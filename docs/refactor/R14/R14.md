is there an alternative to "Automation can use X-API-Key (from Secret Manager) as a secure bypass only in staging." i.e. simple and same as normal use?
ChatGPT said:
Thought for 16s

Yes — you can make staging OAuth-only (no API key) and still keep it easy for humans, headless tests, and API clients.

The clean alternative is: use the exact same Bearer-token path everywhere and let automation get a real OAuth token via the OAuth 2.0 Device Code flow (a.k.a. “device flow”). Both Google and GitHub support it. No bypass keys, no special staging logic — just Authorization: Bearer <token> exactly like production.

Here’s how to wire it up fast.

1) Flip staging to OAuth-only (no API key)

In your deploy script, set the app to OAuth mode and drop TEST_API_KEY usage:

Change:

--set-env-vars="..., AUTH_MODE=hybrid, API_AUTH_MODE=hybrid, ..."


To:

--set-env-vars="..., AUTH_MODE=oauth, API_AUTH_MODE=oauth, ..."


(Keep Cloud Run private with IAM as you already do. That’s your edge gate. Inside the app, accept OAuth Bearer tokens from Google/GitHub per your story.)

2) Manual browser access (unchanged)

You (or any tester you grant roles/run.invoker) open the staging URL.

The app’s normal Google/GitHub OAuth flow runs — no special staging bypass needed.

3) Headless & API clients (use Device Flow to mint real tokens)
Option A — Google (get an ID token with openid email profile)

Use a “TVs and Limited Input devices” OAuth client in your Google Cloud project (or reuse an existing web client if it’s permitted for device flow). Then run this minimal Python script to get an id_token you can pass as a Bearer token:

# google_device_flow.py
import time, sys, requests

CLIENT_ID = sys.argv[1]
SCOPES = "openid email profile"
DEVICE_ENDPOINT = "https://oauth2.googleapis.com/device/code"
TOKEN_ENDPOINT  = "https://oauth2.googleapis.com/token"

# 1) Start device flow
r = requests.post(DEVICE_ENDPOINT, data={"client_id": CLIENT_ID, "scope": SCOPES})
r.raise_for_status()
data = r.json()
print(f"Visit: {data['verification_url']}\nCode:  {data['user_code']}")
interval = data.get("interval", 5)

# 2) Poll for token
while True:
    t = requests.post(TOKEN_ENDPOINT, data={
        "client_id": CLIENT_ID,
        "device_code": data["device_code"],
        "grant_type": "urn:ietf:params:oauth:grant-type:device_code",
    })
    j = t.json()
    if t.status_code == 200:
        # j contains access_token and (importantly) id_token
        print(j["id_token"])
        break
    elif j.get("error") in ("authorization_pending", "slow_down"):
        time.sleep(interval)
    else:
        raise SystemExit(f"Auth failed: {j}")


Usage:

# One-time interactive: shows URL + code to approve as YOUR user.
python google_device_flow.py <GOOGLE_OAUTH_CLIENT_ID> > id_token.txt
ID_TOKEN=$(cat id_token.txt)

# Use it exactly like production:
curl -H "Authorization: Bearer $ID_TOKEN" \
     -H "Content-Type: application/json" \
     -d '{"query":"CWE-79","persona":"DEVELOPER"}' \
     "$APP_URL/api/v1/query"


Your backend verifies this Google ID token (JWT) with Google’s public keys & your client ID (audience) — exactly as in your acceptance criteria.

Option B — GitHub (get an access token via Device Flow)
# 1) Start device flow
CLIENT_ID="<GITHUB_OAUTH_CLIENT_ID>"
resp=$(curl -s -X POST https://github.com/login/device/code \
  -H "Accept: application/json" \
  -d "client_id=$CLIENT_ID&scope=read:user user:email")
DEVICE_CODE=$(echo "$resp" | jq -r .device_code)
USER_CODE=$(echo "$resp" | jq -r .user_code)
VERIFICATION_URI=$(echo "$resp" | jq -r .verification_uri)
INTERVAL=$(echo "$resp" | jq -r .interval)

echo "Visit: $VERIFICATION_URI"
echo "Code:  $USER_CODE"

# 2) Poll for token
while :; do
  tok=$(curl -s -X POST https://github.com/login/oauth/access_token \
    -H "Accept: application/json" \
    -d "client_id=$CLIENT_ID&device_code=$DEVICE_CODE&grant_type=urn:ietf:params:oauth:grant-type:device_code")
  err=$(echo "$tok" | jq -r .error // empty)
  if [ -z "$err" ]; then
    ACCESS_TOKEN=$(echo "$tok" | jq -r .access_token)
    break
  fi
  [ "$err" = "authorization_pending" ] || [ "$err" = "slow_down" ] || { echo "Auth failed: $tok"; exit 1; }
  sleep "${INTERVAL:-5}"
done

# Use it exactly like production:
curl -H "Authorization: Bearer $ACCESS_TOKEN" \
     -H "Content-Type: application/json" \
     -d '{"query":"CWE-89","persona":"DEVELOPER"}' \
     "$APP_URL/api/v1/query"


Your backend validates the GitHub access token by calling GET https://api.github.com/user (as in your plan), extracts email/login, and applies user-based rate limits.

4) Headless test runners
Python Playwright (unchanged shape — just swap token source)

Instead of sending X-API-Key, send real OAuth tokens:

# conftest.py (snippet)
import os, pytest
from playwright.sync_api import sync_playwright

@pytest.fixture(scope="session")
def auth_headers():
    # Put your minted token (from device flow) into env before running tests
    hdrs = {}
    tok = os.getenv("OAUTH_BEARER")
    if tok:
        hdrs["Authorization"] = f"Bearer {tok}"
    return hdrs


Run:

export OAUTH_BEARER="$(cat id_token.txt)"   # or your GitHub access token
pytest -q

Puppeteer
const token = process.env.OAUTH_BEARER;
await page.setExtraHTTPHeaders({ Authorization: `Bearer ${token}` });
await page.goto(process.env.APP_URL);

Pros of OAuth-only with Device Flow

Same path as production — every client (browser, headless, curl) uses Authorization: Bearer ….

No staging-only keys to rotate or accidentally leak.

Auditable identity — tokens map to real users for rate limits & logs.

Simple CI — a small pre-step to mint a token, then run tests.

When to still keep a key (if you must)

If you have fully non-interactive CI where the device flow is undesirable, you can:

Create a dedicated “bot” user in Google/GitHub and approve the device flow once per run (it takes ~30s).

Or, add a short-lived internal signer that issues your own JWTs (aud = your API) after an OAuth login — but that’s a new auth surface and usually not necessary.

Minimal changes summary

Deploy staging with:

API_AUTH_MODE=oauth

--no-allow-unauthenticated + --ingress=internal-and-cloud-load-balancing

(Optionally grant roles/run.invoker to testers)

Clients/tests:

Mint Google ID token or GitHub access token via device flow.

Send Authorization: Bearer <token> to the same endpoints you already have.

This gives you a simple, uniform, production-identical auth story — no X-API-Key needed.