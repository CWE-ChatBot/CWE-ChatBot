# Implementation Plan: Story 4.3 - Ephemeral Document Ingestion (EDI)

**Story ID:** 4.3.ephemeral-pdf-extraction-system
**Status:** Ready for Implementation
**Plan Version:** 2.0 (Comprehensive)

## Executive Summary

Implement ephemeral PDF and text file processing with a **Cloud Functions v2** backend for isolated PDF handling, while text files are processed locally in Chainlit (Cloud Run). Enforce IAM+OIDC service-to-service authentication, private ingress, and zero persistence.

## Pre-Implementation Checklist

- [ ] **Environment Access**: Verify GCP project access and required permissions
- [ ] **Service Accounts**: Confirm Chainlit SA exists and can be granted cloudfunctions.invoker
- [ ] **Dependencies**: Review pikepdf, pdfminer.six library security advisories
- [ ] **Existing Code**: Review apps/chatbot/src/file_processor.py for integration points
- [ ] **Cloud Functions Quota**: Verify Cloud Functions v2 API enabled and quota available
- [ ] **Testing Environment**: Prepare test PDFs (valid, encrypted, image-only, malicious)
- [ ] **Security Review**: Load python-common-vulns.md and python-secure-coding.md

## Architecture Overview

```
User → Chainlit (Cloud Run) → [File Type Detection]
                                   ├─ PDF → Cloud Functions v2 Worker (OIDC auth)
                                   └─ Text → Local in-memory processing
```

**Key Design Decisions:**
- **PDF isolation**: Separate Cloud Function eliminates PDF library risks from main app
- **Text local**: Simple UTF-8 validation doesn't require isolation
- **OIDC auth**: Google-signed tokens eliminate shared secrets
- **No persistence**: Memory-only processing enforces ephemerality

## Goal

Implement the PDF processing backend as **Cloud Functions v2** to emphasize ephemerality, while keeping Chainlit on Cloud Run. Enforce IAM+OIDC S2S, private ingress, and zero persistence.

## Architecture

```
Chainlit (Cloud Run) ──(OIDC ID token, audience=function URL)──> PDF Worker (Cloud Functions v2, private)
```

## Function Interface

* **HTTP** `POST /` (entrypoint), `Content-Type: application/pdf`.
* **Auth**: Bearer **OIDC ID token** (aud = function URL). IAM requires `roles/cloudfunctions.invoker` for the Chainlit SA.
* **Response**: JSON `{ text: string, pages: number, sanitized: boolean }`.
* **Limits**: body ≤ 10 MB; ≤ 50 pages; ≤ 60s execution; output text ≤ 1,000,000 chars.

## Implementation (Python)

```python
# main.py (Cloud Functions v2 - Python)
import io
import json
import os
from flask import Flask, request, jsonify
import pikepdf
from pdfminer.high_level import extract_text

app = Flask(__name__)

MAX_BYTES = 10 * 1024 * 1024
MAX_PAGES = 50

@app.after_request
def headers(r):
    r.headers['X-Content-Type-Options'] = 'nosniff'
    r.headers['Referrer-Policy'] = 'no-referrer'
    return r

@app.route('/', methods=['POST'])
def handle():
    if request.content_type != 'application/pdf':
        return ('Unsupported Content-Type', 415)

    raw = request.get_data(cache=False, as_text=False)
    if not raw or len(raw) > MAX_BYTES:
        return ('Payload too large', 413)

    try:
        with pikepdf.open(io.BytesIO(raw)) as pdf:
            if '/OpenAction' in pdf.root: del pdf.root['/OpenAction']
            if '/AA' in pdf.root: del pdf.root['/AA']
            if '/Names' in pdf.root and '/JavaScript' in pdf.root['/Names']:
                del pdf.root['/Names']['/JavaScript']
            if '/AcroForm' in pdf.root:
                af = pdf.root['/AcroForm']
                if '/XFA' in af: del af['/XFA']
                if '/NeedAppearances' in af: del af['/NeedAppearances']
            if '/Names' in pdf.root and '/EmbeddedFiles' in pdf.root['/Names']:
                del pdf.root['/Names']['/EmbeddedFiles']
            buf = io.BytesIO()
            pdf.save(buf)
            sanitized = buf.getvalue()
    except Exception:
        return ('Failed to sanitize PDF', 422)

    try:
        text = extract_text(io.BytesIO(sanitized), maxpages=MAX_PAGES) or ''
    except Exception:
        return ('Failed to extract text', 422)

    pages = _count_pages(sanitized)
    text = text[:1_000_000]
    return jsonify({ 'text': text, 'pages': pages, 'sanitized': True })


def _count_pages(data: bytes) -> int:
    try:
        with pikepdf.open(io.BytesIO(data)) as pdf:
            return len(pdf.pages)
    except Exception:
        return 0

# entry point for Functions v2
def function_entry(request):
    with app.app_context():
        return app.full_dispatch_request()
```

`requirements.txt`

```
Flask==3.0.3
pikepdf==9.4.0
pdfminer.six==20240706
```

## Deployment (gcloud)

```bash
gcloud functions deploy pdf-worker \
  --gen2 \
  --region=$REGION \
  --runtime=python312 \
  --entry-point=function_entry \
  --trigger-http \
  --no-allow-unauthenticated \
  --memory=512Mi --timeout=60s \
  --set-env-vars=EXPECTED_AUDIENCE=https://$REGION-$PROJECT.cloudfunctions.net/pdf-worker

# Grant invoker to Chainlit SA only
CHAINLIT_SA="chatbot-sa@$PROJECT.iam.gserviceaccount.com"
gcloud functions add-iam-policy-binding pdf-worker \
  --member=serviceAccount:$CHAINLIT_SA \
  --role=roles/cloudfunctions.invoker \
  --region=$REGION --gen2
```

## Terraform (sketch)

```hcl
resource "google_cloudfunctions2_function" "pdf_worker" {
  name     = "pdf-worker"
  location = var.region
  build_config {
    runtime     = "python312"
    entry_point = "function_entry"
    source {
      storage_source { bucket = var.source_bucket, object = var.source_object }
    }
  }
  service_config {
    available_memory      = "512Mi"
    timeout_seconds       = 60
    ingress_settings      = "ALLOW_INTERNAL_ONLY" # or internal-and-gclb if needed
    service_account_email = google_service_account.pdf_worker_sa.email
    environment_variables = { EXPECTED_AUDIENCE = var.pdf_worker_url }
  }
}

resource "google_service_account" "pdf_worker_sa" {
  account_id   = "pdf-worker-sa"
  display_name = "PDF Worker SA"
}

resource "google_cloud_run_service_iam_member" "invoker" {
  service  = google_cloudfunctions2_function.pdf_worker.name
  location = var.region
  role     = "roles/cloudfunctions.invoker"
  member   = "serviceAccount:${google_service_account.chatbot_sa.email}"
}
```

## Chainlit Caller (OIDC)

* Fetch OIDC token from metadata server with **audience = function URL**.
* Send `Authorization: Bearer <token>` and `Content-Type: application/pdf`.
* Timeout at 55s; retry once on transient 5xx.

## Testing

* Negative auth: missing token / wrong `aud` / expired → 401/403.
* Oversized payload → 413; encrypted → 422; image-only → 422.
* No content written to disk; only `/tmp` used by libraries.

## Notes

* Cloud Functions v2 is built on Cloud Run; IAM/OIDC behavior is identical from the caller's perspective.
* Keep function **not public** and out of any external LB. Rate limit at the **Chainlit edge** only with Cloud Armor.

---

## Detailed Implementation Steps

### Phase 1: Cloud Functions v2 PDF Worker (AC2, AC5, AC6)

#### Step 1.1: Create Worker Directory Structure
```bash
mkdir -p apps/pdf_worker
cd apps/pdf_worker
```

**Files to create:**
- `main.py` - Function handler (see implementation above)
- `requirements.txt` - Dependencies
- `.gcloudignore` - Exclude unnecessary files from deployment
- `README.md` - Deployment and testing instructions

#### Step 1.2: Implement PDF Sanitization Logic

**Security Requirements** (from python-secure-coding.md):
```python
# main.py security checklist:
# ✓ Input validation: PDF magic bytes check
# ✓ Size limits: MAX_BYTES = 10MB, MAX_PAGES = 50
# ✓ Timeout: 60s function timeout
# ✓ Sanitization: Remove OpenAction, AA, JavaScript, XFA, embedded files
# ✓ No disk writes: Use io.BytesIO only
# ✓ Error handling: Catch all exceptions, return stable error codes
# ✓ No logging of content: Metadata only
```

**Implementation checklist:**
- [ ] Import pikepdf for PDF manipulation
- [ ] Import pdfminer.six for text extraction
- [ ] Validate PDF magic bytes (`%PDF-`)
- [ ] Remove dangerous PDF features (OpenAction, AA, JavaScript, XFA, embedded files)
- [ ] Extract text with max 50 pages limit
- [ ] Truncate output to 1,000,000 chars
- [ ] Return JSON response with metadata only

#### Step 1.3: Deploy Cloud Function

```bash
export PROJECT=$(gcloud config get-value project)
export REGION=us-central1
export FUNCTION_URL=https://$REGION-$PROJECT.cloudfunctions.net/pdf-worker

gcloud functions deploy pdf-worker \
  --gen2 \
  --region=$REGION \
  --runtime=python312 \
  --entry-point=function_entry \
  --trigger-http \
  --no-allow-unauthenticated \
  --memory=512Mi \
  --timeout=60s \
  --max-instances=10 \
  --ingress-settings=internal-only \
  --set-env-vars=EXPECTED_AUDIENCE=$FUNCTION_URL
```

**Verification:**
```bash
# Should return 403 Forbidden (no auth)
curl -X POST $FUNCTION_URL \
  -H "Content-Type: application/pdf" \
  --data-binary @test.pdf
```

#### Step 1.4: Configure IAM Permissions

```bash
# Get Chainlit service account
CHAINLIT_SA=$(gcloud run services describe cwe-chatbot \
  --region=$REGION \
  --format='value(spec.template.spec.serviceAccountName)')

# Grant invoker role
gcloud functions add-iam-policy-binding pdf-worker \
  --gen2 \
  --region=$REGION \
  --member="serviceAccount:$CHAINLIT_SA" \
  --role="roles/cloudfunctions.invoker"
```

**Verification:**
```bash
gcloud functions get-iam-policy pdf-worker \
  --gen2 --region=$REGION
```

### Phase 2: Chainlit File Upload Handler (AC1, AC3, AC4)

#### Step 2.1: Update File Processor

**File:** `apps/chatbot/src/file_processor.py`

**Add content type detection:**
```python
def detect_file_type(content: bytes) -> str:
    """
    Detect file type via magic bytes (content sniffing).

    Returns: 'pdf', 'text', or 'unknown'
    """
    if content.startswith(b'%PDF-'):
        return 'pdf'

    # Text validation: check for NUL bytes and printable ratio
    if b'\x00' in content:
        return 'unknown'

    try:
        text = content.decode('utf-8', errors='strict')
        # Calculate printable ratio (allow \n, \r, \t)
        printable = sum(1 for c in text if c.isprintable() or c in '\n\r\t')
        ratio = printable / len(text) if text else 0

        if ratio >= 0.9:
            return 'text'
    except UnicodeDecodeError:
        pass

    return 'unknown'
```

**Add OIDC token fetcher:**
```python
import google.auth
import google.auth.transport.requests
from google.auth import compute_engine

def get_oidc_token(audience: str) -> str:
    """
    Fetch OIDC ID token from metadata server.

    Security: Token audience bound to function URL.
    """
    credentials = compute_engine.IDTokenCredentials(
        request=google.auth.transport.requests.Request(),
        target_audience=audience
    )
    credentials.refresh(google.auth.transport.requests.Request())
    return credentials.token
```

**Add PDF worker client:**
```python
import httpx

async def call_pdf_worker(
    pdf_bytes: bytes,
    worker_url: str,
    timeout: int = 55
) -> dict:
    """
    Call Cloud Functions PDF worker with OIDC auth.

    Returns: {'text': str, 'pages': int, 'sanitized': bool}
    Raises: HTTPStatusError on 4xx/5xx
    """
    token = get_oidc_token(audience=worker_url)

    async with httpx.AsyncClient(timeout=timeout) as client:
        response = await client.post(
            worker_url,
            content=pdf_bytes,
            headers={
                'Authorization': f'Bearer {token}',
                'Content-Type': 'application/pdf'
            },
            follow_redirects=False  # Security: no redirects
        )
        response.raise_for_status()
        return response.json()
```

#### Step 2.2: Implement Text File Handler

**Add to file_processor.py:**
```python
def process_text_file(content: bytes, max_chars: int = 1_000_000) -> str:
    """
    Process text file with strict validation.

    Security:
    - NUL byte rejection
    - UTF-8 strict decoding
    - Printable ratio check
    - Line length limit
    - Character truncation
    """
    # Reject NUL bytes
    if b'\x00' in content:
        raise ValueError("binary_text_rejected")

    # UTF-8 decode with strict errors
    try:
        text = content.decode('utf-8', errors='strict')
    except UnicodeDecodeError:
        # Fallback: try chardet detection once
        import chardet
        detected = chardet.detect(content)
        if detected['confidence'] < 0.8:
            raise ValueError("decoding_failed")
        text = content.decode(detected['encoding'], errors='strict')

    # Check printable ratio
    printable = sum(1 for c in text if c.isprintable() or c in '\n\r\t')
    ratio = printable / len(text) if text else 0
    if ratio < 0.9:
        raise ValueError("binary_text_rejected")

    # Reject pathologically long lines (2MB limit)
    lines = text.split('\n')
    if any(len(line) > 2 * 1024 * 1024 for line in lines):
        raise ValueError("line_too_long")

    # Truncate to max chars
    if len(text) > max_chars:
        text = text[:max_chars]
        return text + "\n\n[Content truncated at 1,000,000 characters]"

    return text
```

#### Step 2.3: Update Chainlit Message Handler

**File:** `apps/chatbot/main.py`

**Update `@cl.on_message` to handle file uploads:**
```python
@cl.on_message
async def main(message: cl.Message):
    # ... existing auth checks ...

    # Handle file uploads
    if message.elements:
        for element in message.elements:
            if isinstance(element, cl.File):
                try:
                    file_content = await process_uploaded_file(element)
                    # Append to user query
                    user_query += f"\n\n--- File Content ({element.name}) ---\n{file_content}"
                except ValueError as e:
                    await cl.Message(
                        content=f"❌ File processing error: {get_friendly_error(str(e))}"
                    ).send()
                    return

    # ... continue with normal message processing ...
```

**Add file processing dispatcher:**
```python
async def process_uploaded_file(file: cl.File) -> str:
    """
    Process uploaded file based on content type.

    Dispatches to PDF worker or local text processor.
    """
    # Enforce 10MB limit
    if file.size > 10 * 1024 * 1024:
        raise ValueError("too_large")

    content = await file.read()
    file_type = detect_file_type(content)

    if file_type == 'pdf':
        # Call Cloud Functions PDF worker
        worker_url = os.getenv('PDF_WORKER_URL')
        if not worker_url:
            raise ValueError("pdf_worker_not_configured")

        try:
            result = await call_pdf_worker(content, worker_url)
            return result['text']
        except httpx.HTTPStatusError as e:
            if e.response.status_code == 413:
                raise ValueError("too_large")
            elif e.response.status_code == 422:
                # Parse error code from response
                error = e.response.json().get('error', 'invalid_content')
                raise ValueError(error)
            elif e.response.status_code in (401, 403):
                raise ValueError("auth_failed")
            else:
                raise ValueError("pdf_processing_failed")

    elif file_type == 'text':
        # Process locally
        return process_text_file(content)

    else:
        raise ValueError("invalid_content_type")
```

**Add friendly error messages:**
```python
def get_friendly_error(error_code: str) -> str:
    """Map error codes to user-friendly messages."""
    messages = {
        'too_large': 'File exceeds 10MB limit. Please upload a smaller file.',
        'too_many_pages': 'PDF exceeds 50 pages. Please split into smaller documents.',
        'timeout': 'File processing timed out. Try a smaller file.',
        'invalid_content_type': 'Unsupported file type. Please upload PDF or text files.',
        'pdf_magic_missing': 'File does not appear to be a valid PDF.',
        'encrypted_pdf_unsupported': 'Encrypted PDFs are not supported. Please remove password protection.',
        'image_only_pdf_unsupported': 'Image-only PDFs require OCR which is not supported.',
        'binary_text_rejected': 'File contains binary data and cannot be processed as text.',
        'decoding_failed': 'Text encoding could not be determined.',
        'auth_failed': 'PDF processing service authentication failed.',
        'pdf_worker_not_configured': 'PDF processing is not configured.',
    }
    return messages.get(error_code, f'Unknown error: {error_code}')
```

### Phase 3: Testing & Validation (AC7, AC8)

#### Step 3.1: Unit Tests

**File:** `apps/pdf_worker/test_main.py`

```python
import pytest
from main import app

@pytest.fixture
def client():
    app.config['TESTING'] = True
    with app.test_client() as client:
        yield client

def test_missing_content_type(client):
    """Test rejection of missing Content-Type header."""
    response = client.post('/', data=b'%PDF-1.4...')
    assert response.status_code == 415

def test_oversized_payload(client):
    """Test rejection of >10MB payload."""
    large_pdf = b'%PDF-1.4' + (b'x' * (11 * 1024 * 1024))
    response = client.post(
        '/',
        data=large_pdf,
        content_type='application/pdf'
    )
    assert response.status_code == 413

def test_invalid_pdf_magic(client):
    """Test rejection of non-PDF content."""
    response = client.post(
        '/',
        data=b'Not a PDF',
        content_type='application/pdf'
    )
    assert response.status_code == 422

def test_security_headers(client):
    """Test presence of security headers."""
    response = client.post('/', data=b'test')
    assert response.headers['X-Content-Type-Options'] == 'nosniff'
    assert response.headers['Referrer-Policy'] == 'no-referrer'
```

**File:** `apps/chatbot/tests/unit/test_file_processor.py`

```python
import pytest
from src.file_processor import detect_file_type, process_text_file

def test_pdf_detection():
    """Test PDF magic byte detection."""
    assert detect_file_type(b'%PDF-1.4...') == 'pdf'

def test_text_detection():
    """Test text file detection."""
    assert detect_file_type(b'Hello, world!') == 'text'

def test_binary_rejection():
    """Test binary content rejection."""
    assert detect_file_type(b'\x00\x01\x02') == 'unknown'

def test_nul_byte_rejection():
    """Test NUL byte rejection in text."""
    with pytest.raises(ValueError, match='binary_text_rejected'):
        process_text_file(b'Hello\x00World')

def test_printable_ratio():
    """Test printable ratio enforcement."""
    # Binary data should fail
    with pytest.raises(ValueError):
        process_text_file(b'\x01\x02\x03' * 100)

def test_truncation():
    """Test character truncation."""
    long_text = b'x' * 2_000_000
    result = process_text_file(long_text)
    assert len(result) <= 1_000_050  # Allow for truncation marker
    assert '[truncated]' in result.lower()
```

#### Step 3.2: Integration Tests

**File:** `apps/chatbot/tests/integration/test_pdf_worker.py`

```python
import pytest
import httpx
import os

PDF_WORKER_URL = os.getenv('PDF_WORKER_URL')

@pytest.mark.skipif(not PDF_WORKER_URL, reason="PDF_WORKER_URL not set")
async def test_pdf_worker_auth():
    """Test that PDF worker requires authentication."""
    async with httpx.AsyncClient() as client:
        # Should fail without auth token
        with pytest.raises(httpx.HTTPStatusError) as exc:
            response = await client.post(
                PDF_WORKER_URL,
                content=b'%PDF-test',
                headers={'Content-Type': 'application/pdf'}
            )
            response.raise_for_status()

        assert exc.value.response.status_code in (401, 403)

@pytest.mark.skipif(not PDF_WORKER_URL, reason="PDF_WORKER_URL not set")
async def test_pdf_worker_valid_pdf():
    """Test PDF worker with valid PDF."""
    from src.file_processor import get_oidc_token

    token = get_oidc_token(audience=PDF_WORKER_URL)

    # Load test PDF
    with open('tests/fixtures/valid.pdf', 'rb') as f:
        pdf_content = f.read()

    async with httpx.AsyncClient(timeout=60) as client:
        response = await client.post(
            PDF_WORKER_URL,
            content=pdf_content,
            headers={
                'Authorization': f'Bearer {token}',
                'Content-Type': 'application/pdf'
            }
        )
        assert response.status_code == 200
        data = response.json()
        assert 'text' in data
        assert 'pages' in data
        assert data['sanitized'] is True
```

#### Step 3.3: Security Tests

**File:** `tests/security/test_pdf_security.py`

```python
import pytest
from apps.pdf_worker.main import app

def test_encrypted_pdf_rejection():
    """Test rejection of encrypted PDFs."""
    with open('tests/fixtures/encrypted.pdf', 'rb') as f:
        encrypted_pdf = f.read()

    client = app.test_client()
    response = client.post(
        '/',
        data=encrypted_pdf,
        content_type='application/pdf'
    )
    assert response.status_code == 422

def test_javascript_removal():
    """Test JavaScript removal from PDF."""
    # Create PDF with JavaScript
    import pikepdf
    pdf = pikepdf.new()
    pdf.Root.OpenAction = pikepdf.Dictionary({'/S': '/JavaScript'})

    # Process through sanitization
    # Verify JavaScript removed
    # (Implementation detail test)
```

### Phase 4: Deployment & Configuration

#### Step 4.1: Update Chainlit Environment Variables

**Add to Cloud Run deployment:**
```bash
gcloud run services update cwe-chatbot \
  --region=$REGION \
  --set-env-vars="PDF_WORKER_URL=$FUNCTION_URL"
```

#### Step 4.2: Update Dependencies

**apps/chatbot/requirements.txt:**
```
google-auth==2.25.2
httpx==0.25.2
chardet==5.2.0
```

**apps/pdf_worker/requirements.txt:**
```
Flask==3.0.3
pikepdf==9.4.0
pdfminer.six==20240706
```

#### Step 4.3: Configure Cloud Armor (AC9)

```bash
# Create security policy
gcloud compute security-policies create pdf-upload-policy \
  --description="Rate limiting for PDF uploads"

# Add rate limiting rule
gcloud compute security-policies rules create 1000 \
  --security-policy=pdf-upload-policy \
  --expression="request.path.matches('/upload')" \
  --action=rate-based-ban \
  --rate-limit-threshold-count=20 \
  --rate-limit-threshold-interval-sec=60 \
  --ban-duration-sec=600 \
  --conform-action=allow \
  --exceed-action=deny-429

# Attach to load balancer (if using external LB)
# gcloud compute backend-services update ... --security-policy=pdf-upload-policy
```

## Verification Procedures

### Functional Verification
- [ ] Upload valid PDF (< 10MB, < 50 pages) - Success
- [ ] Upload valid text file - Success
- [ ] Upload encrypted PDF - Friendly error message
- [ ] Upload > 10MB file - "too_large" error
- [ ] Upload > 50 page PDF - "too_many_pages" error
- [ ] Upload binary file - "invalid_content_type" error

### Security Verification
- [ ] Call PDF worker without token - 401/403
- [ ] Call PDF worker with wrong audience - 403
- [ ] Verify no file persistence (check /tmp, container filesystem)
- [ ] Verify no content in logs (grep for file content)
- [ ] Test JavaScript removal from PDF
- [ ] Test embedded file removal from PDF

### Performance Verification
- [ ] p50 latency < 2s
- [ ] p95 latency < 5s
- [ ] p99 latency < 10s
- [ ] Error rate < 1%

## Rollback Plan

If issues occur:
1. **PDF Worker issues**: Disable PDF uploads in Chainlit (env var `ENABLE_PDF_UPLOAD=false`)
2. **Auth issues**: Verify IAM bindings and service account configuration
3. **Performance issues**: Reduce max instances on Cloud Function
4. **Complete rollback**: Remove PDF upload UI, keep text-only processing

## Success Criteria

- [ ] All acceptance criteria (AC1-AC10) implemented
- [ ] All unit tests passing
- [ ] Integration tests passing with real Cloud Function
- [ ] Security tests passing
- [ ] Performance meets SLOs
- [ ] No content logged (verified)
- [ ] Documentation complete
- [ ] Story status updated to "Ready for Review"
