PDF Worker (Cloud Functions v2) – No‑Flask Implementation & Plan Deltas

This document replaces any Flask app usage with a framework‑light, native Cloud Functions v2 HTTP handler using functions-framework. It also lists the exact deployment, testing, and E2E changes. The Story 4.3 acceptance criteria remain unchanged (framework‑agnostic).

1) Minimal no‑Flask HTTP Function (Python)

apps/pdf_worker/main.py

import io
        return ("Method Not Allowed", 405, {"Allow": "POST"})
    if request.headers.get("Content-Type") != "application/pdf":
        return ("Unsupported Content-Type", 415, _sec_headers())


    if not _aud_ok(request):
        return ("audience mismatch", 401, _sec_headers())


    raw = request.get_data(cache=False, as_text=False)
    if not raw:
        return ("Empty body", 400, _sec_headers())
    if len(raw) > MAX_BYTES:
        return ("Payload too large", 413, _sec_headers())


    # Sanitize
    try:
        with pikepdf.open(io.BytesIO(raw)) as pdf:
            if "/OpenAction" in pdf.root: del pdf.root["/OpenAction"]
            if "/AA" in pdf.root: del pdf.root["/AA"]
            if "/Names" in pdf.root and "/JavaScript" in pdf.root["/Names"]:
                del pdf.root["/Names"]["/JavaScript"]
            if "/AcroForm" in pdf.root:
                af = pdf.root["/AcroForm"]
                if "/XFA" in af: del af["/XFA"]
                if "/NeedAppearances" in af: del af["/NeedAppearances"]
            if "/Names" in pdf.root and "/EmbeddedFiles" in pdf.root["/Names"]:
                del pdf.root["/Names"]["/EmbeddedFiles"]
            mem = io.BytesIO()
            pdf.save(mem)
            sanitized = mem.getvalue()
    except Exception:
        return ("Failed to sanitize PDF", 422, _sec_headers())


    # Extract
    try:
        text = extract_text(io.BytesIO(sanitized), maxpages=MAX_PAGES) or ""
    except Exception:
        return ("Failed to extract text", 422, _sec_headers())


    pages = _count_pages(sanitized)
    body = json.dumps({
        "text": text[:1_000_000],
        "pages": pages,
        "sanitized": True
    })
    return (body, 200, _sec_headers_json())




def _count_pages(data: bytes) -> int:
    try:
        with pikepdf.open(io.BytesIO(data)) as pdf:
            return len(pdf.pages)
    except Exception:
        return 0




def _sec_headers():
    return {
        "X-Content-Type-Options": "nosniff",
        "Referrer-Policy": "no-referrer",
        "X-Frame-Options": "DENY",
        "Permissions-Policy": "geolocation=(), microphone=()",
    }




def _sec_headers_json():
    h = _sec_headers()
    h["Content-Type"] = "application/json"
    return h

apps/pdf_worker/requirements.txt

functions-framework==3.5.0
pikepdf==9.4.0
pdfminer.six==20240706

Notes

No Flask import or app object. functions-framework provides the HTTP entry shim that Cloud Functions v2 expects.

If you want an explicit audience check, you’ll need to decode and verify the token yourself (adds crypto deps). The platform already validates signature/expiry/aud for you; keep this simple unless your threat model requires app‑level aud verification.

2) Deploy (CF v2) without Flask
PROJECT_ID=$(gcloud config get-value project)
REGION=us-central1
SA_PDF_WORKER=pdf-worker@${PROJECT_ID}.iam.gserviceaccount.com
cd apps/pdf_worker


# A) initial deploy (placeholder aud)
gcloud functions deploy pdf-worker \
  --gen2 --region=$REGION --runtime=python312 --source=. \
  --entry-point=function_entry --trigger-http --no-allow-unauthenticated \
  --memory=512Mi --timeout=60s --max-instances=10 --min-instances=0 \
  --ingress-settings=internal-only --service-account=$SA_PDF_WORKER \
  --set-env-vars=EXPECTED_AUDIENCE=PLACEHOLDER


FUNCTION_URL=$(gcloud functions describe pdf-worker --gen2 --region=$REGION \
  --format='value(serviceConfig.uri)')


gcloud functions deploy pdf-worker \
  --gen2 --region=$REGION --runtime=python312 --source=. \
  --entry-point=function_entry --trigger-http --no-allow-unauthenticated \
  --memory=512Mi --timeout=60s --max-instances=10 --min-instances=0 \
  --ingress-settings=internal-only --service-account=$SA_PDF_WORKER \
  --set-env-vars=EXPECTED_AUDIENCE=${FUNCTION_URL}

Sanity

# Unauth → 401/403
curl -sSi "$FUNCTION_URL" | head -n 20


# With local ID token (no metadata server)
IDT=$(gcloud auth print-identity-token --audiences="$FUNCTION_URL")
curl -sSi -X POST "$FUNCTION_URL" \
  -H "Authorization: Bearer $IDT" -H "Content-Type: application/pdf" \
  --data-binary @tests/fixtures/sample.pdf | head -n 60
3) Chainlit Client – Dev‑only OIDC fallback (no Flask involved)

In your Chainlit PDF client, add a dev‑only fallback when not on GCP:

import os, subprocess


def _mint_id_token(audience: str) -> str:
    # Primary: metadata server (GCP)
    try:
        import requests
        r = requests.get(
            "http://metadata/computeMetadata/v1/instance/service-accounts/default/identity",
            params={"audience": audience, "format": "full"},
            headers={"Metadata-Flavor": "Google"}, timeout=3
        )
        r.raise_for_status()
        return r.text
    except Exception:
        pass


    # Dev fallback: gcloud (guard with env)
    if os.getenv("ALLOW_GCLOUD_OIDC") == "1":
        return subprocess.check_output([
            "gcloud", "auth", "print-identity-token", f"--audiences={audience}"
        ], text=True, timeout=5).strip()
    raise RuntimeError("OIDC token unavailable (not on GCP and dev fallback disabled)")
4) Testing Matrix (Real PDFs)

Create three files in tests/fixtures/ and run:

for f in sample.pdf encrypted.pdf scanned.pdf; do 
  IDT=$(gcloud auth print-identity-token --audiences="$FUNCTION_URL"); 
  code=$(curl -s -o /dev/null -w "%{http_code}" -X POST "$FUNCTION_URL" \
    -H "Authorization: Bearer $IDT" -H "Content-Type: application/pdf" \
    --data-binary @tests/fixtures/$f); 
  echo "$f -> $code"; 
done

Expected: sample.pdf → 200; encrypted.pdf → 422; scanned.pdf → 422.

5) Plan Deltas (apply to your Deployment & E2E docs)

Replace any Flask references with functions‑framework only.

Ensure all deploy commands use --entry-point=function_entry (callable).

Security headers: set via tuple return (body, status, headers) as shown.

Logs queries: keep Cloud Run revision filter for CF v2.

Local OIDC: document gcloud auth print-identity-token usage + ALLOW_GCLOUD_OIDC=1 guard.

No redirects in HTTP client; timeout ≤ 55s; retry once on 5xx only.

6) Requirements Recap

Runtime: Cloud Functions v2 (Python 3.12)

Libs: functions-framework, pikepdf, pdfminer.six

Auth: OIDC ID token with aud = FUNCTION_URL (platform‑verified); optional app‑level aud check.

Limits: 10 MB body, 50 pages, 60s timeout, 1,000,000 chars cap.

Security: no persistence; metadata‑only logs; non‑root; read‑only fs; headers set.