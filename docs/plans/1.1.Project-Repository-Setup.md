# Epic 1.1 Implementation Plan: Project Repository Setup

## Overview
This plan outlines the step-by-step implementation of the foundational repository structure for the CWE ChatBot project. This is a critical first step that will enable all subsequent development work.

## Pre-Implementation Checklist
- [ ] Verify access to CWE-ChatBot GitHub organization
- [ ] Confirm repository naming conventions with team
- [ ] Review monorepo strategy with architecture team
- [ ] Ensure development tools are installed (Python 3.10+, Poetry/PDM, Git)
- [ ] **TDD Requirement**: Prepare to write tests BEFORE implementation code
- [ ] **Security Verification**: Plan manual verification steps for each security control

## Implementation Steps

### Phase 1: Repository Initialization (Estimated: 45 minutes)

#### Step 1.0: TDD Foundation Setup
```bash
# CRITICAL: Follow TDD methodology per CLAUDE.md
# Tests must be written BEFORE implementation code

# Create test structure first
mkdir -p tests/integration
mkdir -p tests/unit
touch tests/__init__.py
touch tests/integration/__init__.py
touch tests/unit/__init__.py

# Create first test file
touch tests/integration/test_repository_structure.py
```

#### Step 1.1: Create Repository Structure
```bash
# Create new repository on GitHub (if not already created)
# Repository: CWE-ChatBot/CWE-ChatBot (already exists)

# Clone and set up local development
git clone git@github.com:CWE-ChatBot/CWE-ChatBot.git
cd CWE-ChatBot
```

#### Step 1.2: Initialize Monorepo Structure
```bash
# Create monorepo directory structure
mkdir -p apps/chatbot
mkdir -p apps/chatbot/src
mkdir -p apps/chatbot/tests
mkdir -p shared/utils
mkdir -p shared/tests
mkdir -p docs/api
mkdir -p scripts
mkdir -p .github/workflows
```

#### Step 1.3: Create Structure Validation Test
```python
# tests/integration/test_repository_structure.py
import os
from pathlib import Path

def test_monorepo_structure_exists():
    """Test that all required directories exist."""
    required_dirs = [
        "apps/chatbot",
        "apps/chatbot/src", 
        "apps/chatbot/tests",
        "shared/utils",
        "shared/tests",
        "docs/api",
        "scripts",
        ".github/workflows"
    ]
    
    for directory in required_dirs:
        assert Path(directory).exists(), f"Required directory {directory} does not exist"

def test_test_structure_exists():
    """Test that test directories have __init__.py files."""
    test_init_files = [
        "tests/__init__.py",
        "tests/integration/__init__.py", 
        "tests/unit/__init__.py",
        "apps/chatbot/tests/__init__.py",
        "shared/tests/__init__.py"
    ]
    
    for init_file in test_init_files:
        assert Path(init_file).exists(), f"Required __init__.py file {init_file} does not exist"

# RUN TEST: poetry run pytest tests/integration/test_repository_structure.py -v
# EXPECTED: FAIL (directories don't exist yet)
```

### Phase 2: Configuration Files (Estimated: 60 minutes)

#### Step 2.0: Configuration Validation Tests
```python
# tests/unit/test_configuration.py
import toml
from pathlib import Path

def test_pyproject_toml_valid():
    """Test that pyproject.toml is valid TOML and has required sections."""
    pyproject_path = Path("pyproject.toml")
    assert pyproject_path.exists(), "pyproject.toml must exist"
    
    config = toml.load(pyproject_path)
    
    # Required sections
    assert "tool" in config
    assert "poetry" in config["tool"]
    assert "dependencies" in config["tool"]["poetry"]
    assert "python" in config["tool"]["poetry"]["dependencies"]
    
    # Python version requirement
    python_version = config["tool"]["poetry"]["dependencies"]["python"]
    assert "^3.10" in python_version or ">=3.10" in python_version

def test_gitignore_comprehensive():
    """Test that .gitignore covers all required patterns."""
    gitignore_path = Path(".gitignore")
    assert gitignore_path.exists(), ".gitignore must exist"
    
    content = gitignore_path.read_text()
    
    required_patterns = [
        "__pycache__/",
        "*.py[cod]",
        ".env",
        ".vscode/",
        "venv/",
        ".pytest_cache/",
        "htmlcov/"
    ]
    
    for pattern in required_patterns:
        assert pattern in content, f"Missing required .gitignore pattern: {pattern}"

def test_env_example_comprehensive():
    """Test that .env.example contains all required variables."""
    env_example_path = Path(".env.example")
    assert env_example_path.exists(), ".env.example must exist"
    
    content = env_example_path.read_text()
    
    required_vars = [
        "DATABASE_URL",
        "CHAINLIT_HOST",
        "CHAINLIT_PORT",
        "SECRET_KEY",
        "LOG_LEVEL"
    ]
    
    for var in required_vars:
        assert var in content, f"Missing required environment variable: {var}"

# RUN TEST: poetry run pytest tests/unit/test_configuration.py -v
# EXPECTED: FAIL (files don't exist yet)
```

#### Step 2.1: Create pyproject.toml (Root Level)
```toml
[build-system]
requires = ["poetry-core"]
build-backend = "poetry.core.masonry.api"

[tool.poetry]
name = "cwe-chatbot"
version = "0.1.0"
description = "CWE ChatBot - Conversational AI for Common Weakness Enumeration"
authors = ["CWE-ChatBot Team"]
packages = [
    {include = "chatbot", from = "apps/chatbot/src"},
    {include = "shared", from = "."},
]

[tool.poetry.dependencies]
python = "^3.10"
# Core dependencies will be added in subsequent stories

[tool.poetry.group.dev.dependencies]
pytest = "^7.4.0"
pytest-cov = "^4.1.0"
black = "^23.0.0"
ruff = "^0.0.284"
mypy = "^1.5.0"
toml = "^0.10.2"
pre-commit = "^3.4.0"

[tool.black]
line-length = 88
target-version = ['py310']

[tool.ruff]
select = ["E", "F", "I", "N", "W"]
ignore = []
line-length = 88
target-version = "py310"

[tool.mypy]
python_version = "3.10"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true

[tool.pytest.ini_options]
testpaths = ["apps/chatbot/tests", "shared/tests"]
python_files = ["test_*.py", "*_test.py"]
addopts = "--cov=apps/chatbot/src --cov=shared --cov-report=html --cov-report=term"
```

#### Step 2.2: Create Comprehensive .gitignore
```gitignore
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# PyInstaller
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
.hypothesis/
.pytest_cache/

# Virtual environments
venv/
env/
ENV/

# Environment variables
.env
.env.local
.env.*.local

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Logs
logs/
*.log

# Temporary files
tmp/
temp/
.tmp/

# Docker
.dockerignore

# Cloud deployment
.gcloudignore

# Application specific
data/
models/
embeddings/
vector_db/
```

#### Step 2.3: Create .env.example
```bash
# Database Configuration
DATABASE_URL=postgresql://user:password@localhost:5432/cwe_chatbot
VECTOR_DB_URL=
VECTOR_DB_API_KEY=

# LLM Configuration
OPENAI_API_KEY=
ANTHROPIC_API_KEY=
GOOGLE_AI_API_KEY=

# Application Configuration
CHAINLIT_HOST=0.0.0.0
CHAINLIT_PORT=8000
LOG_LEVEL=INFO

# Security
SECRET_KEY=
OAUTH_CLIENT_ID=
OAUTH_CLIENT_SECRET=

# Cloud Configuration (GCP)
GOOGLE_CLOUD_PROJECT=
GCP_SERVICE_ACCOUNT_KEY=

# Monitoring
SENTRY_DSN=
```

### Phase 2.5: CI/CD Pipeline Setup (Estimated: 30 minutes)

#### Step 2.5.1: Create GitHub Actions Workflow
```yaml
# .github/workflows/ci.yml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test-and-quality:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python-version: ['3.10', '3.11']
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}
    
    - name: Install Poetry
      uses: snok/install-poetry@v1
      with:
        version: latest
        virtualenvs-create: true
        virtualenvs-in-project: true
    
    - name: Cache Poetry dependencies
      uses: actions/cache@v3
      with:
        path: .venv
        key: venv-${{ runner.os }}-${{ matrix.python-version }}-${{ hashFiles('**/poetry.lock') }}
    
    - name: Install dependencies
      run: poetry install --no-interaction --no-ansi
    
    - name: Run tests
      run: poetry run pytest --cov=apps/chatbot/src --cov=shared --cov-report=xml --cov-report=term-missing
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./coverage.xml
        fail_ci_if_error: false
    
    - name: Run code formatting check
      run: poetry run black --check --diff .
    
    - name: Run linting
      run: poetry run ruff check .
    
    - name: Run type checking
      run: poetry run mypy apps/chatbot/src shared/utils
    
    - name: Run security scan
      run: |
        poetry add --group dev bandit[toml]
        poetry run bandit -r apps/chatbot/src shared/utils -f json -o bandit-report.json || true
        poetry run bandit -r apps/chatbot/src shared/utils

  security-scan:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-results.sarif'
    
    - name: Upload Trivy scan results to GitHub Security tab
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'
```

#### Step 2.5.2: Create Pre-commit Configuration
```yaml
# .pre-commit-config.yaml
repos:
  - repo: https://github.com/pre-commit/pre-commit-hooks
    rev: v4.4.0
    hooks:
      - id: trailing-whitespace
      - id: end-of-file-fixer
      - id: check-yaml
      - id: check-added-large-files
      - id: check-merge-conflict

  - repo: https://github.com/psf/black
    rev: 23.7.0
    hooks:
      - id: black
        language_version: python3.10

  - repo: https://github.com/charliermarsh/ruff-pre-commit
    rev: v0.0.284
    hooks:
      - id: ruff
        args: [--fix]

  - repo: https://github.com/pre-commit/mirrors-mypy
    rev: v1.5.1
    hooks:
      - id: mypy
        additional_dependencies: [types-toml]
        args: [--ignore-missing-imports]

  - repo: https://github.com/PyCQA/bandit
    rev: 1.7.5
    hooks:
      - id: bandit
        args: [-c, pyproject.toml]
```

#### Step 2.5.3: CI/CD Validation Test
```python
# tests/integration/test_cicd_config.py
import yaml
from pathlib import Path

def test_github_workflow_exists():
    """Test that CI/CD workflow file exists and is valid YAML."""
    workflow_path = Path(".github/workflows/ci.yml")
    assert workflow_path.exists(), "CI workflow file must exist"
    
    with open(workflow_path) as f:
        workflow = yaml.safe_load(f)
    
    assert "name" in workflow
    assert "on" in workflow
    assert "jobs" in workflow
    assert "test-and-quality" in workflow["jobs"]

def test_precommit_config_exists():
    """Test that pre-commit configuration exists."""
    precommit_path = Path(".pre-commit-config.yaml")
    assert precommit_path.exists(), "Pre-commit config must exist"
    
    with open(precommit_path) as f:
        config = yaml.safe_load(f)
    
    assert "repos" in config
    assert len(config["repos"]) > 0

# RUN TEST: poetry run pytest tests/integration/test_cicd_config.py -v
# EXPECTED: FAIL (files don't exist yet)
```

### Phase 3: Documentation (Estimated: 30 minutes)

#### Step 3.1: Create Comprehensive README.md
```markdown
# CWE ChatBot

A conversational AI application designed to revolutionize interaction with the MITRE Common Weakness Enumeration (CWE) corpus.

## Overview

The CWE ChatBot enables cybersecurity professionals to interact with CWE data through natural language conversations, providing contextual, role-based responses for vulnerability analysis and prevention.

## Quick Start

### Prerequisites
- Python 3.10 or higher
- Poetry (recommended) or pip
- Git

### Installation

1. Clone the repository:
   ```bash
   git clone git@github.com:CWE-ChatBot/CWE-ChatBot.git
   cd CWE-ChatBot
   ```

2. Install dependencies:
   ```bash
   poetry install
   ```

3. Set up environment variables:
   ```bash
   cp .env.example .env
   # Edit .env with your configuration
   ```

4. Run the application (when available):
   ```bash
   poetry run chainlit run apps/chatbot/main.py
   ```

## Architecture

This project uses a monorepo structure:

```
CWE-ChatBot/
â”œâ”€â”€ apps/
â”‚   â””â”€â”€ chatbot/           # Main Chainlit application
â”‚       â”œâ”€â”€ src/
â”‚       â””â”€â”€ tests/
â”œâ”€â”€ shared/                # Shared utilities and libraries
â”œâ”€â”€ docs/                  # Project documentation
â”œâ”€â”€ scripts/               # Utility scripts
â”œâ”€â”€ pyproject.toml         # Project configuration
â””â”€â”€ README.md
```

## Development

### Code Quality
- **Formatting**: Black (line length: 88)
- **Linting**: Ruff
- **Type Checking**: MyPy
- **Testing**: Pytest with coverage

### Running Tests
```bash
poetry run pytest
```

### Code Formatting
```bash
poetry run black .
poetry run ruff check .
```

## Security

This project implements security-first development practices:
- Branch protection on main branch
- Required code reviews
- Comprehensive security testing
- Input validation and sanitization

## Contributing

1. Create a feature branch from `main`
2. Make your changes following our code standards
3. Add tests for new functionality
4. Submit a pull request

## Project Status

ðŸš§ **In Development** - Foundation phase

## License

[License information to be added]

## Contact

[Contact information to be added]
```

### Phase 4: Security Configuration (Estimated: 25 minutes)

#### Step 4.1: Configure Branch Protection Rules
```bash
# This will be done via GitHub web interface or API:
# - Require pull request reviews before merging
# - Require at least 1 approval
# - Dismiss stale reviews when new commits are pushed
# - Require status checks to pass before merging (CI/CD pipeline)
# - Restrict pushes to main branch
# - Enable "Restrict pushes that create files"
# - Enable "Block force pushes"
```

#### Step 4.2: Security Configuration Test
```python
# tests/integration/test_security_config.py
import subprocess
import json
from pathlib import Path

def test_no_secrets_in_code():
    """Test that no secrets are committed to the repository."""
    # This test will run after initial commit
    dangerous_patterns = [
        "api_key",
        "secret_key", 
        "password",
        "token",
        "sk-",  # OpenAI API key prefix
        "xoxb-", # Slack token prefix
    ]
    
    # Check all Python files for dangerous patterns
    python_files = list(Path(".").rglob("*.py"))
    
    for file_path in python_files:
        if ".venv" in str(file_path) or "__pycache__" in str(file_path):
            continue
            
        content = file_path.read_text().lower()
        for pattern in dangerous_patterns:
            assert f'"{pattern}"' not in content and f"'{pattern}'" not in content, \
                f"Potential secret found in {file_path}: {pattern}"

def test_env_file_not_committed():
    """Test that .env file is not committed."""
    assert not Path(".env").exists() or Path(".env").stat().st_size == 0, \
        ".env file should not be committed or should be empty"

def test_gitignore_prevents_secrets():
    """Test that .gitignore prevents common secret files."""
    gitignore_content = Path(".gitignore").read_text()
    secret_patterns = [".env", "*.key", "*.pem", "secrets/"]
    
    for pattern in secret_patterns:
        assert pattern in gitignore_content, f"Missing .gitignore pattern for secrets: {pattern}"

# RUN TEST: poetry run pytest tests/integration/test_security_config.py -v
# EXPECTED: PASS (after proper setup)
```

### Phase 5: Initial Commit and Verification (Estimated: 15 minutes)

#### Step 5.1: TDD Validation Before Commit
```bash
# CRITICAL: Run all tests to verify TDD approach
# Tests should PASS now that implementation is complete

# Run structure tests
poetry run pytest tests/integration/test_repository_structure.py -v

# Run configuration tests 
poetry run pytest tests/unit/test_configuration.py -v

# Run CI/CD tests
poetry run pytest tests/integration/test_cicd_config.py -v

# Run security tests
poetry run pytest tests/integration/test_security_config.py -v

# All tests should PASS before committing
```

#### Step 5.2: Commit Initial Structure
```bash
# Only commit if ALL tests pass
git add .
git commit -m "Initial commit: project structure setup

- Add monorepo structure with apps/chatbot directory
- Configure Poetry for Python monorepo management  
- Add comprehensive .gitignore for Python projects
- Add .env.example with configuration templates
- Add detailed README.md with setup instructions
- Configure development tools (Black, Ruff, MyPy, Pytest)
- Add CI/CD pipeline with GitHub Actions
- Add pre-commit hooks for code quality
- Add TDD test suite for infrastructure validation
- Configure security scanning and validation"

git push origin main
```

#### Step 5.3: Comprehensive Verification Steps

**TDD Verification:**
- [ ] All structure tests pass: `poetry run pytest tests/integration/test_repository_structure.py -v`
- [ ] All configuration tests pass: `poetry run pytest tests/unit/test_configuration.py -v`  
- [ ] All CI/CD tests pass: `poetry run pytest tests/integration/test_cicd_config.py -v`
- [ ] All security tests pass: `poetry run pytest tests/integration/test_security_config.py -v`

**Functional Verification:**
- [ ] Verify repository structure is created correctly
- [ ] Test `poetry install` works without errors
- [ ] Test `poetry run pytest` discovers and runs all tests
- [ ] Test `poetry run black .` formats code without errors
- [ ] Test `poetry run ruff check .` lints code without errors
- [ ] Test `poetry run mypy .` type-checks without errors

**Security Verification:**
- [ ] Verify branch protection rules are active in GitHub UI
- [ ] Test that direct pushes to main are blocked
- [ ] Verify GitHub Actions workflow triggers on push/PR
- [ ] Confirm pre-commit hooks install: `poetry run pre-commit install`
- [ ] Test pre-commit hooks work: `poetry run pre-commit run --all-files`

**CI/CD Verification:**
- [ ] Verify CI pipeline runs successfully on first commit
- [ ] Check that all CI jobs (test, lint, security scan) pass
- [ ] Verify code coverage reporting works
- [ ] Test status checks prevent merge when CI fails

**Final Verification:**
- [ ] Clone repository in fresh directory and verify setup
- [ ] Confirm all files are properly committed
- [ ] Verify no secrets or sensitive data committed

## Success Criteria

âœ… **Repository Setup Complete When:**

**Core Infrastructure:**
- [ ] Monorepo structure is established
- [ ] pyproject.toml is configured for Poetry with all dev dependencies
- [ ] README.md provides clear setup instructions
- [ ] .gitignore covers all Python/development artifacts
- [ ] .env.example documents all required environment variables

**TDD Foundation:**
- [ ] Test structure established with proper __init__.py files
- [ ] All infrastructure tests written and passing
- [ ] TDD methodology validated for future stories
- [ ] pytest configuration working correctly

**CI/CD Pipeline:**
- [ ] GitHub Actions workflow configured and working
- [ ] Pre-commit hooks installed and functional
- [ ] Code quality tools integrated (black, ruff, mypy)
- [ ] Security scanning enabled (bandit, trivy)
- [ ] Coverage reporting configured

**Security Controls:**
- [ ] Branch protection enabled on main branch with PR reviews required
- [ ] Status checks required before merge (CI pipeline must pass)
- [ ] No secrets or sensitive data committed
- [ ] Security tests validate protection measures

**Verification Complete:**
- [ ] Initial commit pushed successfully
- [ ] CI pipeline passes on main branch
- [ ] Fresh clone works for new developers
- [ ] Repository is ready for subsequent development stories

## Time Estimation
- **Total Estimated Time:** 3.5 hours (increased for TDD + CI/CD)
  - Phase 1 (Repository + TDD Setup): 45 minutes
  - Phase 2 (Configuration + Tests): 60 minutes 
  - Phase 2.5 (CI/CD Pipeline): 30 minutes
  - Phase 3 (Documentation): 30 minutes
  - Phase 4 (Security + Tests): 25 minutes
  - Phase 5 (TDD Validation + Commit): 25 minutes
  - Buffer for debugging/iteration: 15 minutes
- **Critical Path:** TDD Test Creation â†’ Implementation â†’ Test Validation â†’ CI/CD â†’ Security â†’ Verification
- **Dependencies:** None (this is the foundational story)
- **TDD Multiplier:** 1.5x base time (worth the investment for quality foundation)

## Risk Mitigation
- **Risk:** Branch protection conflicts with existing setup
  - **Mitigation:** Review current repository settings before implementing
- **Risk:** Poetry configuration conflicts
  - **Mitigation:** Test configuration in a separate branch first
- **Risk:** Environment variable exposure
  - **Mitigation:** Ensure .env is in .gitignore before any commits

## Next Steps After Completion
- Epic 1.2: Basic Chainlit Application Deployment to Cloud Run
- Security Story S-1: API Rate Limiting and Budget Monitoring (parallel track)