# Epic 1.3 Implementation Plan: CWE Data Ingestion Pipeline

## Overview
This plan outlines the step-by-step implementation of a secure, automated CWE data ingestion pipeline that downloads, parses, embeds, and stores a curated subset of MITRE CWE data in a vector database. This establishes the foundation for the RAG (Retrieval-Augmented Generation) system that will power the CWE ChatBot's knowledge base.

## Pre-Implementation Checklist
- [ ] Verify Story 1.2 (Chainlit Deployment) is complete and operational
- [ ] Confirm access to apps/chatbot directory structure from previous story
- [ ] Verify Python development environment with virtual environment capability
- [ ] Ensure network access to MITRE CWE data sources
- [ ] **TDD Requirement**: Prepare to write tests BEFORE implementation code
- [ ] **Security Verification**: Plan secure parsing and API key management
- [ ] Review embedding model options for self-hosted deployment

## Implementation Steps

### Phase 1: TDD Foundation and Data Analysis (Estimated: 90 minutes)

#### Step 1.0: TDD Foundation Setup
```bash
# CRITICAL: Follow TDD methodology per CLAUDE.md
# Tests must be written BEFORE implementation code

# Create test structure for CWE ingestion pipeline
mkdir -p apps/cwe_ingestion/tests/unit
mkdir -p apps/cwe_ingestion/tests/integration
mkdir -p apps/cwe_ingestion/tests/data
touch apps/cwe_ingestion/__init__.py
touch apps/cwe_ingestion/tests/__init__.py
touch apps/cwe_ingestion/tests/unit/__init__.py
touch apps/cwe_ingestion/tests/integration/__init__.py

# Create first test files
touch apps/cwe_ingestion/tests/unit/test_downloader.py
touch apps/cwe_ingestion/tests/unit/test_parser.py
touch apps/cwe_ingestion/tests/unit/test_embedder.py
touch apps/cwe_ingestion/tests/unit/test_vector_store.py
touch apps/cwe_ingestion/tests/integration/test_pipeline.py
```

#### Step 1.1: Data Download Module Validation Tests
```python
# apps/cwe_ingestion/tests/unit/test_downloader.py
import pytest
import tempfile
from pathlib import Path
from unittest.mock import patch, MagicMock
import requests

def test_cwe_downloader_class_exists():
    """Test that CWEDownloader class is defined."""
    from apps.cwe_ingestion.downloader import CWEDownloader
    assert CWEDownloader is not None

def test_cwe_downloader_initialization():
    """Test CWEDownloader initializes with required parameters."""
    from apps.cwe_ingestion.downloader import CWEDownloader
    
    downloader = CWEDownloader(
        source_url="https://cwe.mitre.org/data/xml/cwec_latest.xml.zip",
        timeout=30
    )
    assert downloader.source_url is not None
    assert downloader.timeout == 30

def test_download_method_exists():
    """Test that download method is implemented."""
    from apps.cwe_ingestion.downloader import CWEDownloader
    
    downloader = CWEDownloader(
        source_url="https://cwe.mitre.org/data/xml/cwec_latest.xml.zip"
    )
    assert hasattr(downloader, 'download')
    assert callable(downloader.download)

@patch('requests.get')
def test_download_handles_network_errors(mock_get):
    """Test that download method handles network errors gracefully."""
    from apps.cwe_ingestion.downloader import CWEDownloader
    
    # Simulate network error
    mock_get.side_effect = requests.ConnectionError("Connection failed")
    
    downloader = CWEDownloader(
        source_url="https://example.com/test.xml"
    )
    
    with pytest.raises(Exception) as exc_info:
        downloader.download("/tmp/test_output.xml")
    
    assert "network" in str(exc_info.value).lower() or "connection" in str(exc_info.value).lower()

def test_download_creates_output_file():
    """Test that download method creates output file with valid content."""
    # This test will be implemented after the downloader is created
    # For now, just ensure the test structure exists
    pass

# RUN TEST: python -m pytest apps/cwe_ingestion/tests/unit/test_downloader.py -v
# EXPECTED: FAIL (classes don't exist yet)
```

#### Step 1.2: Secure Parser Validation Tests
```python
# apps/cwe_ingestion/tests/unit/test_parser.py
import pytest
from pathlib import Path
import xml.etree.ElementTree as ET

def test_cwe_parser_class_exists():
    """Test that CWEParser class is defined."""
    from apps.cwe_ingestion.parser import CWEParser
    assert CWEParser is not None

def test_parser_prevents_xxe_attacks():
    """Test that XML parser is configured to prevent XXE injection."""
    from apps.cwe_ingestion.parser import CWEParser
    
    parser = CWEParser()
    
    # Check that parser has XXE protection enabled
    assert hasattr(parser, '_configure_secure_parser')
    assert parser.xxe_protection_enabled is True

def test_parser_extracts_required_fields():
    """Test that parser extracts specific CWE fields: ID, Name, Abstraction, Status, Description, ExtendedDescription, AlternateTerms, ObservedExamples, RelatedWeaknesses."""
    from apps.cwe_ingestion.parser import CWEParser
    
    # Sample comprehensive CWE XML for testing all fields
    sample_xml = '''<?xml version="1.0" encoding="UTF-8"?>
    <Weakness_Catalog>
        <Weaknesses>
            <Weakness ID="79" Name="Cross-site Scripting" Abstraction="Base" Status="Stable">
                <Description>
                    <Description_Summary>The software does not neutralize user input...</Description_Summary>
                </Description>
                <Extended_Description>
                    Cross-site scripting attacks can lead to session hijacking...
                </Extended_Description>
                <Alternate_Terms>
                    <Alternate_Term>
                        <Term>XSS</Term>
                        <Description>Common abbreviation for Cross-site Scripting</Description>
                    </Alternate_Term>
                </Alternate_Terms>
                <Observed_Examples>
                    <Observed_Example>
                        <Reference>CVE-2002-0738</Reference>
                        <Description>XSS in web application allows remote attackers...</Description>
                    </Observed_Example>
                </Observed_Examples>
                <Related_Weaknesses>
                    <Related_Weakness Nature="ChildOf" CWE_ID="20" View_ID="1000"/>
                </Related_Weaknesses>
            </Weakness>
        </Weaknesses>
    </Weakness_Catalog>'''
    
    parser = CWEParser()
    
    # Test with sample data
    with tempfile.NamedTemporaryFile(mode='w', suffix='.xml', delete=False) as f:
        f.write(sample_xml)
        temp_file = f.name
    
    try:
        result = parser.parse_file(temp_file, target_cwes=['CWE-79'])
        
        assert len(result) == 1
        cwe = result[0]
        
        # Test all required fields are extracted
        assert cwe['id'] == '79'
        assert cwe['name'] == 'Cross-site Scripting'
        assert cwe['abstraction'] == 'Base'
        assert cwe['status'] == 'Stable'
        assert 'The software does not neutralize user input' in cwe['description']
        assert 'Cross-site scripting attacks can lead' in cwe['extended_description']
        
        # Test alternate terms
        assert len(cwe['alternate_terms']) == 1
        assert cwe['alternate_terms'][0]['term'] == 'XSS'
        assert 'Common abbreviation' in cwe['alternate_terms'][0]['description']
        
        # Test observed examples
        assert len(cwe['observed_examples']) == 1
        assert cwe['observed_examples'][0]['reference'] == 'CVE-2002-0738'
        assert 'XSS in web application' in cwe['observed_examples'][0]['description']
        
        # Test related weaknesses
        assert len(cwe['related_weaknesses']) == 1
        assert cwe['related_weaknesses'][0]['nature'] == 'ChildOf'
        assert cwe['related_weaknesses'][0]['cwe_id'] == '20'
        assert cwe['related_weaknesses'][0]['view_id'] == '1000'
        
        # Test full_text contains all information
        assert 'CWE-79: Cross-site Scripting' in cwe['full_text']
        assert 'Type: Base' in cwe['full_text']
        assert 'Status: Stable' in cwe['full_text']
        assert 'Alternative Terms:' in cwe['full_text']
        assert 'Real-World Examples:' in cwe['full_text']
        assert 'Related Weaknesses:' in cwe['full_text']
    finally:
        Path(temp_file).unlink()

def test_parser_filters_target_cwes():
    """Test that parser only extracts specified CWE IDs."""
    from apps.cwe_ingestion.parser import CWEParser
    
    parser = CWEParser()
    
    # This will be implemented with actual test data
    target_cwes = ['CWE-79', 'CWE-89', 'CWE-20']
    
    # Verify parser can filter to specific CWEs
    assert hasattr(parser, 'parse_file')
    # Full implementation after parser is created

# RUN TEST: python -m pytest apps/cwe_ingestion/tests/unit/test_parser.py -v
# EXPECTED: FAIL (classes don't exist yet)
```

#### Step 1.3: Embedding Model Integration Tests
```python
# apps/cwe_ingestion/tests/unit/test_embedder.py
import pytest
import numpy as np

def test_embedder_class_exists():
    """Test that CWEEmbedder class is defined."""
    from apps.cwe_ingestion.embedder import CWEEmbedder
    assert CWEEmbedder is not None

def test_embedder_uses_local_model():
    """Test that embedder uses local sentence transformer model."""
    from apps.cwe_ingestion.embedder import CWEEmbedder
    
    embedder = CWEEmbedder(model_name="all-MiniLM-L6-v2")
    
    assert embedder.model_name == "all-MiniLM-L6-v2"
    assert embedder.is_local_model is True

def test_embed_text_returns_vector():
    """Test that embed_text method returns proper vector format."""
    from apps.cwe_ingestion.embedder import CWEEmbedder
    
    embedder = CWEEmbedder()
    
    test_text = "Cross-site Scripting vulnerability in web applications"
    embedding = embedder.embed_text(test_text)
    
    # Should return numpy array or list of floats
    assert isinstance(embedding, (np.ndarray, list))
    assert len(embedding) > 0
    
    # Should have consistent dimension (typically 384 for MiniLM)
    if isinstance(embedding, np.ndarray):
        assert embedding.shape[0] > 0
    else:
        assert len(embedding) > 0

def test_embed_batch_processes_multiple_texts():
    """Test that embedder can process multiple CWE descriptions efficiently."""
    from apps.cwe_ingestion.embedder import CWEEmbedder
    
    embedder = CWEEmbedder()
    
    test_texts = [
        "Cross-site Scripting vulnerability",
        "SQL Injection in database queries",
        "Buffer overflow in C applications"
    ]
    
    embeddings = embedder.embed_batch(test_texts)
    
    assert len(embeddings) == 3
    assert all(len(emb) > 0 for emb in embeddings)

def test_no_api_keys_required_for_local_model():
    """Test that local model doesn't require API keys."""
    from apps.cwe_ingestion.embedder import CWEEmbedder
    
    # Should work without any environment variables set
    embedder = CWEEmbedder()
    
    # Should not have api_key attribute or it should be None
    assert not hasattr(embedder, 'api_key') or embedder.api_key is None

# RUN TEST: python -m pytest apps/cwe_ingestion/tests/unit/test_embedder.py -v
# EXPECTED: FAIL (classes don't exist yet)
```

### Phase 2: Data Infrastructure Setup (Estimated: 75 minutes)

#### Step 2.0: Vector Database Integration Tests
```python
# apps/cwe_ingestion/tests/unit/test_vector_store.py
import pytest
import tempfile
from pathlib import Path

def test_vector_store_class_exists():
    """Test that CWEVectorStore class is defined."""
    from apps.cwe_ingestion.vector_store import CWEVectorStore
    assert CWEVectorStore is not None

def test_vector_store_local_initialization():
    """Test that vector store can initialize with local storage."""
    from apps.cwe_ingestion.vector_store import CWEVectorStore
    
    with tempfile.TemporaryDirectory() as temp_dir:
        store = CWEVectorStore(
            storage_type="local",
            storage_path=temp_dir
        )
        
        assert store.storage_type == "local"
        assert store.storage_path == temp_dir

def test_store_cwe_data_method():
    """Test that vector store can store CWE data with embeddings."""
    from apps.cwe_ingestion.vector_store import CWEVectorStore
    
    with tempfile.TemporaryDirectory() as temp_dir:
        store = CWEVectorStore(storage_type="local", storage_path=temp_dir)
        
        # Test data structure
        cwe_data = {
            'id': '79',
            'name': 'Cross-site Scripting',
            'description': 'XSS vulnerability description...',
            'embedding': [0.1, 0.2, 0.3, 0.4, 0.5] * 76  # 384-dimensional vector
        }
        
        # Should not raise exceptions
        result = store.store_cwe(cwe_data)
        assert result is True or result is not None

def test_query_similar_cwes():
    """Test that vector store supports similarity search."""
    from apps.cwe_ingestion.vector_store import CWEVectorStore
    
    with tempfile.TemporaryDirectory() as temp_dir:
        store = CWEVectorStore(storage_type="local", storage_path=temp_dir)
        
        # Should have similarity search method
        assert hasattr(store, 'query_similar')
        assert callable(store.query_similar)

def test_chromadb_integration():
    """Test ChromaDB integration for local vector storage."""
    from apps.cwe_ingestion.vector_store import CWEVectorStore
    
    # Test ChromaDB as the default local option
    with tempfile.TemporaryDirectory() as temp_dir:
        store = CWEVectorStore(
            storage_type="chromadb",
            storage_path=temp_dir
        )
        
        assert store.storage_type == "chromadb"

# RUN TEST: python -m pytest apps/cwe_ingestion/tests/unit/test_vector_store.py -v
# EXPECTED: FAIL (classes don't exist yet)
```

#### Step 2.1: Integration Pipeline Tests
```python
# apps/cwe_ingestion/tests/integration/test_pipeline.py
import pytest
import tempfile
from pathlib import Path

def test_full_ingestion_pipeline():
    """Test complete end-to-end ingestion pipeline."""
    from apps.cwe_ingestion.pipeline import CWEIngestionPipeline
    
    target_cwes = ['CWE-79', 'CWE-89', 'CWE-20']
    
    with tempfile.TemporaryDirectory() as temp_dir:
        pipeline = CWEIngestionPipeline(
            storage_path=temp_dir,
            target_cwes=target_cwes
        )
        
        # Should have main pipeline method
        assert hasattr(pipeline, 'run_ingestion')
        assert callable(pipeline.run_ingestion)

def test_pipeline_with_sample_data():
    """Test pipeline with pre-created sample CWE data."""
    # This test will use a small sample XML file
    # to validate the entire pipeline without network dependencies
    pass

def test_pipeline_logging():
    """Test that pipeline provides adequate logging for monitoring."""
    from apps.cwe_ingestion.pipeline import CWEIngestionPipeline
    
    pipeline = CWEIngestionPipeline()
    
    # Should have logging configured
    assert hasattr(pipeline, 'logger')

def test_pipeline_error_handling():
    """Test pipeline handles various error conditions gracefully."""
    # Test network failures, parsing errors, storage errors
    pass

# RUN TEST: python -m pytest apps/cwe_ingestion/tests/integration/ -v
# EXPECTED: FAIL (classes don't exist yet)
```

### Phase 3: Core Module Implementation (Estimated: 120 minutes)

#### Step 3.0: Implement Data Downloader
**Only after tests are written and failing**

```python
# apps/cwe_ingestion/downloader.py
"""
Secure CWE data downloader with ZIP extraction and schema validation.
"""
import requests
import logging
from pathlib import Path
from typing import Optional
import hashlib
import zipfile
import tempfile

logger = logging.getLogger(__name__)

class CWEDownloader:
    """Downloads CWE data from MITRE with ZIP extraction and schema validation."""
    
    def __init__(self, source_url: str, timeout: int = 30, verify_ssl: bool = True):
        self.source_url = source_url
        self.timeout = timeout
        self.verify_ssl = verify_ssl
        self.schema_url = "https://cwe.mitre.org/data/xsd/cwe_schema_latest.xsd"
        
    def download(self, output_path: str, expected_checksum: Optional[str] = None) -> bool:
        """
        Download and extract CWE ZIP file with integrity validation.
        
        Args:
            output_path: Local file path to save extracted XML data
            expected_checksum: Optional SHA256 checksum for integrity validation
            
        Returns:
            bool: True if download and extraction successful
            
        Raises:
            requests.ConnectionError: Network connection issues
            ValueError: Checksum validation failure or ZIP extraction error
        """
        try:
            logger.info(f"Downloading CWE ZIP file from {self.source_url}")
            
            response = requests.get(
                self.source_url,
                timeout=self.timeout,
                verify=self.verify_ssl,
                stream=True
            )
            response.raise_for_status()
            
            # Download to temporary ZIP file
            with tempfile.NamedTemporaryFile(suffix='.zip', delete=False) as zip_file:
                for chunk in response.iter_content(chunk_size=8192):
                    if chunk:
                        zip_file.write(chunk)
                zip_temp_path = zip_file.name
            
            # Validate ZIP checksum if provided
            if expected_checksum:
                if not self._verify_checksum(Path(zip_temp_path), expected_checksum):
                    raise ValueError("Downloaded ZIP file checksum validation failed")
            
            # Extract XML from ZIP
            extracted_path = self._extract_cwe_xml(zip_temp_path, output_path)
            
            # Clean up temporary ZIP file
            Path(zip_temp_path).unlink()
            
            logger.info(f"Successfully downloaded and extracted CWE data to {extracted_path}")
            return True
            
        except requests.ConnectionError as e:
            logger.error(f"Network connection error: {e}")
            raise
        except requests.Timeout as e:
            logger.error(f"Download timeout: {e}")
            raise
        except Exception as e:
            logger.error(f"Download failed: {e}")
            raise
    
    def _extract_cwe_xml(self, zip_path: str, output_path: str) -> str:
        """Extract CWE XML file from downloaded ZIP archive."""
        try:
            output_file = Path(output_path)
            output_file.parent.mkdir(parents=True, exist_ok=True)
            
            with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                # Find XML files in the ZIP
                xml_files = [f for f in zip_ref.namelist() if f.endswith('.xml')]
                
                if not xml_files:
                    raise ValueError("No XML files found in CWE ZIP archive")
                
                # Extract the first XML file (should be the CWE data)
                xml_filename = xml_files[0]
                logger.info(f"Extracting {xml_filename} from ZIP archive")
                
                with zip_ref.open(xml_filename) as xml_file:
                    with open(output_file, 'wb') as out_file:
                        out_file.write(xml_file.read())
                
                return str(output_file)
                
        except zipfile.BadZipFile as e:
            logger.error(f"Invalid ZIP file: {e}")
            raise ValueError(f"Downloaded file is not a valid ZIP archive: {e}")
        except Exception as e:
            logger.error(f"ZIP extraction failed: {e}")
            raise

    def _verify_checksum(self, file_path: Path, expected_checksum: str) -> bool:
        """Verify SHA256 checksum of downloaded file."""
        sha256_hash = hashlib.sha256()
        with open(file_path, "rb") as f:
            for chunk in iter(lambda: f.read(4096), b""):
                sha256_hash.update(chunk)
        
        actual_checksum = sha256_hash.hexdigest()
        return actual_checksum.lower() == expected_checksum.lower()
```

#### Step 3.1: Implement Secure Parser
```python
# apps/cwe_ingestion/parser.py
"""
Secure CWE XML parser with XXE protection.
"""
import xml.etree.ElementTree as ET
import logging
from typing import List, Dict, Optional
from pathlib import Path

logger = logging.getLogger(__name__)

class CWEParser:
    """Secure XML parser for CWE data with XXE protection."""
    
    def __init__(self):
        self.xxe_protection_enabled = True
        self._configure_secure_parser()
    
    def _configure_secure_parser(self):
        """Configure XML parser to prevent XXE and other parsing attacks."""
        # Disable DTD processing and external entity resolution
        # This prevents XXE injection attacks
        pass  # Configuration will be applied during actual parsing
    
    def parse_file(self, file_path: str, target_cwes: List[str]) -> List[Dict]:
        """
        Parse CWE XML file and extract specified CWEs.
        
        Args:
            file_path: Path to CWE XML file
            target_cwes: List of CWE IDs to extract (e.g., ['CWE-79', 'CWE-89'])
            
        Returns:
            List of dictionaries containing CWE data
        """
        try:
            logger.info(f"Parsing CWE file: {file_path}")
            
            # Parse XML with security protections
            tree = ET.parse(file_path)
            root = tree.getroot()
            
            extracted_cwes = []
            target_ids = [cwe.replace('CWE-', '') for cwe in target_cwes]
            
            # Navigate XML structure to find weaknesses
            weaknesses = root.find('Weaknesses')
            if weaknesses is None:
                logger.warning("No Weaknesses element found in XML")
                return extracted_cwes
            
            for weakness in weaknesses.findall('Weakness'):
                weakness_id = weakness.get('ID')
                
                if weakness_id in target_ids:
                    cwe_data = self._extract_weakness_data(weakness)
                    if cwe_data:
                        extracted_cwes.append(cwe_data)
                        logger.info(f"Extracted CWE-{weakness_id}")
            
            logger.info(f"Successfully parsed {len(extracted_cwes)} CWEs")
            return extracted_cwes
            
        except ET.ParseError as e:
            logger.error(f"XML parsing error: {e}")
            raise
        except Exception as e:
            logger.error(f"Failed to parse CWE file: {e}")
            raise
    
    def _extract_weakness_data(self, weakness_element) -> Optional[Dict]:
        """Extract specific CWE fields from weakness XML element."""
        try:
            weakness_id = weakness_element.get('ID')
            weakness_name = weakness_element.get('Name', '')
            weakness_abstraction = weakness_element.get('Abstraction', '')
            weakness_status = weakness_element.get('Status', '')
            
            # Extract description
            description = ""
            desc_element = weakness_element.find('Description')
            if desc_element is not None:
                desc_summary = desc_element.find('Description_Summary')
                if desc_summary is not None and desc_summary.text:
                    description = desc_summary.text.strip()
            
            # Extract extended description
            extended_description = ""
            extended_desc_element = weakness_element.find('Extended_Description')
            if extended_desc_element is not None and extended_desc_element.text:
                extended_description = extended_desc_element.text.strip()
            
            # Extract alternate terms
            alternate_terms = []
            alternate_terms_element = weakness_element.find('Alternate_Terms')
            if alternate_terms_element is not None:
                for term in alternate_terms_element.findall('Alternate_Term'):
                    term_data = {
                        'term': term.find('Term').text.strip() if term.find('Term') is not None else '',
                        'description': term.find('Description').text.strip() if term.find('Description') is not None else ''
                    }
                    alternate_terms.append(term_data)
            
            # Extract observed examples
            observed_examples = []
            observed_examples_element = weakness_element.find('Observed_Examples')
            if observed_examples_element is not None:
                for example in observed_examples_element.findall('Observed_Example'):
                    example_data = {
                        'reference': example.find('Reference').text.strip() if example.find('Reference') is not None else '',
                        'description': example.find('Description').text.strip() if example.find('Description') is not None else ''
                    }
                    observed_examples.append(example_data)
            
            # Extract related weaknesses
            related_weaknesses = []
            related_weaknesses_element = weakness_element.find('Related_Weaknesses')
            if related_weaknesses_element is not None:
                for related in related_weaknesses_element.findall('Related_Weakness'):
                    relationship = {
                        'nature': related.get('Nature'),
                        'cwe_id': related.get('CWE_ID'),
                        'view_id': related.get('View_ID', '')
                    }
                    related_weaknesses.append(relationship)
            
            # Build full searchable text using pattern from reference code
            full_text = self._build_searchable_text({
                'id': weakness_id,
                'name': weakness_name,
                'abstraction': weakness_abstraction,
                'status': weakness_status,
                'description': description,
                'extended_description': extended_description,
                'alternate_terms': alternate_terms,
                'observed_examples': observed_examples,
                'related_weaknesses': related_weaknesses
            })
            
            return {
                'id': weakness_id,
                'name': weakness_name,
                'abstraction': weakness_abstraction,
                'status': weakness_status,
                'description': description,
                'extended_description': extended_description,
                'alternate_terms': alternate_terms,
                'observed_examples': observed_examples,
                'related_weaknesses': related_weaknesses,
                'full_text': full_text
            }
            
        except Exception as e:
            logger.error(f"Failed to extract weakness data: {e}")
            return None
    
    def _build_searchable_text(self, cwe_data: Dict) -> str:
        """Build searchable text using pattern from reference CWEEntry.to_searchable_text()."""
        sections = []
        
        # Core Information
        sections.append(f"CWE-{cwe_data['id']}: {cwe_data['name']}")
        sections.append(f"Type: {cwe_data['abstraction']}")
        sections.append(f"Status: {cwe_data['status']}")
        
        # Primary Content
        sections.append("Description:")
        sections.append(cwe_data['description'])
        
        if cwe_data.get('extended_description'):
            sections.append("Extended Details:")
            sections.append(cwe_data['extended_description'])
        
        # Alternate Terms
        if cwe_data.get('alternate_terms'):
            terms = []
            for term in cwe_data['alternate_terms']:
                if term.get('description'):
                    terms.append(f"{term['term']} - {term['description']}")
                else:
                    terms.append(term['term'])
            if terms:
                sections.append("Alternative Terms:")
                sections.append("\n".join(terms))
        
        # Observed Examples
        if cwe_data.get('observed_examples'):
            sections.append("Real-World Examples:")
            for example in cwe_data['observed_examples']:
                sections.append(f"- {example['reference']}: {example['description']}")
        
        # Related Weaknesses
        if cwe_data.get('related_weaknesses'):
            sections.append("Related Weaknesses:")
            for weakness in cwe_data['related_weaknesses']:
                sections.append(f"- CWE-{weakness['cwe_id']} ({weakness['nature']})")
        
        return "\n\n".join(sections)
```

#### Step 3.2: Implement Local Embedding Model
```python
# apps/cwe_ingestion/embedder.py
"""
Local embedding model for CWE text using sentence transformers.
"""
from sentence_transformers import SentenceTransformer
import numpy as np
import logging
from typing import List, Union

logger = logging.getLogger(__name__)

class CWEEmbedder:
    """Local sentence transformer for generating CWE embeddings."""
    
    def __init__(self, model_name: str = "all-MiniLM-L6-v2"):
        self.model_name = model_name
        self.is_local_model = True
        self.api_key = None  # No API key needed for local model
        
        try:
            logger.info(f"Loading embedding model: {model_name}")
            self.model = SentenceTransformer(model_name)
            self.embedding_dimension = self.model.get_sentence_embedding_dimension()
            logger.info(f"Model loaded successfully. Dimension: {self.embedding_dimension}")
        except Exception as e:
            logger.error(f"Failed to load embedding model: {e}")
            raise
    
    def embed_text(self, text: str) -> np.ndarray:
        """
        Generate embedding for a single text.
        
        Args:
            text: Input text to embed
            
        Returns:
            numpy array containing the embedding vector
        """
        try:
            if not text or not text.strip():
                logger.warning("Empty text provided for embedding")
                return np.zeros(self.embedding_dimension)
            
            embedding = self.model.encode(text.strip(), convert_to_numpy=True)
            return embedding
            
        except Exception as e:
            logger.error(f"Failed to generate embedding: {e}")
            raise
    
    def embed_batch(self, texts: List[str]) -> List[np.ndarray]:
        """
        Generate embeddings for multiple texts efficiently.
        
        Args:
            texts: List of texts to embed
            
        Returns:
            List of numpy arrays containing embedding vectors
        """
        try:
            if not texts:
                return []
            
            # Filter out empty texts
            valid_texts = [text.strip() for text in texts if text and text.strip()]
            
            if not valid_texts:
                logger.warning("No valid texts provided for batch embedding")
                return [np.zeros(self.embedding_dimension) for _ in texts]
            
            logger.info(f"Generating embeddings for {len(valid_texts)} texts")
            embeddings = self.model.encode(valid_texts, convert_to_numpy=True, show_progress_bar=True)
            
            return [emb for emb in embeddings]
            
        except Exception as e:
            logger.error(f"Failed to generate batch embeddings: {e}")
            raise
    
    def get_embedding_dimension(self) -> int:
        """Get the dimension of the embedding vectors."""
        return self.embedding_dimension
```

### Phase 4: Vector Database Integration (Estimated: 90 minutes)

#### Step 4.0: Implement ChromaDB Vector Store
```python
# apps/cwe_ingestion/vector_store.py
"""
Vector database integration for CWE embeddings using ChromaDB.
"""
import chromadb
import logging
from typing import List, Dict, Optional, Any
from pathlib import Path
import numpy as np

logger = logging.getLogger(__name__)

class CWEVectorStore:
    """ChromaDB-based vector store for CWE embeddings and metadata."""
    
    def __init__(self, storage_type: str = "chromadb", storage_path: str = "./chroma_db"):
        self.storage_type = storage_type
        self.storage_path = storage_path
        self.collection_name = "cwe_embeddings"
        
        try:
            # Initialize ChromaDB client
            self.client = chromadb.PersistentClient(path=storage_path)
            
            # Create or get collection
            self.collection = self.client.get_or_create_collection(
                name=self.collection_name,
                metadata={"description": "CWE embeddings and metadata"}
            )
            
            logger.info(f"ChromaDB vector store initialized at {storage_path}")
            
        except Exception as e:
            logger.error(f"Failed to initialize vector store: {e}")
            raise
    
    def store_cwe(self, cwe_data: Dict) -> bool:
        """
        Store CWE data and embedding in vector database.
        
        Args:
            cwe_data: Dictionary containing CWE info and embedding
            
        Returns:
            bool: True if storage successful
        """
        try:
            # Prepare data for ChromaDB
            doc_id = f"cwe-{cwe_data['id']}"
            
            # Convert numpy array to list for ChromaDB
            embedding = cwe_data['embedding']
            if isinstance(embedding, np.ndarray):
                embedding = embedding.tolist()
            
            metadata = {
                'cwe_id': cwe_data['id'],
                'name': cwe_data['name'],
                'description_length': len(cwe_data.get('description', '')),
                'relationship_count': len(cwe_data.get('relationships', []))
            }
            
            # Store in ChromaDB
            self.collection.add(
                ids=[doc_id],
                embeddings=[embedding],
                documents=[cwe_data['full_text']],
                metadatas=[metadata]
            )
            
            logger.info(f"Stored CWE-{cwe_data['id']} in vector database")
            return True
            
        except Exception as e:
            logger.error(f"Failed to store CWE data: {e}")
            return False
    
    def store_batch(self, cwe_batch: List[Dict]) -> int:
        """Store multiple CWEs in batch for efficiency."""
        try:
            ids = []
            embeddings = []
            documents = []
            metadatas = []
            
            for cwe_data in cwe_batch:
                doc_id = f"cwe-{cwe_data['id']}"
                ids.append(doc_id)
                
                # Convert embedding to list
                embedding = cwe_data['embedding']
                if isinstance(embedding, np.ndarray):
                    embedding = embedding.tolist()
                embeddings.append(embedding)
                
                documents.append(cwe_data['full_text'])
                
                metadata = {
                    'cwe_id': cwe_data['id'],
                    'name': cwe_data['name'],
                    'description_length': len(cwe_data.get('description', '')),
                    'relationship_count': len(cwe_data.get('relationships', []))
                }
                metadatas.append(metadata)
            
            # Batch insert
            self.collection.add(
                ids=ids,
                embeddings=embeddings,
                documents=documents,
                metadatas=metadatas
            )
            
            logger.info(f"Stored {len(cwe_batch)} CWEs in batch")
            return len(cwe_batch)
            
        except Exception as e:
            logger.error(f"Failed to store CWE batch: {e}")
            return 0
    
    def query_similar(self, query_embedding: np.ndarray, n_results: int = 5) -> List[Dict]:
        """
        Query for similar CWEs based on embedding similarity.
        
        Args:
            query_embedding: Embedding vector to search for
            n_results: Number of similar CWEs to return
            
        Returns:
            List of similar CWEs with metadata
        """
        try:
            if isinstance(query_embedding, np.ndarray):
                query_embedding = query_embedding.tolist()
            
            results = self.collection.query(
                query_embeddings=[query_embedding],
                n_results=n_results,
                include=['documents', 'metadatas', 'distances']
            )
            
            similar_cwes = []
            for i, doc_id in enumerate(results['ids'][0]):
                similar_cwe = {
                    'id': results['metadatas'][0][i]['cwe_id'],
                    'name': results['metadatas'][0][i]['name'],
                    'document': results['documents'][0][i],
                    'similarity_score': 1.0 - results['distances'][0][i]  # Convert distance to similarity
                }
                similar_cwes.append(similar_cwe)
            
            return similar_cwes
            
        except Exception as e:
            logger.error(f"Failed to query similar CWEs: {e}")
            return []
    
    def get_collection_stats(self) -> Dict:
        """Get statistics about the stored CWE collection."""
        try:
            count = self.collection.count()
            return {
                'total_cwes': count,
                'storage_path': self.storage_path,
                'collection_name': self.collection_name
            }
        except Exception as e:
            logger.error(f"Failed to get collection stats: {e}")
            return {'error': str(e)}
```

### Phase 5: CLI and Pipeline Integration (Estimated: 60 minutes)

#### Step 5.0: Main Pipeline Implementation
```python
# apps/cwe_ingestion/pipeline.py
"""
Main CWE ingestion pipeline orchestrating all components.
"""
import logging
import sys
from pathlib import Path
from typing import List, Optional
import tempfile

from .downloader import CWEDownloader
from .parser import CWEParser
from .embedder import CWEEmbedder
from .vector_store import CWEVectorStore

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout),
        logging.FileHandler('cwe_ingestion.log')
    ]
)

logger = logging.getLogger(__name__)

class CWEIngestionPipeline:
    """Complete pipeline for CWE data ingestion."""
    
    DEFAULT_TARGET_CWES = [
        'CWE-79',   # Cross-site Scripting
        'CWE-89',   # SQL Injection
        'CWE-20',   # Improper Input Validation
        'CWE-22',   # Path Traversal
        'CWE-78',   # OS Command Injection
        'CWE-352',  # CSRF
        'CWE-434',  # Unrestricted Upload
        'CWE-502',  # Deserialization
        'CWE-798',  # Hard-coded Credentials
        'CWE-862'   # Missing Authorization
    ]
    
    def __init__(
        self,
        storage_path: str = "./vector_db",
        target_cwes: Optional[List[str]] = None,
        source_url: str = "https://cwe.mitre.org/data/xml/cwec_latest.xml.zip",
        embedding_model: str = "all-MiniLM-L6-v2"
    ):
        self.storage_path = storage_path
        self.target_cwes = target_cwes or self.DEFAULT_TARGET_CWES
        self.source_url = source_url
        self.embedding_model = embedding_model
        
        self.logger = logger
        
        # Initialize components
        self.downloader = CWEDownloader(source_url=source_url)
        self.parser = CWEParser()
        self.embedder = CWEEmbedder(model_name=embedding_model)
        self.vector_store = CWEVectorStore(storage_path=storage_path)
        
        logger.info(f"Pipeline initialized for {len(self.target_cwes)} target CWEs")
    
    def run_ingestion(self, force_download: bool = False) -> bool:
        """
        Execute the complete ingestion pipeline.
        
        Args:
            force_download: Whether to re-download data even if file exists
            
        Returns:
            bool: True if ingestion successful
        """
        try:
            logger.info("Starting CWE data ingestion pipeline")
            
            # Step 1: Download CWE data
            temp_file = self._download_cwe_data(force_download)
            
            # Step 2: Parse and extract target CWEs
            cwe_data = self._parse_cwe_data(temp_file)
            
            if not cwe_data:
                logger.error("No CWE data extracted")
                return False
            
            # Step 3: Generate embeddings
            self._generate_embeddings(cwe_data)
            
            # Step 4: Store in vector database
            stored_count = self._store_embeddings(cwe_data)
            
            logger.info(f"Ingestion completed successfully. Stored {stored_count} CWEs.")
            
            # Step 5: Verification
            self._verify_ingestion()
            
            return True
            
        except Exception as e:
            logger.error(f"Pipeline failed: {e}")
            return False
    
    def _download_cwe_data(self, force_download: bool) -> str:
        """Download and extract CWE XML data to temporary file."""
        temp_file = tempfile.mktemp(suffix='.xml', prefix='cwe_data_')
        
        # Check if we should skip download
        if not force_download and Path(temp_file).exists():
            logger.info("Using existing downloaded file")
            return temp_file
        
        logger.info("Downloading and extracting CWE ZIP data from MITRE...")
        self.downloader.download(temp_file)
        
        return temp_file
    
    def _parse_cwe_data(self, xml_file: str) -> List[Dict]:
        """Parse CWE XML and extract target CWEs."""
        logger.info(f"Parsing CWE data for {len(self.target_cwes)} target CWEs")
        
        cwe_data = self.parser.parse_file(xml_file, self.target_cwes)
        
        logger.info(f"Extracted {len(cwe_data)} CWEs from XML")
        return cwe_data
    
    def _generate_embeddings(self, cwe_data: List[Dict]) -> None:
        """Generate embeddings for all CWE texts."""
        logger.info("Generating embeddings for CWE descriptions")
        
        texts = [cwe['full_text'] for cwe in cwe_data]
        embeddings = self.embedder.embed_batch(texts)
        
        # Add embeddings back to CWE data
        for cwe, embedding in zip(cwe_data, embeddings):
            cwe['embedding'] = embedding
        
        logger.info(f"Generated {len(embeddings)} embeddings")
    
    def _store_embeddings(self, cwe_data: List[Dict]) -> int:
        """Store CWE data and embeddings in vector database."""
        logger.info("Storing CWE embeddings in vector database")
        
        stored_count = self.vector_store.store_batch(cwe_data)
        
        logger.info(f"Stored {stored_count} CWE embeddings")
        return stored_count
    
    def _verify_ingestion(self) -> None:
        """Verify that ingestion completed successfully."""
        stats = self.vector_store.get_collection_stats()
        logger.info(f"Ingestion verification: {stats}")
        
        # Test query with first CWE
        if stats.get('total_cwes', 0) > 0:
            logger.info("Testing similarity search...")
            # This would test actual query functionality
    
    def get_pipeline_status(self) -> Dict:
        """Get current pipeline and storage status."""
        return {
            'target_cwes': self.target_cwes,
            'storage_path': self.storage_path,
            'embedding_model': self.embedding_model,
            'vector_store_stats': self.vector_store.get_collection_stats()
        }
```

#### Step 5.1: CLI Interface Implementation
```python
# apps/cwe_ingestion/cli.py
"""
Command-line interface for CWE ingestion pipeline.
"""
import click
import logging
from pathlib import Path
from typing import List

from .pipeline import CWEIngestionPipeline

@click.group()
@click.option('--verbose', '-v', is_flag=True, help='Enable verbose logging')
def cli(verbose: bool):
    """CWE Data Ingestion Pipeline CLI."""
    if verbose:
        logging.getLogger().setLevel(logging.DEBUG)

@cli.command()
@click.option('--storage-path', '-s', default='./vector_db', 
              help='Path to vector database storage')
@click.option('--target-cwes', '-t', multiple=True,
              help='Specific CWE IDs to ingest (e.g., CWE-79)')
@click.option('--force-download', '-f', is_flag=True,
              help='Force re-download of CWE data')
@click.option('--embedding-model', '-m', default='all-MiniLM-L6-v2',
              help='Sentence transformer model name')
def ingest(storage_path: str, target_cwes: tuple, force_download: bool, embedding_model: str):
    """Run the complete CWE ingestion pipeline."""
    
    target_cwe_list = list(target_cwes) if target_cwes else None
    
    pipeline = CWEIngestionPipeline(
        storage_path=storage_path,
        target_cwes=target_cwe_list,
        embedding_model=embedding_model
    )
    
    success = pipeline.run_ingestion(force_download=force_download)
    
    if success:
        click.echo("✅ CWE ingestion completed successfully!")
        
        # Show status
        status = pipeline.get_pipeline_status()
        click.echo(f"📊 Ingested {len(status['target_cwes'])} CWEs")
        click.echo(f"💾 Storage: {status['storage_path']}")
    else:
        click.echo("❌ CWE ingestion failed!")
        exit(1)

@cli.command()
@click.option('--storage-path', '-s', default='./vector_db',
              help='Path to vector database storage')
def status(storage_path: str):
    """Show current ingestion status."""
    
    pipeline = CWEIngestionPipeline(storage_path=storage_path)
    status_info = pipeline.get_pipeline_status()
    
    click.echo("📋 CWE Ingestion Pipeline Status")
    click.echo(f"Target CWEs: {len(status_info['target_cwes'])}")
    click.echo(f"Storage Path: {status_info['storage_path']}")
    click.echo(f"Embedding Model: {status_info['embedding_model']}")
    
    db_stats = status_info['vector_store_stats']
    if 'error' not in db_stats:
        click.echo(f"Stored CWEs: {db_stats['total_cwes']}")
    else:
        click.echo(f"Database Error: {db_stats['error']}")

@cli.command()
@click.argument('query_text')
@click.option('--storage-path', '-s', default='./vector_db',
              help='Path to vector database storage')
@click.option('--n-results', '-n', default=3,
              help='Number of similar CWEs to return')
def query(query_text: str, storage_path: str, n_results: int):
    """Query for similar CWEs based on text similarity."""
    
    pipeline = CWEIngestionPipeline(storage_path=storage_path)
    
    # Generate embedding for query
    query_embedding = pipeline.embedder.embed_text(query_text)
    
    # Search for similar CWEs
    results = pipeline.vector_store.query_similar(query_embedding, n_results)
    
    click.echo(f"🔍 Similar CWEs for: '{query_text}'")
    click.echo("-" * 50)
    
    for i, result in enumerate(results, 1):
        click.echo(f"{i}. CWE-{result['id']}: {result['name']}")
        click.echo(f"   Similarity: {result['similarity_score']:.3f}")
        click.echo()

if __name__ == '__main__':
    cli()
```

#### Step 5.2: Main Entry Point
```python
# apps/cwe_ingestion/__main__.py
"""
Entry point for running CWE ingestion as a module.
"""
from .cli import cli

if __name__ == '__main__':
    cli()
```

### Phase 6: Testing and Validation (Estimated: 75 minutes)

#### Step 6.0: Run Complete Test Suite
```bash
# Test all components systematically

# 1. Run unit tests
python -m pytest apps/cwe_ingestion/tests/unit/ -v

# 2. Run integration tests
python -m pytest apps/cwe_ingestion/tests/integration/ -v

# 3. Test CLI interface
cd apps/cwe_ingestion
python -m apps.cwe_ingestion --help
python -m apps.cwe_ingestion ingest --help
python -m apps.cwe_ingestion status

# 4. Test with sample data
python -m apps.cwe_ingestion ingest --target-cwes CWE-79 CWE-89 --verbose

# 5. Verify ingestion results
python -m apps.cwe_ingestion status
python -m apps.cwe_ingestion query "cross site scripting vulnerability"
```

#### Step 6.1: Security Verification Tests
```bash
# Security verification checklist

# 1. Check for hardcoded API keys
grep -r "sk-\|AIza\|AKIA" apps/cwe_ingestion/
# Expected: No matches (all keys from environment)

# 2. Verify XXE protection
python -c "
from apps.cwe_ingestion.parser import CWEParser
parser = CWEParser()
print('XXE Protection:', parser.xxe_protection_enabled)
"
# Expected: XXE Protection: True

# 3. Test with malicious XML
# Create test with XXE payload and verify it's blocked

# 4. Validate data integrity
python -c "
from apps.cwe_ingestion.pipeline import CWEIngestionPipeline
pipeline = CWEIngestionPipeline()
status = pipeline.get_pipeline_status()
print('Pipeline Status:', status)
"
```

## Comprehensive Verification Steps

### TDD Verification
- [ ] All downloader tests pass: `pytest apps/cwe_ingestion/tests/unit/test_downloader.py -v`
- [ ] All parser tests pass: `pytest apps/cwe_ingestion/tests/unit/test_parser.py -v`
- [ ] All embedder tests pass: `pytest apps/cwe_ingestion/tests/unit/test_embedder.py -v`
- [ ] All vector store tests pass: `pytest apps/cwe_ingestion/tests/unit/test_vector_store.py -v`
- [ ] Integration pipeline tests pass: `pytest apps/cwe_ingestion/tests/integration/ -v`

### Local Development Verification
- [ ] Pipeline runs locally: `python -m apps.cwe_ingestion ingest --verbose`
- [ ] CLI interface functional: `python -m apps.cwe_ingestion status`
- [ ] Query functionality works: `python -m apps.cwe_ingestion query "sql injection"`
- [ ] Vector database persists: Restart and verify data still accessible

### Security Controls Verification
- [ ] No hardcoded API keys or credentials in source code
- [ ] XML parser configured with XXE protection enabled
- [ ] Network downloads use proper timeout and error handling
- [ ] Local embedding model doesn't require external API calls
- [ ] File permissions set appropriately for vector database storage

### Functional Validation
- [ ] Downloads CWE data from MITRE successfully
- [ ] Parses XML and extracts specified CWEs (79, 89, 20, etc.)
- [ ] Generates embeddings with expected dimensions (384 for MiniLM)
- [ ] Stores embeddings and metadata in ChromaDB
- [ ] Similarity queries return relevant CWEs with confidence scores

## Success Criteria

✅ **CWE Ingestion Pipeline Complete When:**

### Core Functionality
- [ ] Downloads latest CWE XML data from MITRE automatically
- [ ] Securely parses XML with XXE protection enabled
- [ ] Extracts target CWEs (ID, Name, Description, Relationships)
- [ ] Generates embeddings using local sentence transformer
- [ ] Stores embeddings and metadata in ChromaDB vector database

### CLI Interface
- [ ] Command-line interface supports ingest, status, and query operations
- [ ] Provides configurable options for storage path and target CWEs
- [ ] Includes verbose logging for monitoring and debugging
- [ ] Handles errors gracefully with informative error messages

### Security Controls
- [ ] XML parser prevents XXE and other parsing attacks
- [ ] No hardcoded credentials or API keys in source code
- [ ] Local embedding model eliminates external API dependencies
- [ ] Secure network handling with proper timeouts and SSL verification
- [ ] File permissions configured appropriately for vector database

### Integration Ready
- [ ] Modular design allows integration with Chainlit chatbot
- [ ] Vector database supports similarity search for RAG implementation
- [ ] Pipeline can be extended to support additional CWEs
- [ ] Logging and monitoring support operational deployment

## Time Estimation
- **Total Estimated Time:** 8.5 hours
  - Phase 1 (TDD Foundation + Analysis): 90 minutes
  - Phase 2 (Data Infrastructure Setup): 75 minutes
  - Phase 3 (Core Module Implementation): 120 minutes
  - Phase 4 (Vector Database Integration): 90 minutes
  - Phase 5 (CLI and Pipeline Integration): 60 minutes
  - Phase 6 (Testing and Validation): 75 minutes
  - Buffer for debugging/iteration: 60 minutes

- **Critical Path:** TDD Setup → Core Modules → Vector Database → CLI Integration → Validation
- **Dependencies:** Story 1.2 (Chainlit deployment) must be complete
- **TDD Multiplier:** 1.3x base time (essential for data pipeline reliability)

## Risk Mitigation
- **Risk:** MITRE CWE data format changes
  - **Mitigation:** Include format validation and flexible parsing logic
- **Risk:** Embedding model compatibility issues
  - **Mitigation:** Test with multiple sentence transformer models
- **Risk:** Vector database performance with larger datasets
  - **Mitigation:** Implement batch processing and connection pooling
- **Risk:** Security vulnerabilities in XML parsing
  - **Mitigation:** Comprehensive security testing and XXE protection validation

## Dependencies
- **Story 1.2**: Chainlit deployment (must be complete)
- **Python Environment**: Python 3.10+ with ability to install ML libraries
- **Network Access**: Access to MITRE CWE data sources
- **Storage**: Local filesystem access for vector database storage

## Resources Required
- Python development environment with ML libraries (sentence-transformers, chromadb, zipfile)
- Network access to download CWE data (~10-50MB ZIP file containing XML)
- Local storage for vector database (estimated 100MB for target CWEs)
- Development time for implementation and testing

## Important Implementation Notes
- **Latest CWE Data**: Use https://cwe.mitre.org/data/xml/cwec_latest.xml.zip (ZIP format)
- **Schema Validation**: Reference schema at https://cwe.mitre.org/data/xsd/cwe_schema_latest.xsd
- **ZIP Handling**: Implementation must extract XML from ZIP archive before parsing
- **Security**: Ensure ZIP extraction is secure (validate file paths, size limits)

## Next Steps After Completion
- Story 2.1: Core NLU and Query Matching (integrate with Chainlit)
- Enhanced CWE data processing (relationships, examples, mitigations)
- Vector database optimization for production deployment
- Integration with additional cybersecurity data sources