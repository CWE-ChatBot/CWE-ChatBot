# Epic 1.2 Implementation Plan: Basic Chainlit Application Deployment to Cloud Run

## Overview
This plan outlines the step-by-step implementation of a minimal Chainlit "Hello World" application with secure deployment to Google Cloud Run. This establishes the core deployment pipeline and validates our cloud infrastructure setup with security-first principles.

## Pre-Implementation Checklist
- [ ] Verify Epic 1.1 (Project Repository Setup) is complete and tests pass
- [ ] Confirm access to Google Cloud Platform project with necessary permissions
- [ ] Verify GCP CLI (`gcloud`) is installed and authenticated locally
- [ ] Ensure Docker is installed and running for local testing
- [ ] **TDD Requirement**: Prepare to write tests BEFORE implementation code
- [ ] **Security Verification**: Plan manual verification steps for each security control
- [ ] Confirm GitHub repository has necessary secrets configured for GCP authentication

## Implementation Steps

### Phase 1: TDD Foundation and GCP Infrastructure Setup (Estimated: 60 minutes)

#### Step 1.0: TDD Foundation Setup
```bash
# CRITICAL: Follow TDD methodology per CLAUDE.md
# Tests must be written BEFORE implementation code

# Create test structure for Chainlit app
mkdir -p apps/chatbot/tests/unit
mkdir -p apps/chatbot/tests/integration
mkdir -p tests/deployment
touch apps/chatbot/tests/__init__.py
touch apps/chatbot/tests/unit/__init__.py
touch apps/chatbot/tests/integration/__init__.py
touch tests/deployment/__init__.py

# Create first test files
touch tests/deployment/test_chainlit_app.py
touch tests/deployment/test_docker_config.py
touch tests/deployment/test_gcp_config.py
```

#### Step 1.1: Chainlit Application Validation Tests
```python
# tests/deployment/test_chainlit_app.py
import pytest
import subprocess
from pathlib import Path
import os

def test_chainlit_main_file_exists():
    """Test that main.py exists in apps/chatbot directory."""
    main_file = Path("apps/chatbot/main.py")
    assert main_file.exists(), "main.py must exist in apps/chatbot directory"

def test_chainlit_imports_valid():
    """Test that main.py has valid Chainlit imports."""
    main_file = Path("apps/chatbot/main.py")
    content = main_file.read_text()
    
    assert "import chainlit" in content or "from chainlit" in content, \
        "main.py must import Chainlit"

def test_chainlit_app_structure():
    """Test that main.py defines required Chainlit components."""
    main_file = Path("apps/chatbot/main.py")
    content = main_file.read_text()
    
    # Must have at least one message handler
    assert "@cl.on_message" in content or "@chainlit.on_message" in content, \
        "main.py must define a message handler"

def test_requirements_txt_exists():
    """Test that requirements.txt exists with Chainlit dependency."""
    req_file = Path("apps/chatbot/requirements.txt")
    assert req_file.exists(), "requirements.txt must exist in apps/chatbot directory"
    
    content = req_file.read_text()
    assert "chainlit" in content.lower(), "requirements.txt must include chainlit"

def test_chainlit_version_specified():
    """Test that Chainlit version follows tech stack specification."""
    req_file = Path("apps/chatbot/requirements.txt")
    content = req_file.read_text()
    
    # Should specify version 0.7.x as per tech-stack.md
    assert "chainlit>=0.7" in content or "chainlit==0.7" in content or \
           "chainlit~=0.7" in content, \
           "Chainlit version must be 0.7.x as per tech stack"

# RUN TEST: poetry run pytest tests/deployment/test_chainlit_app.py -v
# EXPECTED: FAIL (files don't exist yet)
```

#### Step 1.2: Docker Configuration Validation Tests
```python
# tests/deployment/test_docker_config.py
import pytest
from pathlib import Path

def test_dockerfile_exists():
    """Test that Dockerfile exists in apps/chatbot directory."""
    dockerfile = Path("apps/chatbot/Dockerfile")
    assert dockerfile.exists(), "Dockerfile must exist in apps/chatbot directory"

def test_dockerfile_uses_secure_base_image():
    """Test that Dockerfile uses python:3.11-slim as per security requirements."""
    dockerfile = Path("apps/chatbot/Dockerfile")
    content = dockerfile.read_text()
    
    assert "FROM python:3.11-slim" in content, \
        "Dockerfile must use python:3.11-slim base image for security"

def test_dockerfile_has_proper_structure():
    """Test that Dockerfile follows security best practices."""
    dockerfile = Path("apps/chatbot/Dockerfile")
    content = dockerfile.read_text()
    
    # Must create non-root user
    assert "adduser" in content or "useradd" in content, \
        "Dockerfile must create non-root user for security"
    
    # Must not run as root
    assert "USER " in content and not "USER root" in content, \
        "Dockerfile must switch to non-root user"
    
    # Must expose port 8000 (Chainlit default)
    assert "EXPOSE 8000" in content, \
        "Dockerfile must expose port 8000"

def test_dockerignore_exists():
    """Test that .dockerignore exists to optimize build."""
    dockerignore = Path("apps/chatbot/.dockerignore")
    assert dockerignore.exists(), ".dockerignore must exist in apps/chatbot directory"

def test_dockerignore_excludes_unnecessary_files():
    """Test that .dockerignore excludes development files."""
    dockerignore = Path("apps/chatbot/.dockerignore")
    content = dockerignore.read_text()
    
    required_excludes = [
        "__pycache__",
        "*.pyc", 
        ".env",
        "tests/",
        ".git"
    ]
    
    for exclude in required_excludes:
        assert exclude in content, f".dockerignore must exclude {exclude}"

# RUN TEST: poetry run pytest tests/deployment/test_docker_config.py -v
# EXPECTED: FAIL (files don't exist yet)
```

#### Step 1.3: GCP Infrastructure Validation Tests
```python
# tests/deployment/test_gcp_config.py
import pytest
import subprocess
import json
from pathlib import Path

def test_gcp_service_account_exists():
    """Test that dedicated service account exists for Cloud Run."""
    # This test will be implemented after GCP setup
    # For now, just check that we can authenticate with gcloud
    result = subprocess.run(
        ["gcloud", "auth", "list", "--format=json"], 
        capture_output=True, text=True
    )
    assert result.returncode == 0, "Must be authenticated with gcloud"

def test_artifact_registry_repository_exists():
    """Test that Artifact Registry repository exists for Docker images."""
    # Placeholder - will be implemented after GCP setup
    pass

def test_github_workflow_exists():
    """Test that GitHub Actions workflow exists for CI/CD."""
    workflow_file = Path(".github/workflows/deploy-chainlit.yml")
    assert workflow_file.exists(), "GitHub Actions workflow must exist"

def test_github_workflow_has_security_config():
    """Test that GitHub Actions workflow uses secure authentication."""
    workflow_file = Path(".github/workflows/deploy-chainlit.yml")
    content = workflow_file.read_text()
    
    # Must use Workload Identity Federation, not service account keys
    assert "workload_identity_provider" in content, \
        "Workflow must use Workload Identity Federation"
    
    assert "service_account_key" not in content.lower(), \
        "Workflow must NOT use service account keys (security risk)"

# RUN TEST: poetry run pytest tests/deployment/test_gcp_config.py -v
# EXPECTED: FAIL (files don't exist yet)
```

### Phase 2: Minimal Chainlit Application Implementation (Estimated: 45 minutes)

#### Step 2.0: Create Basic Chainlit Application
**Only after tests are written and failing**

```python
# apps/chatbot/main.py
"""
CWE ChatBot - Minimal Chainlit Application
Basic "Hello World" implementation for deployment validation.
"""

import chainlit as cl
import logging
from typing import Optional

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@cl.on_chat_start
async def start():
    """Initialize the chat session with a welcome message."""
    logger.info("New chat session started")
    
    await cl.Message(
        content="Hello, welcome to CWE ChatBot! 👋\n\n"
                "This is a minimal implementation for deployment validation. "
                "How can I help you today?"
    ).send()

@cl.on_message
async def main(message: cl.Message):
    """
    Handle user messages with basic echo functionality.
    
    Args:
        message: The user's message object
    """
    user_message = message.content
    logger.info(f"Received message: {user_message[:50]}...")
    
    # Basic response logic
    if user_message.lower() in ["hello", "hi", "hey"]:
        response = "Hello! I'm the CWE ChatBot. I'm currently in development mode."
    elif user_message.lower() in ["help", "what can you do"]:
        response = ("I'm a minimal implementation for testing deployment. "
                   "Full CWE analysis capabilities will be available soon!")
    else:
        response = f"Thanks for your message: \"{user_message}\". "
                  "I'm currently in development mode and will have full "
                  "CWE analysis capabilities once development is complete."
    
    # Send response
    await cl.Message(content=response).send()
    logger.info("Response sent successfully")

@cl.on_stop
async def stop():
    """Clean up when chat session ends."""
    logger.info("Chat session ended")

if __name__ == "__main__":
    # This allows running with: python main.py (for development)
    import os
    port = int(os.getenv("PORT", 8000))
    cl.run(host="0.0.0.0", port=port, debug=False)
```

#### Step 2.1: Create Requirements File
```txt
# apps/chatbot/requirements.txt
chainlit>=0.7.0,<0.8.0
python-dotenv>=1.0.0
gunicorn>=21.0.0
```

#### Step 2.2: Create Configuration File
```python
# apps/chatbot/config.py
"""
Configuration management for CWE ChatBot.
Follows security requirements from docs/architecture/security.md.
"""

import os
from pathlib import Path
from typing import Optional

class Config:
    """Application configuration with security-first principles."""
    
    # Server configuration
    HOST = os.getenv("CHAINLIT_HOST", "0.0.0.0")
    PORT = int(os.getenv("CHAINLIT_PORT", "8000"))
    
    # Environment
    ENVIRONMENT = os.getenv("ENVIRONMENT", "development")
    
    # Logging
    LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO")
    
    # Security headers (will be implemented in future stories)
    SECURITY_HEADERS_ENABLED = os.getenv("SECURITY_HEADERS_ENABLED", "true").lower() == "true"
    
    @classmethod
    def validate(cls) -> bool:
        """Validate configuration is properly set."""
        # Basic validation - will be expanded
        return cls.PORT > 0 and cls.HOST is not None

# Initialize config
config = Config()
```

#### Step 2.3: Run First Test Validation
```bash
# CRITICAL: Verify tests now pass
poetry run pytest tests/deployment/test_chainlit_app.py -v

# Expected: PASS (files now exist and are valid)
```

### Phase 3: Docker Containerization (Estimated: 45 minutes)

#### Step 3.0: Create Dockerfile
**Only after Docker tests are written and failing**

```dockerfile
# apps/chatbot/Dockerfile
# Multi-stage build for security and minimal image size
FROM python:3.11-slim as builder

# Set build arguments
ARG POETRY_VERSION=1.6.1

# Install system dependencies for building
RUN apt-get update && apt-get install -y \
    build-essential \
    curl \
    && rm -rf /var/lib/apt/lists/*

# Install Poetry
RUN pip install poetry==$POETRY_VERSION

# Set poetry configuration
RUN poetry config venv.create false

# Copy dependency files
WORKDIR /app
COPY requirements.txt .

# Install Python dependencies
RUN pip install --no-cache-dir -r requirements.txt

# Production stage
FROM python:3.11-slim as production

# Install runtime dependencies
RUN apt-get update && apt-get install -y \
    && rm -rf /var/lib/apt/lists/*

# Create non-root user for security
RUN adduser --disabled-password --gecos '' --uid 1000 chainlit_user

# Set working directory
WORKDIR /app

# Copy Python packages from builder
COPY --from=builder /usr/local/lib/python3.11/site-packages /usr/local/lib/python3.11/site-packages
COPY --from=builder /usr/local/bin /usr/local/bin

# Copy application code
COPY . .

# Change ownership to non-root user
RUN chown -R chainlit_user:chainlit_user /app

# Switch to non-root user
USER chainlit_user

# Expose port
EXPOSE 8000

# Health check
HEALTHCHECK --interval=30s --timeout=30s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:8000/health || exit 1

# Run application
CMD ["chainlit", "run", "main.py", "--host", "0.0.0.0", "--port", "8000"]
```

#### Step 3.1: Create .dockerignore
```gitignore
# apps/chatbot/.dockerignore

# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
*.egg-info/
.installed.cfg
*.egg

# Testing
.pytest_cache/
htmlcov/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
.hypothesis/

# Environment
.env
.env.local
.env.*.local
venv/
env/
ENV/

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# Git
.git/
.gitignore

# Documentation
README.md
docs/

# Tests
tests/

# Development
*.log
.DS_Store
tmp/
temp/
```

#### Step 3.2: Create Docker Build and Test Script
```bash
# scripts/build-and-test-docker.sh
#!/bin/bash
set -e

echo "Building Docker image for Chainlit app..."

# Build the image
docker build -t cwe-chatbot-local:latest apps/chatbot/

echo "Testing Docker image..."

# Run basic tests
docker run --rm cwe-chatbot-local:latest python -c "import chainlit; print('Chainlit import successful')"

# Test that non-root user is used
USER_CHECK=$(docker run --rm cwe-chatbot-local:latest whoami)
if [ "$USER_CHECK" != "chainlit_user" ]; then
    echo "ERROR: Container is not running as non-root user"
    exit 1
fi

echo "Docker image built and tested successfully!"
```

#### Step 3.3: Run Docker Configuration Tests
```bash
# CRITICAL: Verify Docker tests now pass
poetry run pytest tests/deployment/test_docker_config.py -v

# Test local Docker build
chmod +x scripts/build-and-test-docker.sh
./scripts/build-and-test-docker.sh

# Expected: PASS (Docker files now exist and are valid)
```

### Phase 4: GCP Infrastructure Setup (Estimated: 75 minutes)

#### Step 4.0: GCP Service Account Creation
```bash
# CRITICAL: Follow least privilege security requirements

# Set project variables
export PROJECT_ID="your-gcp-project-id"  # Replace with actual project ID
export SERVICE_ACCOUNT_NAME="cwe-chatbot-runner"
export SERVICE_ACCOUNT_EMAIL="${SERVICE_ACCOUNT_NAME}@${PROJECT_ID}.iam.gserviceaccount.com"

# Create dedicated service account
gcloud iam service-accounts create $SERVICE_ACCOUNT_NAME \
    --display-name "CWE ChatBot Cloud Run Service Account" \
    --description "Minimal permissions for running CWE ChatBot on Cloud Run"

# Grant minimal required permissions
gcloud projects add-iam-policy-binding $PROJECT_ID \
    --member="serviceAccount:${SERVICE_ACCOUNT_EMAIL}" \
    --role="roles/run.invoker"

# Note: Cloud Run service will automatically have access to invoke itself
# No additional broad permissions are granted for security
```

#### Step 4.1: Artifact Registry Setup
```bash
# Create Artifact Registry repository for Docker images
export REPOSITORY_NAME="cwe-chatbot-images"
export REGION="us-central1"  # Adjust as needed

gcloud artifacts repositories create $REPOSITORY_NAME \
    --repository-format=docker \
    --location=$REGION \
    --description="Docker images for CWE ChatBot application"

# Configure Docker authentication
gcloud auth configure-docker ${REGION}-docker.pkg.dev
```

#### Step 4.2: Workload Identity Federation Setup
```bash
# Create Workload Identity Pool for GitHub Actions
export POOL_NAME="github-actions-pool"
export PROVIDER_NAME="github-provider"
export REPO_NAME="CWE-ChatBot/CWE-ChatBot"  # Adjust to your repo

gcloud iam workload-identity-pools create $POOL_NAME \
    --location="global" \
    --display-name="GitHub Actions Pool"

# Create provider
gcloud iam workload-identity-pools providers create-oidc $PROVIDER_NAME \
    --workload-identity-pool=$POOL_NAME \
    --location="global" \
    --issuer-uri="https://token.actions.githubusercontent.com" \
    --attribute-mapping="google.subject=assertion.sub,attribute.actor=assertion.actor,attribute.repository=assertion.repository" \
    --attribute-condition="assertion.repository=='${REPO_NAME}'"

# Get provider name for GitHub secrets
PROVIDER_ID="projects/${PROJECT_ID}/locations/global/workloadIdentityPools/${POOL_NAME}/providers/${PROVIDER_NAME}"
echo "Workload Identity Provider ID: $PROVIDER_ID"

# Bind service account to GitHub repository
gcloud iam service-accounts add-iam-policy-binding $SERVICE_ACCOUNT_EMAIL \
    --role="roles/iam.workloadIdentityUser" \
    --member="principalSet://iam.googleapis.com/projects/${PROJECT_ID}/locations/global/workloadIdentityPools/${POOL_NAME}/attribute.repository/${REPO_NAME}"

echo "Set these GitHub repository secrets:"
echo "GCP_PROJECT_ID: $PROJECT_ID"
echo "GCP_SA_EMAIL: $SERVICE_ACCOUNT_EMAIL"
echo "GCP_WORKLOAD_IDENTITY_PROVIDER: $PROVIDER_ID"
```

#### Step 4.3: Initial Cloud Run Service Creation
```bash
# Create Cloud Run service with security-first configuration
export SERVICE_NAME="cwe-chatbot"
export IMAGE_URI="${REGION}-docker.pkg.dev/${PROJECT_ID}/${REPOSITORY_NAME}/cwe-chatbot:latest"

# Note: This creates the service structure - image will be deployed via CI/CD
gcloud run services replace - <<EOF
apiVersion: serving.knative.dev/v1
kind: Service
metadata:
  name: $SERVICE_NAME
  namespace: $PROJECT_ID
  annotations:
    run.googleapis.com/ingress: internal-and-cloud-load-balancing
spec:
  template:
    metadata:
      annotations:
        run.googleapis.com/execution-environment: gen2
        run.googleapis.com/cpu-throttling: "false"
    spec:
      serviceAccountName: $SERVICE_ACCOUNT_EMAIL
      containerConcurrency: 100
      timeoutSeconds: 300
      containers:
      - image: $IMAGE_URI
        ports:
        - containerPort: 8000
        env:
        - name: ENVIRONMENT
          value: "production"
        - name: LOG_LEVEL
          value: "INFO"
        resources:
          limits:
            cpu: "1000m"
            memory: "512Mi"
        startupProbe:
          httpGet:
            path: /
            port: 8000
          initialDelaySeconds: 10
          periodSeconds: 10
          failureThreshold: 3
        livenessProbe:
          httpGet:
            path: /
            port: 8000
          initialDelaySeconds: 30
          periodSeconds: 60
EOF
```

### Phase 5: CI/CD Pipeline Implementation (Estimated: 60 minutes)

#### Step 5.0: GitHub Actions Workflow
**Only after GitHub workflow tests are written**

```yaml
# .github/workflows/deploy-chainlit.yml
name: Deploy Chainlit App to Cloud Run

on:
  push:
    branches: [main]
    paths:
      - 'apps/chatbot/**'
      - '.github/workflows/deploy-chainlit.yml'
  pull_request:
    branches: [main]
    paths:
      - 'apps/chatbot/**'

env:
  GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  GCP_REGION: us-central1
  SERVICE_NAME: cwe-chatbot
  REPOSITORY_NAME: cwe-chatbot-images

jobs:
  security-scan:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: 'apps/chatbot'
        format: 'sarif'
        output: 'trivy-results.sarif'

    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'

  build-and-test:
    runs-on: ubuntu-latest
    needs: security-scan
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Python 3.11
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install Poetry
      uses: snok/install-poetry@v1
      with:
        version: latest
        virtualenvs-create: true
        virtualenvs-in-project: true

    - name: Cache Poetry dependencies
      uses: actions/cache@v3
      with:
        path: .venv
        key: venv-${{ runner.os }}-3.11-${{ hashFiles('**/poetry.lock') }}

    - name: Install dependencies
      run: poetry install --no-interaction --no-ansi

    - name: Run deployment tests
      run: poetry run pytest tests/deployment/ -v

    - name: Run Chainlit app tests
      run: poetry run pytest apps/chatbot/tests/ -v

    - name: Build Docker image
      run: docker build -t test-image apps/chatbot/

    - name: Test Docker image
      run: |
        # Test that image runs without errors
        docker run --rm -d --name test-container -p 8000:8000 test-image &
        sleep 10
        curl -f http://localhost:8000/ || exit 1
        docker stop test-container

  deploy:
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    needs: [security-scan, build-and-test]
    permissions:
      id-token: write
      contents: read

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Authenticate to Google Cloud
      id: auth
      uses: google-github-actions/auth@v1
      with:
        workload_identity_provider: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
        service_account: ${{ secrets.GCP_SA_EMAIL }}

    - name: Set up Cloud SDK
      uses: google-github-actions/setup-gcloud@v1

    - name: Configure Docker authentication
      run: gcloud auth configure-docker ${{ env.GCP_REGION }}-docker.pkg.dev

    - name: Build and tag Docker image
      run: |
        IMAGE_URI="${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.REPOSITORY_NAME }}/cwe-chatbot:${{ github.sha }}"
        LATEST_URI="${{ env.GCP_REGION }}-docker.pkg.dev/${{ env.GCP_PROJECT_ID }}/${{ env.REPOSITORY_NAME }}/cwe-chatbot:latest"
        
        docker build -t $IMAGE_URI -t $LATEST_URI apps/chatbot/
        
        echo "IMAGE_URI=$IMAGE_URI" >> $GITHUB_ENV
        echo "LATEST_URI=$LATEST_URI" >> $GITHUB_ENV

    - name: Push Docker image
      run: |
        docker push ${{ env.IMAGE_URI }}
        docker push ${{ env.LATEST_URI }}

    - name: Deploy to Cloud Run
      run: |
        gcloud run deploy ${{ env.SERVICE_NAME }} \
          --image ${{ env.IMAGE_URI }} \
          --region ${{ env.GCP_REGION }} \
          --service-account ${{ secrets.GCP_SA_EMAIL }} \
          --ingress internal-and-cloud-load-balancing \
          --cpu 1 \
          --memory 512Mi \
          --concurrency 100 \
          --timeout 300 \
          --set-env-vars ENVIRONMENT=production,LOG_LEVEL=INFO \
          --allow-unauthenticated

    - name: Get service URL
      id: url
      run: |
        SERVICE_URL=$(gcloud run services describe ${{ env.SERVICE_NAME }} \
          --region ${{ env.GCP_REGION }} \
          --format 'value(status.url)')
        echo "SERVICE_URL=$SERVICE_URL" >> $GITHUB_ENV
        echo "service_url=$SERVICE_URL" >> $GITHUB_OUTPUT

    - name: Test deployed service
      run: |
        # Wait for deployment to be ready
        sleep 30
        
        # Test basic connectivity
        curl -f ${{ env.SERVICE_URL }}/ || exit 1
        echo "✅ Service is responding at ${{ env.SERVICE_URL }}"

    outputs:
      service-url: ${{ steps.url.outputs.service_url }}

  post-deploy-verification:
    runs-on: ubuntu-latest
    needs: deploy
    if: github.ref == 'refs/heads/main'

    steps:
    - name: Verify deployment
      run: |
        SERVICE_URL="${{ needs.deploy.outputs.service-url }}"
        
        # Test service responds with expected content
        RESPONSE=$(curl -s "$SERVICE_URL/")
        if echo "$RESPONSE" | grep -q "Hello, welcome to CWE ChatBot"; then
          echo "✅ Service responding with correct content"
        else
          echo "❌ Service not responding with expected content"
          exit 1
        fi

    - name: Check Cloud Run logs
      env:
        GCP_PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
      run: |
        # Authenticate using workload identity
        echo '${{ secrets.GCP_SA_EMAIL }}' | gcloud auth activate-service-account --key-file=-
        
        # Check for startup logs
        gcloud logs read "resource.type=cloud_run_revision resource.labels.service_name=${{ env.SERVICE_NAME }}" \
          --limit=10 \
          --format="table(timestamp,severity,textPayload)" \
          --project=${{ env.GCP_PROJECT_ID }}
```

#### Step 5.1: Update GitHub Repository Secrets
```bash
# Instructions for setting up GitHub secrets (to be done manually)

echo "Configure the following secrets in your GitHub repository:"
echo "Settings > Secrets and variables > Actions > New repository secret"
echo ""
echo "Required secrets:"
echo "GCP_PROJECT_ID: $PROJECT_ID"
echo "GCP_SA_EMAIL: $SERVICE_ACCOUNT_EMAIL"  
echo "GCP_WORKLOAD_IDENTITY_PROVIDER: $PROVIDER_ID"
echo ""
echo "These enable secure, keyless authentication to GCP from GitHub Actions"
```

#### Step 5.2: Run CI/CD Configuration Tests
```bash
# CRITICAL: Verify GitHub workflow tests now pass
poetry run pytest tests/deployment/test_gcp_config.py -v

# Expected: PASS (workflow file now exists and is valid)
```

### Phase 6: Comprehensive Testing and Validation (Estimated: 45 minutes)

#### Step 6.0: Local End-to-End Testing
```bash
# Test complete local workflow

# 1. Install dependencies and run app tests
poetry install
poetry run pytest apps/chatbot/tests/ -v
poetry run pytest tests/deployment/ -v

# 2. Test local Chainlit app
cd apps/chatbot
poetry run python main.py &
sleep 5

# Test basic functionality
curl -f http://localhost:8000/ && echo "✅ Local app responds"

# Kill local app
pkill -f "python main.py"
cd ../..

# 3. Test Docker build and run
./scripts/build-and-test-docker.sh

# 4. Test Docker container locally
docker run -d --name test-chainlit -p 8000:8000 cwe-chatbot-local:latest
sleep 10

curl -f http://localhost:8000/ && echo "✅ Docker container responds"

docker stop test-chainlit
docker rm test-chainlit
```

#### Step 6.1: Security Validation Tests
```python
# tests/deployment/test_security_validation.py
import subprocess
import json
from pathlib import Path

def test_no_hardcoded_secrets():
    """Test that no secrets are hardcoded in the application."""
    app_files = list(Path("apps/chatbot").rglob("*.py"))
    
    dangerous_patterns = [
        "sk-",  # OpenAI API key prefix
        "AIza",  # Google API key prefix
        "AKIA",  # AWS access key prefix
        "eyJ",   # JWT token prefix
    ]
    
    for file_path in app_files:
        content = file_path.read_text()
        for pattern in dangerous_patterns:
            assert f'"{pattern}"' not in content and f"'{pattern}'" not in content, \
                f"Potential hardcoded secret found in {file_path}: {pattern}"

def test_dockerfile_security_practices():
    """Test that Dockerfile follows security best practices."""
    dockerfile = Path("apps/chatbot/Dockerfile")
    content = dockerfile.read_text()
    
    # Must not run as root
    assert "USER root" not in content, "Dockerfile must not run as root user"
    assert "USER chainlit_user" in content, "Must switch to non-root user"
    
    # Must have health check
    assert "HEALTHCHECK" in content, "Dockerfile must include health check"
    
    # Must use specific Python version
    assert "python:3.11-slim" in content, "Must use specified Python version"

def test_service_account_least_privilege():
    """Test that service account has minimal permissions."""
    # This would check actual GCP permissions
    # For now, validate configuration
    pass

# RUN TEST: poetry run pytest tests/deployment/test_security_validation.py -v
# EXPECTED: PASS (security requirements met)
```

#### Step 6.2: Deployment Integration Test
```bash
# Test full CI/CD pipeline locally (without actual deployment)

# Simulate GitHub Actions workflow
echo "Simulating CI/CD pipeline..."

# 1. Security scan
echo "Running security scan..."
docker run --rm -v $(pwd):/workspace aquasec/trivy fs --exit-code 1 /workspace/apps/chatbot/

# 2. Build and test
echo "Building and testing..."
poetry run pytest tests/deployment/ -v
docker build -t test-deployment apps/chatbot/

# 3. Image security scan
echo "Scanning Docker image..."
docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
  aquasec/trivy image --exit-code 1 test-deployment

echo "✅ CI/CD simulation complete - ready for actual deployment"
```

### Phase 7: Production Deployment and Verification (Estimated: 30 minutes)

#### Step 7.0: Initial Deployment via CI/CD
```bash
# Trigger deployment by pushing to main branch

# 1. Commit all changes
git add .
git commit -m "Implement minimal Chainlit application with secure Cloud Run deployment

- Add basic Chainlit 'Hello World' application in apps/chatbot/
- Implement Docker containerization with python:3.11-slim base
- Create dedicated GCP service account with least privilege access
- Configure Artifact Registry for secure image storage
- Set up Workload Identity Federation for keyless GitHub authentication
- Add comprehensive CI/CD pipeline with security scanning
- Include TDD test suite for deployment validation
- Configure Cloud Run with secure ingress and monitoring
- Follow security-first practices per architecture documentation"

# 2. Push to main to trigger deployment
git push origin main

# 3. Monitor GitHub Actions workflow
echo "Monitor deployment at: https://github.com/your-org/CWE-ChatBot/actions"
```

#### Step 7.1: Post-Deployment Verification
```bash
# After successful CI/CD deployment

# Get service URL from Cloud Run
SERVICE_URL=$(gcloud run services describe cwe-chatbot \
  --region=us-central1 \
  --format='value(status.url)')

echo "Service deployed at: $SERVICE_URL"

# Test basic functionality
curl -f "$SERVICE_URL/" && echo "✅ Production service responds"

# Test expected content
RESPONSE=$(curl -s "$SERVICE_URL/")
if echo "$RESPONSE" | grep -q "Hello, welcome to CWE ChatBot"; then
    echo "✅ Service responding with correct content"
else
    echo "❌ Service not responding with expected content"
    exit 1
fi

# Check Cloud Run logs
gcloud logs read "resource.type=cloud_run_revision resource.labels.service_name=cwe-chatbot" \
  --limit=20 \
  --format="table(timestamp,severity,textPayload)"
```

#### Step 7.2: Security Verification
```bash
# Verify security configuration in production

# 1. Check service account permissions
gcloud iam service-accounts get-iam-policy $SERVICE_ACCOUNT_EMAIL

# 2. Verify ingress configuration  
gcloud run services describe cwe-chatbot --region=us-central1 \
  --format='value(metadata.annotations["run.googleapis.com/ingress"])'
# Should output: internal-and-cloud-load-balancing

# 3. Check that service runs as non-root
gcloud run services describe cwe-chatbot --region=us-central1 \
  --format='value(spec.template.spec.containers[0].securityContext.runAsUser)'

echo "✅ Security verification complete"
```

## Comprehensive Verification Steps

### TDD Verification
- [ ] All Chainlit app tests pass: `poetry run pytest tests/deployment/test_chainlit_app.py -v`
- [ ] All Docker configuration tests pass: `poetry run pytest tests/deployment/test_docker_config.py -v`
- [ ] All GCP configuration tests pass: `poetry run pytest tests/deployment/test_gcp_config.py -v`
- [ ] All security validation tests pass: `poetry run pytest tests/deployment/test_security_validation.py -v`

### Local Development Verification
- [ ] Chainlit app runs locally: `cd apps/chatbot && poetry run python main.py`
- [ ] Docker image builds successfully: `docker build -t test-image apps/chatbot/`
- [ ] Docker container runs correctly: `docker run -p 8000:8000 test-image`
- [ ] Basic functionality works: `curl http://localhost:8000/`

### GCP Infrastructure Verification
- [ ] Service account created with minimal permissions
- [ ] Artifact Registry repository exists and accessible
- [ ] Workload Identity Federation configured correctly
- [ ] Cloud Run service created with security settings

### CI/CD Pipeline Verification
- [ ] GitHub Actions workflow triggers on push to main
- [ ] Security scanning completes successfully
- [ ] Docker image builds and pushes to Artifact Registry
- [ ] Cloud Run deployment succeeds
- [ ] Post-deployment verification passes

### Security Controls Verification
- [ ] Service account has least privilege permissions only
- [ ] Cloud Run ingress set to "internal-and-cloud-load-balancing"
- [ ] Container runs as non-root user
- [ ] No hardcoded secrets in application code
- [ ] Docker image uses secure base image (python:3.11-slim)
- [ ] Workload Identity Federation used (no service account keys)

### Production Functionality Verification
- [ ] Service accessible via Cloud Run URL
- [ ] Welcome message displays correctly
- [ ] Basic message handling works
- [ ] Application logs appear in Cloud Logging
- [ ] Health checks pass

## Success Criteria

✅ **Chainlit Deployment Complete When:**

### Core Application
- [ ] Minimal Chainlit "Hello World" app created in apps/chatbot/
- [ ] App responds with proper welcome message
- [ ] Basic message handling functionality works
- [ ] Application follows configuration best practices

### Docker Containerization
- [ ] Dockerfile uses python:3.11-slim base image
- [ ] Container runs as non-root user for security
- [ ] Multi-stage build optimizes image size
- [ ] Health checks implemented and working
- [ ] .dockerignore excludes unnecessary files

### GCP Infrastructure
- [ ] Dedicated service account with minimal permissions
- [ ] Artifact Registry repository for secure image storage
- [ ] Workload Identity Federation for keyless authentication
- [ ] Cloud Run service configured with secure ingress
- [ ] All infrastructure follows least privilege principles

### CI/CD Pipeline
- [ ] GitHub Actions workflow triggers on code changes
- [ ] Security scanning integrated (Trivy, Bandit)
- [ ] Automated build, test, and deploy process
- [ ] No service account keys used (security requirement)
- [ ] Post-deployment verification included

### Security Controls
- [ ] All security requirements from Story 1.2 implemented
- [ ] No secrets hardcoded or committed to repository
- [ ] Container security best practices followed
- [ ] Network ingress properly restricted
- [ ] Comprehensive security testing included

### Operational Readiness
- [ ] Application logs visible in Cloud Logging
- [ ] Service accessible via provided URL
- [ ] Basic monitoring and health checks working
- [ ] Documentation updated for deployment process

## Time Estimation
- **Total Estimated Time:** 6.5 hours
  - Phase 1 (TDD Foundation + GCP Setup): 60 minutes
  - Phase 2 (Chainlit Application): 45 minutes
  - Phase 3 (Docker Containerization): 45 minutes
  - Phase 4 (GCP Infrastructure Setup): 75 minutes
  - Phase 5 (CI/CD Pipeline): 60 minutes
  - Phase 6 (Testing and Validation): 45 minutes
  - Phase 7 (Production Deployment): 30 minutes
  - Buffer for debugging/iteration: 30 minutes

- **Critical Path:** TDD Setup → Chainlit App → Docker → GCP Infrastructure → CI/CD → Deployment
- **Dependencies:** Epic 1.1 (Project Repository Setup) must be complete
- **TDD Multiplier:** 1.4x base time (essential for cloud deployment validation)

## Risk Mitigation
- **Risk:** GCP authentication/permission issues
  - **Mitigation:** Test authentication locally before CI/CD setup
- **Risk:** Docker build failures in CI/CD
  - **Mitigation:** Validate Docker builds locally first
- **Risk:** Cloud Run deployment timeouts
  - **Mitigation:** Implement proper health checks and startup probes
- **Risk:** Security misconfigurations
  - **Mitigation:** Comprehensive security testing and validation steps

## Next Steps After Completion
- Epic 1.3: CWE Data Ingestion Pipeline
- Story S-1: API Rate Limiting and Budget Monitoring (parallel security track)
- Integration with future authentication and user management features

## Dependencies
- **Epic 1.1**: Project Repository Setup (must be complete)
- **GCP Project**: Must have access to Google Cloud Project with necessary APIs enabled
- **GitHub Repository**: Must have proper secrets configured for Workload Identity Federation

## Resources Required
- Google Cloud Platform project with billing enabled
- GitHub repository with Actions enabled
- Local development environment with Docker and gcloud CLI
- Necessary GCP APIs enabled: Cloud Run, Artifact Registry, IAM, Cloud Logging