# Plan B — Ops (Cloud changes on Google Cloud)

## Objective

Expose the app at **[https://cwe.crashedmind.com](https://cwe.crashedmind.com)** behind an **External HTTPS Load Balancer** with **Cloud Armor WAF**, SSL, HTTP→HTTPS redirect, response-header policies, and origin pinning for WebSocket handshakes.

## High-level architecture

DNS (Cloud DNS) → External HTTPS LB (Global)

* **Frontend**: HTTPS, Google-managed cert for `cwe.crashedmind.com`
* **URL Map**: host rule `cwe.crashedmind.com` → backend
* **Backend**: **Serverless NEG** pointing to your **Cloud Run** service
* **Security**: **Cloud Armor** policy (preconfigured WAF + custom rules), response header policy (CSP/HSTS/etc.)

---

## Step-by-step

### 1) DNS

* Create a **Cloud DNS** public zone for **crashedmind.com** (if not already).
* Add an **A/AAAA** (or **CNAME**) record:

  * `cwe.crashedmind.com` → LB’s generated IP/endpoint.

### 2) SSL/TLS

* Create a **Google-managed certificate** for `cwe.crashedmind.com`.

  * Attach it to the LB frontend.
  * Wait for provisioning → **ACTIVE**.

### 3) Load Balancer

* Create **External HTTPS LB** (global).
* **Frontend**: HTTPS listener with the cert above.
* **Backend**:

  * Create a **Serverless NEG** referencing your **Cloud Run** service (region must match).
  * Set **timeout** ≥ 600s if you stream long responses.
* **URL Map / Host rule**:

  * Host: `cwe.crashedmind.com` → your backend service.
  * Optional: a default route to a 404 backend.

### 4) Cloud Armor WAF (attach to backend service)

* Enable **preconfigured WAF rules**:

  * XSS, SQLi, RFI, LFI, Protocol anomalies (start in **preview** → then enforce).
* Add **custom rules** (CEL) — examples:

**a) Allow only our host header**

```
expression: request.host != "cwe.crashedmind.com"
action: deny(403)
description: Block unexpected Host
```

**b) Enforce Origin on WebSocket upgrades**

```
expression:
  request.headers["upgrade"].lower() == "websocket" &&
  !(request.headers["origin"] in ["https://cwe.crashedmind.com"])
action: deny(403)
description: WS origin pinning
```

**c) Block missing Host/Origin on WS**

```
expression:
  request.headers["upgrade"].lower() == "websocket" &&
  (empty(request.headers["origin"]) || empty(request.host))
action: deny(403)
description: Missing Origin/Host on WS
```

> Keep these in **preview** first; observe logs; then move to **deny**.

### 5) HTTP→HTTPS redirect

* Add an **HTTP frontend** with redirect to HTTPS, or use global forwarding rule → **Redirect to HTTPS**.

### 6) Response headers (edge)

Add a **response header policy** on the LB (defense-in-depth; the app also sets them):

* `Strict-Transport-Security: max-age=31536000; includeSubDomains; preload`
* `Content-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-inline' 'unsafe-eval'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self' data:; connect-src 'self' https: wss:; frame-ancestors 'none'; object-src 'none'; base-uri 'self'; form-action 'self'`
* `X-Frame-Options: DENY`
* `X-Content-Type-Options: nosniff`
* `Referrer-Policy: no-referrer`
* `Permissions-Policy: geolocation=(), microphone=(), camera=(), usb=()`

> Once you confirm Chainlit UI works without inline/eval, flip CSP to a stricter variant.

### 7) Cloud Run service settings

* **Ingress**: Ideally **internal and LB** only (via serverless NEG). If you keep “all”, do not publish the direct `run.app` URL.
* **Authentication**: your app already does OAuth; keep Cloud Run unauthenticated if you rely on LB only.
* **Env vars**: set `PUBLIC_ORIGIN=https://cwe.crashedmind.com`.

### 8) OAuth configs

* Update **Google/GitHub** OAuth app **Authorized redirect URIs** and allowed origins to `https://cwe.crashedmind.com`.

### 9) Logging & Monitoring

* Enable **Cloud Armor logging**.
* Create **alerts** for spikes in 403s and 5xx.
* Create **uptime checks** for `/` and WebSocket path (if any).
* Monitor **latency** at LB and Cloud Run.

---

## Ops Validation / Tests

### Functional

* `curl -I https://cwe.crashedmind.com/` → 200 and all security headers present.
* `curl -I http://cwe.crashedmind.com/` → 301/308 to HTTPS.
* WebSocket test from another origin → **403** by Cloud Armor.
* WebSocket from correct origin → connects.

### WAF

* Run **OWASP ZAP**/Burp with XSS/SQLi payloads → see **blocked/flagged** in Cloud Armor logs (start in preview first).
* Validate that normal user flows are unaffected.

### DNS/Cert

* DNS resolves globally.
* Cert is **ACTIVE** and served by LB (browser lock icon, no warnings).

---

## Acceptance Criteria (Ops)

* [ ] **DNS** for `cwe.crashedmind.com` points to the LB; certificate active.
* [ ] **External HTTPS LB** frontends traffic to Cloud Run via **Serverless NEG**.
* [ ] **HTTP→HTTPS** redirect enabled.
* [ ] **Cloud Armor** WAF preconfigured rules enabled; custom rules for **Host pinning** and **WS Origin pinning** enforced.
* [ ] **Response header policy** at LB includes **CSP/HSTS/XFO/nosniff/Referrer-Policy/Permissions-Policy**.
* [ ] **PUBLIC_ORIGIN** configured in Cloud Run env.
* [ ] **OAuth** redirect URIs updated and tested end-to-end.
* [ ] **Monitoring**/alerts in place for WAF blocks and availability.

---

## Security guidance (both teams)

* Keep **in-app protections** **and** **edge protections**; do not rely on one layer.
* Roll out **Cloud Armor** rules in **preview** first; move to **deny** after verifying logs.
* Start with **CSP “compatible”**, then tighten to **“strict”** once Chainlit UI still works (test thoroughly).
* Never interpolate untrusted strings into markdown without escaping.
* Treat **actions/settings/feedback** as **state-changing** -> **require CSRF**.
* Rotate OAuth secrets & set **exact hostname** in OAuth app configs.

---

## Hand-off checklist

* **Dev**: open PR with the middleware, CSRF, origin guard, sanitization, tests.
* **Ops**: Terraform (or console steps) for LB, Serverless NEG, Cloud Armor, DNS, certs; run validation steps; share dashboards & alerts.

If you want, I can turn the LB steps into Terraform or gcloud commands and zip up a small **Playwright** test harness that exercises WS + actions with and without valid CSRF — just say the word.


# gcloud commands and zip up a small Playwright test harness that exercises WS + actions with and without valid CSR

Cloud Run + External HTTPS LB (no CDN) hardening via gcloud

Assumes:

Cloud Run service: cwe-chatbot in project $PROJECT_ID, region $REGION

Domain: cwe.crashedmind.com

You want strict Origin pinning + CSP + security headers + Cloud Armor CSRF/XSS filters

No existing load balancer

0) Set variables (edit these)
export PROJECT_ID="YOUR_PROJECT_ID"
export REGION="us-central1"
export SERVICE="cwe-chatbot"
export DOMAIN="cwe.crashedmind.com"
export BACKEND_TIMEOUT="60" # seconds
gcloud config set project $PROJECT_ID

1) Create a Serverless NEG for your Cloud Run service
gcloud compute network-endpoint-groups create ${SERVICE}-neg \
  --region=$REGION \
  --network-endpoint-type=serverless  \
  --cloud-run-service=$SERVICE

2) Create a backend service and attach NEG (+ standard timeouts)
gcloud compute backend-services create ${SERVICE}-be \
  --global \
  --protocol=HTTPS \
  --timeout=${BACKEND_TIMEOUT}s

gcloud compute backend-services add-backend ${SERVICE}-be \
  --global \
  --network-endpoint-group=${SERVICE}-neg \
  --network-endpoint-group-region=$REGION

3) (Recommended) Cloud Armor policy (block bad Origin/Referer, basic bot patterns)
# Create a policy in "ENFORCED" mode.
gcloud compute security-policies create ${SERVICE}-armor --description="CSRF/XSS baseline"

# Rules:
# 1000 - allow good Origin (your domain)
gcloud compute security-policies rules create 1000 \
  --security-policy=${SERVICE}-armor \
  --expression="(request.headers['origin'] == 'https://${DOMAIN}' || request.headers['origin'].empty()) && (request.headers['host'] == '${DOMAIN}')" \
  --action=allow \
  --description="Allow same-origin or missing Origin if Host matches (browser GET to HTML often has no Origin)"

# 1100 - block cross-origin WebSocket handshakes
gcloud compute security-policies rules create 1100 \
  --security-policy=${SERVICE}-armor \
  --expression="request.headers['upgrade'].lower() == 'websocket' && request.headers['origin'] != 'https://${DOMAIN}'" \
  --action=deny-403 \
  --description="Block cross-origin WebSocket handshakes"

# 1200 - block obvious bad referers
gcloud compute security-policies rules create 1200 \
  --security-policy=${SERVICE}-armor \
  --expression="request.headers['referer'].matches('(?i)://(localhost|127\\.0\\.0\\.1|evil|attack|malicious)')" \
  --action=deny-403 \
  --description="Block suspicious Referer"

# 9000 - default allow (you can switch to a stricter baseline later)
gcloud compute security-policies rules create 9000 \
  --security-policy=${SERVICE}-armor \
  --action=allow \
  --description="Default allow"


Attach the policy:

gcloud compute backend-services update ${SERVICE}-be \
  --global \
  --security-policy=${SERVICE}-armor

4) Response Header Policy: CSP, HSTS, XFO, CORP/COEP, and Referrer-Policy
gcloud compute response-headers-policies create ${SERVICE}-headers \
  --description="Security headers for Chainlit" \
  --custom-response-headers="Content-Security-Policy: default-src 'self'; connect-src 'self' https://${DOMAIN} wss://${DOMAIN}; img-src 'self' data: https:; script-src 'self'; style-src 'self' 'unsafe-inline'; frame-ancestors 'none'; base-uri 'self'; object-src 'none'" \
  --custom-response-headers="Strict-Transport-Security: max-age=31536000; includeSubDomains; preload" \
  --custom-response-headers="X-Content-Type-Options: nosniff" \
  --custom-response-headers="X-Frame-Options: DENY" \
  --custom-response-headers="Referrer-Policy: strict-origin-when-cross-origin" \
  --custom-response-headers="Cross-Origin-Resource-Policy: same-origin" \
  --custom-response-headers="Cross-Origin-Embedder-Policy: require-corp" \
  --custom-response-headers="Cross-Origin-Opener-Policy: same-origin"

5) Managed TLS cert for cwe.crashedmind.com
gcloud compute ssl-certificates create ${SERVICE}-cert \
  --domains=${DOMAIN}

6) URL map, target HTTPS proxy, forwarding rule
# URL map
gcloud compute url-maps create ${SERVICE}-urlmap \
  --default-service=${SERVICE}-be

# Attach response header policy
gcloud compute url-maps update ${SERVICE}-urlmap \
  --default-route-action=response-headers-policy=${SERVICE}-headers

# Target HTTPS proxy with cert
gcloud compute target-https-proxies create ${SERVICE}-https-proxy \
  --ssl-certificates=${SERVICE}-cert \
  --url-map=${SERVICE}-urlmap

# Global forwarding rule (443)
gcloud compute forwarding-rules create ${SERVICE}-fr \
  --global \
  --target-https-proxy=${SERVICE}-https-proxy \
  --ports=443 \
  --address=0.0.0.0

7) DNS

Create a DNS A/AAAA for cwe.crashedmind.com to the forwarding rule’s IP:

gcloud compute forwarding-rules list --global --filter="name=${SERVICE}-fr" --format="value(IPAddress)"
# Use that IP in your registrar/Cloud DNS for DOMAIN

8) Cloud Run: lock ingress to LB only (optional but recommended)
# Allow only load balancer (if you have a serverless VPC connector/LB identity)
gcloud run services update ${SERVICE} \
  --region=$REGION \
  --ingress internal-and-cloud-load-balancing

Playwright harness (ZIP)

I built a small, configurable Playwright pack that tests:

Same-origin WS connection succeeds.

Cross-origin WS connection (from https://example.com
) is blocked by your LB/Armor rule (Origin mismatch).

Chainlit Action happy-path works (click button).

Crafted invalid CSRF action frame (raw WS) is rejected (you may tweak the message payload to match your exact Chainlit protocol).

Download the zip: playwright-cwe-security-harness.zip

What’s inside

README.md — quick start + envs

package.json — minimal deps

playwright.config.ts — base config

tests/ws.spec.ts — origin pinning tests

tests/actions_csrf.spec.ts — valid action + invalid CSRF frame

utils/client.ts — helper that opens a raw WebSocket and sends a crafted “action” frame (adjust frame keys if your Chainlit version differs)

Fast start
unzip playwright-cwe-security-harness.zip -d ./pw-harness
cd ./pw-harness
npm i
export BASE_URL=https://cwe.crashedmind.com
export WS_URL=wss://cwe.crashedmind.com/ws
export ASK_ACTION_TEXT="Ask a Question"
npx playwright test --headed

Adapting the CSRF frame

Open utils/client.ts and update the frame shape to match what your server expects for action callbacks (e.g., {type:'action', name:'ask_question', payload:{...}}). Your app-side CSRF check (from earlier dev plan) should reject frames with missing/mismatched csrf_token — the test asserts rejected: true.

Acceptance checklist (Ops)

 DNS A/AAAA for cwe.crashedmind.com points to LB IP

 Managed cert status: ACTIVE

gcloud compute ssl-certificates list --filter="name=${SERVICE}-cert" --format="table(name,managed.status,managed.domainStatus)"


 Cloud Armor policy attached to backend, enforced (not preview)

 Response header policy active (verify via curl -I https://cwe.crashedmind.com)

 Cloud Run ingress set to internal-and-cloud-load-balancing (optional)

 Playwright tests: ws.spec.ts ✅ (same-origin pass, cross-origin fail)

 Playwright tests: actions_csrf.spec.ts ✅ (valid action succeeds; invalid CSRF rejected)

Acceptance checklist (Dev)

 Server verifies CSRF token from WebSocket message.metadata.csrf_token (or action payload)

 UI includes the CSRF token in action payloads and messages

 Invalid/missing token → graceful error "Invalid request token"

 No dangerous HTML echoed; CSP-compatible UI (no unsafe-eval, only 'unsafe-inline' styles if needed)