# Plan A — Dev (App changes inside your Chainlit service)

## Objective

Harden the Chainlit app for **CSRF/XSS/CSP/WebSocket origin** with the new hostname, and keep protections even if the LB/WAF is misconfigured. All changes are self-contained in the repo.

## Summary of changes

1. **Public origin & HSTS settings** via env.
2. **ASGI security middleware**: CSP, HSTS, XFO, Referrer-Policy, Permissions-Policy, COOP/COEP, clickjacking.
3. **WebSocket Origin guard** (reject mismatched `Origin`/`Host`).
4. **CSRF tokens** for **actions/settings** + soft check for standard messages.
5. **Output sanitization** for messages/elements.
6. **CORS**: restrict to the new origin.
7. **OAuth redirect URIs** updated to the new host.
8. **Security tests (pytest) + E2E (Playwright)**.

---

## Application config (new)

Add to your app config or `.env`:

```
PUBLIC_ORIGIN=https://cwe.crashedmind.com
CSP_MODE=compatible        # "strict" later, see below
HSTS_MAX_AGE=31536000      # 1 year
```

---

## 1) ASGI security middleware (add to `main.py`, near the top, after imports)

```python
# --- Security middleware for Chainlit (ASGI/Starlette) ---
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.types import ASGIApp, Scope, Receive, Send
from starlette.middleware.cors import CORSMiddleware
from urllib.parse import urlparse
import os
import secrets
import re

PUBLIC_ORIGIN = os.getenv("PUBLIC_ORIGIN", "").rstrip("/")
ALLOWED_ORIGINS = [PUBLIC_ORIGIN] if PUBLIC_ORIGIN else []
CSP_MODE = os.getenv("CSP_MODE", "compatible")  # "compatible" or "strict"
HSTS_MAX_AGE = int(os.getenv("HSTS_MAX_AGE", "31536000"))

def _build_csp():
    if CSP_MODE == "strict":
        # Tight CSP (may require UI tweaks if Chainlit uses inline scripts)
        return (
            "default-src 'self'; "
            "script-src 'self'; "
            "style-src 'self'; "
            "img-src 'self' data:; "
            "font-src 'self'; "
            "connect-src 'self' " + (PUBLIC_ORIGIN or "") + " wss: https:; "
            "frame-ancestors 'none'; "
            "base-uri 'self'; "
            "object-src 'none'; "
            "form-action 'self'"
        )
    # Compatible CSP for Chainlit UI (allows inline/eval used by some frontends)
    return (
        "default-src 'self'; "
        "script-src 'self' 'unsafe-inline' 'unsafe-eval'; "
        "style-src 'self' 'unsafe-inline'; "
        "img-src 'self' data:; "
        "font-src 'self' data:; "
        "connect-src 'self' " + (PUBLIC_ORIGIN or "") + " wss: https:; "
        "frame-ancestors 'none'; "
        "base-uri 'self'; "
        "object-src 'none'; "
        "form-action 'self'"
    )

class SecurityHeadersMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request, call_next):
        # Enforce Origin/Host match on WS upgrade and sensitive routes
        scope = request.scope
        headers = dict(request.headers)
        origin = headers.get("origin")
        host = headers.get("host")
        path = scope.get("path", "/")

        # WebSocket origin pinning
        if scope["type"] == "http" and headers.get("upgrade", "").lower() == "websocket":
            if ALLOWED_ORIGINS and origin not in ALLOWED_ORIGINS:
                from starlette.responses import PlainTextResponse
                return PlainTextResponse("Forbidden origin", status_code=403)
            # Host should match the public host
            if PUBLIC_ORIGIN:
                want_host = urlparse(PUBLIC_ORIGIN).netloc
                if host != want_host:
                    from starlette.responses import PlainTextResponse
                    return PlainTextResponse("Forbidden host", status_code=403)

        # Proceed
        response = await call_next(request)

        # Security headers
        response.headers["Content-Security-Policy"] = _build_csp()
        response.headers["Strict-Transport-Security"] = f"max-age={HSTS_MAX_AGE}; includeSubDomains; preload"
        response.headers["X-Frame-Options"] = "DENY"
        response.headers["X-Content-Type-Options"] = "nosniff"
        response.headers["Referrer-Policy"] = "no-referrer"
        response.headers["Permissions-Policy"] = "geolocation=(), microphone=(), camera=(), usb=()"
        response.headers["Cross-Origin-Opener-Policy"] = "same-origin"
        response.headers["Cross-Origin-Resource-Policy"] = "same-origin"
        response.headers["Cross-Origin-Embedder-Policy"] = "require-corp"

        return response

# Attach middleware to Chainlit's Starlette app
try:
    from chainlit.server import app as asgi_app
    asgi_app.add_middleware(SecurityHeadersMiddleware)
    if ALLOWED_ORIGINS:
        asgi_app.add_middleware(
            CORSMiddleware,
            allow_origins=ALLOWED_ORIGINS,
            allow_credentials=True,
            allow_methods=["GET", "POST", "OPTIONS"],
            allow_headers=["Authorization", "Content-Type", "X-Requested-With"],
        )
except Exception:
    pass
```

> **Why both app & LB?** You’ll add similar headers at the LB for defense-in-depth. Keeping them in-app protects you if the LB policy is changed or traffic bypasses it (e.g., direct Cloud Run URL accidentally left public).

---

## 2) CSRF tokens for actions/settings & soft check for messages

Add in `on_chat_start` and verify in callbacks:

```python
# --- CSRF token creation (on chat start) ---
@cl.on_chat_start
async def start():
    # ... existing code ...
    try:
        csrf_token = secrets.token_urlsafe(32)
        cl.user_session.set("csrf_token", csrf_token)
        # Optionally send a hidden message or store in settings so client can echo it back in actions
        await cl.Message(content="_", metadata={"csrf_token": csrf_token}).send()
    except Exception:
        pass

# Helper
def _require_csrf(meta: Optional[dict]) -> bool:
    expected = cl.user_session.get("csrf_token")
    provided = (meta or {}).get("csrf_token") or (meta or {}).get("payload", {}).get("csrf_token")
    return bool(expected and provided and secrets.compare_digest(expected, str(provided)))
```

When you create **actions**, include the token in the payload:

```python
# When building actions (e.g., ask_question)
token = cl.user_session.get("csrf_token")
actions = [cl.Action(name="ask_question", label="❓ Ask a Question", payload={"action": "ask", "csrf_token": token})]
```

And **verify** in callbacks:

```python
@cl.action_callback("ask_question")
async def on_ask_action(action: cl.Action):
    if not _require_csrf(getattr(action, "payload", {})):
        await cl.Message(content="Invalid request token").send()
        return
    # ... existing logic ...
```

For **settings updates** and **feedback**, also verify:

```python
@cl.on_settings_update
async def on_settings_update(settings: Dict[str, Any]):
    meta = cl.context.session.metadata if hasattr(cl.context.session, "metadata") else {}
    if not _require_csrf(meta):
        return
    # ... existing code ...

@cl.on_feedback
async def on_feedback(feedback):
    meta = getattr(feedback, "metadata", None)
    if not _require_csrf(meta):
        return
    # ... existing code ...
```

*For plain chat messages, keep your existing origin guard + OAuth check. Tokens are critical for state-changing operations (actions/settings).*

---

## 3) Output sanitization (server-side)

If not already, sanitize before sending any user-derived content into `cl.Message`/`cl.Text`:

```python
import html

def safe_md(s: str) -> str:
    # Minimal sanitization for user-provided strings that you interpolate
    return html.escape(s, quote=True)

# Example
await cl.Message(content=f"Uploaded file analyzed: {safe_md(filename)}").send()
```

---

## 4) OAuth redirect URIs (code reminder)

Update OAuth configs to **[https://cwe.crashedmind.com](https://cwe.crashedmind.com)** and ensure your app reads env vars for allowed redirect:

```python
# Pseudo: ensure redirect domains include PUBLIC_ORIGIN
OAUTH_ALLOWED_REDIRECT_BASE = PUBLIC_ORIGIN
```

---

## 5) Dev Test Plan

### Unit (pytest)

* **CSRF**

  * Actions without `csrf_token` → 403/blocked.
  * Actions with mismatched token → blocked.
  * Actions with correct token → allowed.

* **Origin guard**

  * Simulated WS upgrade with wrong `Origin` or `Host` → 403.
  * Matching Origin/Host → allowed.

* **CSP header present**

  * Response includes CSP, HSTS, XFO, etc.

### E2E (Playwright)

* Launch at `https://cwe.crashedmind.com`:

  * Chat works, Actions succeed.
  * Open dev tools: **no** CSP violations.
  * Attempt to run the app from an **iframe** on another origin → blocked (XFO + frame-ancestors).

### Manual checks

* Paste `<img src=x onerror=alert(1)>` into chat → **no script executes**.
* Open network tab: confirm `Content-Security-Policy` and `Strict-Transport-Security` headers.
* Try to trigger an action via crafted WebSocket frame from a different site → fails by CSRF and/or Origin guard.

---

## Acceptance Criteria (Dev)

* [ ] All responses include **CSP, HSTS, XFO, Referrer-Policy, Permissions-Policy** headers.
* [ ] WS connections **only** from `https://cwe.crashedmind.com`.
* [ ] All state-changing Chainlit callbacks (actions, settings, feedback) **require CSRF token**.
* [ ] Output sanitization prevents reflected XSS in UI elements.
* [ ] OAuth works with the new hostname and redirects.
* [ ] All tests above pass.

---

