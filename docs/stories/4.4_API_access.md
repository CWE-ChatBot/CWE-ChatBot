# Story 4.4: OAuth-Based API Access for Production

**Status**: In Progress. First pass implementation in staging.

## Story

**As a** developer integrating with the CWE ChatBot API,
**I want** to authenticate API requests using OAuth Bearer tokens from Google/GitHub,
**so that** I can access the REST API programmatically in production without relying on test-only API keys.

## Context and Background

The CWE ChatBot currently has a REST API (`/api/v1/query`) that supports API key authentication (implemented for testing purposes). However, this API key authentication is intended for **testing and staging environments only**.

**Current State:**
- **Staging**: API key authentication via `X-API-Key` header (Story CWE-82 implementation)
- **Production**: No API access currently configured
- **OAuth**: Only used for WebSocket/UI authentication via Chainlit sessions (Story 3.5)

**Problem:**
Production deployments need a more secure authentication mechanism that integrates with the existing OAuth infrastructure (Google and GitHub OAuth providers configured in Story 3.5).

**Goal:**
Enable production API access using OAuth Bearer tokens, allowing developers to:
1. Authenticate via Google/GitHub OAuth flow
2. Use their OAuth access/ID tokens as Bearer tokens for REST API requests
3. Have API access tied to their authenticated identity (same user, same permissions for UI and API)

## Acceptance Criteria

1. **AC1**: The REST API `/api/v1/query` endpoint accepts OAuth Bearer tokens from Google and GitHub OAuth providers in the `Authorization: Bearer <token>` header (FR18), **verifiable through API testing with actual OAuth tokens.**

2. **AC2**: The system validates OAuth Bearer tokens by:
   - For Google: Verifying ID token JWT signature using Google's public keys
   - For GitHub: Validating access token via GitHub API user endpoint
   - Extracting user identifier (email/login) for rate limiting and audit logging (NFR24)
   - **Verifiable through security testing with valid and invalid tokens.**

3. **AC3**: The API endpoint supports **dual authentication modes**:
   - Production mode: OAuth Bearer tokens only (secure, production-ready)
   - Staging/testing mode: OAuth Bearer tokens OR API key (backward compatible)
   - Mode is configurable via environment variable
   - **Verifiable through environment-based configuration testing.**

4. **AC4**: API rate limiting is **user-based** when using OAuth tokens:
   - Rate limits apply per user identity (email/login) instead of per IP address
   - Prevents a single user from bypassing limits by rotating IPs
   - Maintains existing IP-based rate limiting for API key authentication
   - **Verifiable through rate limit testing with OAuth tokens.**

5. **AC5**: The authentication system handles errors gracefully:
   - Invalid tokens return `401 Unauthorized` with clear error messages
   - Expired tokens return `401 Unauthorized` with "Token expired" detail
   - Missing `Authorization` header returns `401 Unauthorized` in production mode
   - All authentication failures are logged for security audit (NFR24)
   - **Verifiable through error scenario testing.**

6. **AC6**: API documentation is updated to include:
   - OAuth token acquisition flow (using existing Google/GitHub OAuth setup)
   - Bearer token authentication format and examples
   - Error response codes and troubleshooting
   - Rate limit information per authentication method
   - **Verifiable through documentation review and API documentation endpoint.**

## Security Requirements

1. **Token Validation**: All OAuth tokens MUST be cryptographically verified (JWT signature for Google, API validation for GitHub) before granting access
2. **Secure Token Handling**: OAuth tokens MUST NOT be logged in plaintext; only log token type and user identifier
3. **Rate Limiting**: OAuth-authenticated requests MUST be rate-limited per user to prevent abuse
4. **Audit Logging**: All API authentication attempts (success and failure) MUST be logged with user identifier, timestamp, and result
5. **Error Security**: Authentication error messages MUST NOT reveal sensitive information about why validation failed (generic "Invalid token" message)
6. **Token Storage**: OAuth tokens are ephemeral (not stored); validated on each request
7. **HTTPS Only**: OAuth Bearer token authentication REQUIRES HTTPS/TLS (NFR4)

## Dependencies

- **Story 3.5**: OAuth 2.0 Authentication (COMPLETE) - Provides existing Google and GitHub OAuth provider configuration
- **Story CWE-82**: API Key Authentication for Testing (COMPLETE) - Existing REST API infrastructure and API key authentication
- **Story S-1**: Rate Limiting (COMPLETE) - Foundation for rate limiting patterns

## Technical Implementation Details

### Two Implementation Approaches

The story can be implemented using either of two approaches:

#### Approach 1: OAuth Bearer Token Authentication (Recommended for Production)

**How It Works:**
- Users authenticate via Google/GitHub OAuth flow (existing Story 3.5 implementation)
- Receive OAuth access token and/or ID token from provider
- Include token in API requests: `Authorization: Bearer <token>`
- Backend validates token with OAuth provider on each request
- More flexible for programmatic/mobile clients
- Follows REST API best practices

**Implementation Pattern:**
```python
# In api.py

from jose import jwt, JWTError  # For Google ID token validation
import httpx  # For GitHub token validation

async def verify_oauth_token(authorization: str = Header(...)) -> str:
    """
    Verify OAuth Bearer token (Google or GitHub).

    Returns user identifier (email/login) for rate limiting and audit logging.
    """
    if not authorization.startswith("Bearer "):
        raise HTTPException(401, "Invalid authorization header format")

    token = authorization.replace("Bearer ", "")

    # Try Google ID token validation
    try:
        # Validate JWT signature using Google's public keys
        google_certs_url = "https://www.googleapis.com/oauth2/v3/certs"
        payload = jwt.decode(
            token,
            # ... fetch and use Google's public keys
            audience=os.getenv("OAUTH_GOOGLE_CLIENT_ID")
        )
        user_id = payload["email"]
        logger.info(f"OAuth authentication successful: {user_id} (Google)")
        return user_id
    except JWTError:
        pass  # Not a valid Google ID token, try GitHub

    # Try GitHub access token validation
    try:
        async with httpx.AsyncClient() as client:
            resp = await client.get(
                "https://api.github.com/user",
                headers={"Authorization": f"Bearer {token}"}
            )
            if resp.status_code == 200:
                data = resp.json()
                user_id = data["email"] or data["login"]
                logger.info(f"OAuth authentication successful: {user_id} (GitHub)")
                return user_id
    except Exception:
        pass

    # Token validation failed for both providers
    logger.warning("OAuth authentication failed: Invalid token")
    raise HTTPException(401, "Invalid OAuth token")

# Update query endpoint for dual authentication
@router.post("/query")
async def query_cwe(
    request: QueryRequest,
    # Allow either API key OR OAuth token
    x_api_key: Optional[str] = Header(None, alias="X-API-Key"),
    authorization: Optional[str] = Header(None),
):
    """
    Query endpoint with dual authentication:
    - Production (oauth mode): OAuth Bearer token required
    - Staging (hybrid mode): OAuth Bearer token OR API key
    """
    auth_mode = os.getenv("API_AUTH_MODE", "oauth")  # "oauth" or "hybrid"
    user_id = None

    # Try OAuth first (preferred for production)
    if authorization:
        user_id = await verify_oauth_token(authorization)
    # Fall back to API key (testing/staging only)
    elif x_api_key and auth_mode == "hybrid":
        await verify_api_key(x_api_key)
        user_id = "api-key-user"
    else:
        if auth_mode == "oauth":
            raise HTTPException(401, "OAuth Bearer token required in production mode")
        else:
            raise HTTPException(401, "Authentication required (Bearer token or API key)")

    # Apply rate limiting by user_id
    # ... rest of implementation
```

#### Approach 2: Session Cookie Authentication (Simpler)

**How It Works:**
- Users authenticate via OAuth on the web UI (existing Story 3.5 implementation)
- Session cookie automatically works for both WebSocket and REST API
- No need to handle tokens separately
- Simpler implementation leveraging existing Chainlit session management
- Best for browser-based or same-origin API clients

**Implementation Pattern:**
```python
# In api.py

async def verify_session_cookie(request: Request) -> str:
    """Verify user has valid OAuth session cookie."""
    session_id = request.cookies.get("chainlit-session")
    if not session_id:
        raise HTTPException(401, "Not authenticated - OAuth session required")

    # Validate session exists and is not expired
    # (requires accessing Chainlit's session store)
    # ... validate session_id ...

    user_id = get_user_from_session(session_id)
    logger.info(f"Session authentication successful: {user_id}")
    return user_id

@router.post("/query")
async def query_cwe(
    request: QueryRequest,
    user_id: str = Depends(verify_session_cookie)
):
    """Query endpoint using OAuth session authentication."""
    # User already authenticated via OAuth session
    # ... rest of implementation
```

**Recommendation**: Use **Approach 1 (Bearer Token)** for production as it:
- Provides more flexibility for programmatic clients (scripts, mobile apps)
- Follows REST API authentication best practices
- Works for both browser-based and non-browser clients
- Enables third-party integrations without session management

## Tasks / Subtasks

### OAuth Bearer Token Implementation Tasks

- [ ] **Task 1: Add OAuth Token Validation Dependencies (AC: 1, 2)**
  - [ ] Add `python-jose[cryptography]` for JWT validation
  - [ ] Add `httpx` for GitHub API validation (if not already present)
  - [ ] Update `pyproject.toml` and run `poetry update`

- [ ] **Task 2: Implement Google ID Token Validation (AC: 1, 2, 5)**
  - [ ] Create `verify_google_id_token()` function using `python-jose`
  - [ ] Fetch Google's public keys from `https://www.googleapis.com/oauth2/v3/certs`
  - [ ] Validate JWT signature and audience claim
  - [ ] Extract user email from token payload
  - [ ] Implement proper error handling for invalid/expired tokens
  - [ ] Add unit tests for Google token validation

- [ ] **Task 3: Implement GitHub Access Token Validation (AC: 1, 2, 5)**
  - [ ] Create `verify_github_access_token()` function using `httpx`
  - [ ] Call GitHub API `/user` endpoint with Bearer token
  - [ ] Extract user email or login from response
  - [ ] Handle GitHub API errors gracefully
  - [ ] Add unit tests for GitHub token validation

- [ ] **Task 4: Create Unified OAuth Token Verifier (AC: 1, 2, 5)**
  - [ ] Implement `verify_oauth_token()` that tries Google then GitHub
  - [ ] Return standardized user identifier regardless of provider
  - [ ] Add comprehensive error handling and logging
  - [ ] Ensure no sensitive token data is logged
  - [ ] Add integration tests for both providers

- [ ] **Task 5: Update API Endpoint with Dual Authentication (AC: 3)**
  - [ ] Modify `/api/v1/query` endpoint to accept `Authorization` header
  - [ ] Implement environment-based auth mode (`API_AUTH_MODE=oauth|hybrid`)
  - [ ] Maintain backward compatibility with API key in staging mode
  - [ ] Add request authentication to audit logs
  - [ ] Add tests for both authentication methods

- [ ] **Task 6: Implement User-Based Rate Limiting (AC: 4)**
  - [ ] Extend rate limiter to support per-user rate limiting
  - [ ] Key rate limits by user identifier from OAuth token
  - [ ] Maintain separate limits for OAuth vs API key authentication
  - [ ] Add rate limit information to response headers (X-RateLimit-*)
  - [ ] Add tests for user-based rate limiting

- [ ] **Task 7: Update API Documentation (AC: 6)**
  - [ ] Document OAuth token acquisition flow in API README
  - [ ] Add Bearer token authentication examples
  - [ ] Document authentication error codes
  - [ ] Add rate limit information per auth method
  - [ ] Create troubleshooting guide for common authentication issues

### Security Verification Tasks

- [ ] **Task 8: Security Testing (Security Requirements 1-7)**
  - [ ] Test with valid Google ID tokens
  - [ ] Test with valid GitHub access tokens
  - [ ] Test with invalid/malformed tokens
  - [ ] Test with expired tokens
  - [ ] Test token validation without logging sensitive data
  - [ ] Test rate limiting per user identity
  - [ ] Test HTTPS enforcement for OAuth endpoints
  - [ ] Verify audit logging for all authentication events

## Testing

### Unit Tests

#### OAuth Token Validation Testing
- [ ] Test Google ID token validation with valid token
- [ ] Test Google ID token validation with invalid signature
- [ ] Test Google ID token validation with expired token
- [ ] Test Google ID token validation with wrong audience
- [ ] Test GitHub access token validation with valid token
- [ ] Test GitHub access token validation with invalid token
- [ ] Test GitHub access token validation with API errors
- [ ] Test unified OAuth verifier with Google tokens
- [ ] Test unified OAuth verifier with GitHub tokens
- [ ] Test unified OAuth verifier with invalid tokens

#### API Endpoint Testing
- [ ] Test `/api/v1/query` with OAuth Bearer token (oauth mode)
- [ ] Test `/api/v1/query` with API key (hybrid mode only)
- [ ] Test `/api/v1/query` without authentication (401 expected)
- [ ] Test environment-based auth mode switching
- [ ] Test user identifier extraction from OAuth tokens

### Integration Tests

#### End-to-End Authentication Flow Testing
- [ ] Test complete OAuth flow: authenticate ‚Üí get token ‚Üí call API
- [ ] Test API access with real Google OAuth tokens
- [ ] Test API access with real GitHub OAuth tokens
- [ ] Test authentication failure scenarios
- [ ] Test rate limiting with multiple OAuth users
- [ ] Test audit logging for OAuth API access

### Security Tests

#### OAuth Security Verification
- [ ] **Token Validation**: Verify cryptographic validation of JWT signatures
- [ ] **Token Expiration**: Verify expired tokens are rejected
- [ ] **Audience Validation**: Verify tokens with wrong audience are rejected
- [ ] **Provider Validation**: Verify tokens from unauthorized providers are rejected
- [ ] **Token Leakage Prevention**: Verify tokens are not logged in plaintext
- [ ] **Rate Limit Enforcement**: Verify per-user rate limits cannot be bypassed
- [ ] **Error Message Safety**: Verify authentication errors don't leak sensitive information
- [ ] **HTTPS Enforcement**: Verify OAuth authentication fails over non-HTTPS connections

### Manual Verification

#### OAuth API Access Verification
- [ ] Authenticate via Google OAuth on web UI, extract token, call API with Bearer token
- [ ] Authenticate via GitHub OAuth on web UI, extract token, call API with Bearer token
- [ ] Test API access from Postman/curl with Bearer tokens
- [ ] Verify rate limiting by making multiple requests with same OAuth token
- [ ] Test error handling by providing invalid/expired tokens
- [ ] Verify audit logs show OAuth API access events

## Environment Configuration

### Required Environment Variables

**Production (oauth mode):**
```bash
# Authentication mode
API_AUTH_MODE=oauth  # OAuth Bearer tokens only

# OAuth configuration (from Story 3.5)
OAUTH_GOOGLE_CLIENT_ID=<from-gcp-secret-manager>
OAUTH_GOOGLE_CLIENT_SECRET=<from-gcp-secret-manager>
OAUTH_GITHUB_CLIENT_ID=<from-gcp-secret-manager>
OAUTH_GITHUB_CLIENT_SECRET=<from-gcp-secret-manager>
```

**Staging/Testing (hybrid mode):**
```bash
# Authentication mode
API_AUTH_MODE=hybrid  # OAuth Bearer tokens OR API key

# OAuth configuration
OAUTH_GOOGLE_CLIENT_ID=<from-gcp-secret-manager>
OAUTH_GOOGLE_CLIENT_SECRET=<from-gcp-secret-manager>
OAUTH_GITHUB_CLIENT_ID=<from-gcp-secret-manager>
OAUTH_GITHUB_CLIENT_SECRET=<from-gcp-secret-manager>

# API key (for testing only)
TEST_API_KEY=<from-gcp-secret-manager>  # Falls back to test-api-key secret
```

### Configuration Files

Update `apps/chatbot/.env.example`:
```bash
# API Authentication Mode
# oauth: OAuth Bearer tokens only (production)
# hybrid: OAuth Bearer tokens OR API key (staging/testing)
API_AUTH_MODE=oauth

# OAuth Configuration (from Story 3.5)
OAUTH_GOOGLE_CLIENT_ID=your-google-client-id
OAUTH_GOOGLE_CLIENT_SECRET=your-google-client-secret
OAUTH_GITHUB_CLIENT_ID=your-github-client-id
OAUTH_GITHUB_CLIENT_SECRET=your-github-client-secret
```

## API Usage Examples

### Example 1: Using Google OAuth Token

```bash
# Step 1: Authenticate via OAuth (web UI)
# Navigate to https://cwe-chatbot.example.com
# Login with Google
# Extract ID token from browser developer tools (Network tab, look for token in OAuth callback)

# Step 2: Call API with Bearer token
curl -X POST https://cwe-chatbot.example.com/api/v1/query \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer <google-id-token>" \
  -d '{
    "query": "What is CWE-89?",
    "persona": "DEVELOPER",
    "max_results": 5
  }'
```

### Example 2: Using GitHub OAuth Token

```bash
# Step 1: Authenticate via OAuth (web UI)
# Navigate to https://cwe-chatbot.example.com
# Login with GitHub
# Extract access token from browser developer tools

# Step 2: Call API with Bearer token
curl -X POST https://cwe-chatbot.example.com/api/v1/query \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer <github-access-token>" \
  -d '{
    "query": "How do I prevent SQL injection?",
    "persona": "PSIRT_MEMBER",
    "max_results": 5
  }'
```

### Example 3: Error Handling

```bash
# Invalid token
curl -X POST https://cwe-chatbot.example.com/api/v1/query \
  -H "Authorization: Bearer invalid-token" \
  -d '{"query": "test"}'

# Response: 401 Unauthorized
{
  "detail": "Invalid OAuth token"
}

# Missing authorization (production mode)
curl -X POST https://cwe-chatbot.example.com/api/v1/query \
  -d '{"query": "test"}'

# Response: 401 Unauthorized
{
  "detail": "OAuth Bearer token required in production mode"
}
```

## Definition of Done

- [ ] OAuth Bearer token authentication implemented for `/api/v1/query` endpoint
- [ ] Google ID token validation working with JWT signature verification
- [ ] GitHub access token validation working with API validation
- [ ] Dual authentication mode (oauth/hybrid) configurable via environment variable
- [ ] User-based rate limiting implemented for OAuth-authenticated requests
- [ ] Error handling for invalid, expired, and missing tokens implemented
- [ ] All security tests passing (token validation, rate limiting, audit logging)
- [ ] API documentation updated with OAuth authentication guide
- [ ] Production deployment configuration updated with OAuth-only mode
- [ ] Staging deployment configuration updated with hybrid mode
- [ ] Manual verification completed with both Google and GitHub OAuth tokens

## Dev Notes

### Implementation Considerations

**Token Acquisition:**
- Users authenticate via existing OAuth flow (Story 3.5)
- ID/access tokens are available in OAuth callback but not currently stored
- For API usage, users need to extract tokens from browser (developer tools) or OAuth flow
- Consider adding a "Get API Token" feature in web UI for easier token access

**Token Refresh:**
- OAuth tokens have limited lifetime (typically 1 hour)
- Clients must handle token expiration and re-authenticate
- Consider implementing token refresh endpoint in future story

**Rate Limiting Strategy:**
- OAuth-authenticated requests: 60 requests/minute per user
- API key authenticated requests: 10 requests/minute per IP (existing)
- Users cannot bypass limits by switching OAuth providers (same user = same limits)

**Backward Compatibility:**
- Staging/testing environments keep API key authentication
- Production can disable API key authentication entirely (oauth mode)
- No breaking changes to existing API key users in staging

### Security Considerations

**Token Validation:**
- Google ID tokens: Cryptographic validation using public keys (no API call needed)
- GitHub access tokens: Must call GitHub API to validate (rate limited to 5000/hour per user)
- Cache Google public keys to reduce latency (refresh every 24 hours)

**Error Messages:**
- Never reveal why token validation failed (don't expose JWT parsing errors)
- Use generic "Invalid OAuth token" message for all validation failures
- Log detailed errors server-side for debugging

**Audit Logging:**
- Log all API authentication attempts (success and failure)
- Include: timestamp, user identifier, authentication method, result
- Never log full tokens (only token type and last 4 characters for correlation)

### Future Enhancements (Out of Scope)

- **API Token Management UI**: Web interface to generate/revoke API tokens
- **Token Refresh Endpoint**: Automatic token refresh without re-authentication
- **Scoped API Tokens**: Different permission levels for API access
- **Third-Party OAuth Providers**: Support for additional OAuth providers beyond Google/GitHub
- **API Key Rotation**: Automated API key rotation for testing environments

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-10-12 | 1.0 | Initial story creation from technical notes and Story 3.5 OAuth implementation | Bob (Scrum Master) |

## Dev Agent Record

### Status
üü° Partially Implemented - API Key Authentication for Staging Complete (2025-10-13)

### Completed Work (Story CWE-82 + Story 4.2)

**API Key Authentication for Staging** ‚úÖ COMPLETE (2025-10-11 to 2025-10-13)

Implemented test-login endpoint for API key authentication in staging/hybrid mode as prerequisite for full OAuth Bearer token implementation.

**Implementation Details:**
- **Endpoint**: `POST /api/v1/test-login` with `X-API-Key` header
- **Returns**: Session cookie for subsequent API calls
- **Mode Control**: `AUTH_MODE=hybrid` enables endpoint, `AUTH_MODE=oauth` disables it (production)
- **Security**: API key stored in GCP Secret Manager (`test-api-key` secret)
- **Configuration**: `TEST_API_KEY` environment variable in staging deployment

**Usage Example:**
```bash
# Step 1: Authenticate with API key to get session cookie
TEST_API_KEY=$(gcloud secrets versions access latest --secret=test-api-key)
curl -X POST https://cwe-chatbot-staging-bmgj6wj65a-uc.a.run.app/api/v1/test-login \
  -H "X-API-Key: $TEST_API_KEY" \
  -c cookies.txt

# Step 2: Use session cookie for API queries
curl -X POST https://cwe-chatbot-staging-bmgj6wj65a-uc.a.run.app/api/v1/query \
  -b cookies.txt \
  -H "Content-Type: application/json" \
  -d '{
    "query": "What is CWE-82?",
    "persona": "DEVELOPER",
    "max_results": 5
  }'
```

**Real-World Usage:**
- Successfully used for debugging **ISSUE-CWE-82-NOT-FOUND.md** (2025-10-11)
- Enabled automated testing and investigation without OAuth browser flow
- Validated force-injection fix for CWE ID queries
- Session-based API access working reliably in staging

**Current Staging Configuration:**
- **Service**: `cwe-chatbot-staging`
- **Auth Mode**: `AUTH_MODE=hybrid`
- **OAuth**: Enabled (Google/GitHub for UI)
- **API Key**: Enabled via test-login endpoint (for automated testing)
- **Production Safety**: Test-login endpoint returns 404 when `AUTH_MODE=oauth`

**Task Completion Status:**
- ‚úÖ API key authentication for staging (hybrid mode)
- ‚úÖ Session cookie authentication for REST API
- ‚úÖ Test-login endpoint with mode-based enable/disable
- ‚úÖ Integration with GCP Secret Manager
- ‚è≥ OAuth Bearer token validation (remaining work)
- ‚è≥ User-based rate limiting for OAuth tokens (remaining work)

### Remaining Work: OAuth Bearer Token Implementation

The following tasks from the original story remain for full OAuth Bearer token support in production (AC1-AC6).

### Status
‚è≥ Ready for Implementation

### Files to Create/Modify
**Modified Files:**
- `apps/chatbot/api.py` - Add OAuth Bearer token authentication
- `apps/chatbot/src/app_config.py` - Add API authentication mode configuration
- `apps/chatbot/.env.example` - Add OAuth API authentication environment variables
- `apps/chatbot/pyproject.toml` - Add OAuth token validation dependencies

**New Files:**
- `apps/chatbot/src/auth/oauth_token_validator.py` - OAuth token validation logic
- `apps/chatbot/tests/unit/test_oauth_api_auth.py` - OAuth API authentication unit tests
- `apps/chatbot/tests/integration/test_oauth_api_flow.py` - End-to-end OAuth API flow tests
- `apps/chatbot/tests/security/test_oauth_api_security.py` - OAuth API security tests
- `apps/chatbot/docs/API_AUTHENTICATION.md` - API authentication guide

### Related Documentation
- Story 3.5: OAuth Authentication (prerequisite)
- Story CWE-82: API Key Authentication (existing implementation)
- Story S-1: Rate Limiting (foundation for user-based rate limiting)

## QA Results
*Results from QA Agent review will be added here after implementation*

## Security Review Results
*Results from security review will be added here after implementation*

### Vulnerability Findings
*To be filled during security review*

### Security Compliance Status
*To be filled during security review*

### Remediation Recommendations
*To be filled during security review*
