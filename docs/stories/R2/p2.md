Patch P2 â€” Chainlit-native UX + small architecture trims
*** Begin Patch
*** Update File: src/conversation.py
@@
             else:
                 retrieved_chunks = await self.query_handler.process_query(
-                    combined_query, user_context_data
-                )
+                    combined_query, user_context_data
+                )
 
             # Create message and stream tokens
             # If the user explicitly mentioned a CWE id, echo it upfront for clarity in UI/tests
             preface = ""
@@
-            msg = cl.Message(content=preface)
-            await msg.send()
+            # Retrieval step (visible in UI)
+            try:
+                async with cl.Step(name="Retrieve CWE context", type="tool") as st:
+                    st.input = combined_query
+                    # If retrieved_chunks was short-circuited above, keep as is
+                    if context.persona not in ("CWE Analyzer", "CVE Creator"):
+                        # already retrieved above; just report count
+                        st.output = f"{len(retrieved_chunks)} chunks"
+                    else:
+                        st.output = "persona-specific analysis (no retrieval)"
+            except Exception:
+                pass
+
+            msg = cl.Message(content=preface)
+            await msg.send()
             collected = ""
-            try:
-                async for token in self.response_generator.generate_response_streaming(
-                    combined_query,
-                    retrieved_chunks or [],
-                    context.persona,
-                    user_evidence=context.file_evidence,
-                ):
-                    if token:  # Ensure token is not None or empty
-                        try:
-                            await msg.stream_token(token)
-                            collected += str(token)  # Ensure token is string
-                        except Exception as e:
-                            logger.warning(f"Failed to stream token: {e}")
-                            collected += str(token)  # Still collect token for processing
-            except Exception as e:
-                logger.error(f"Streaming generation failed: {e}")
-                # Fallback to basic error response if streaming completely fails
-                if not collected:
-                    collected = self.response_generator._generate_error_response(context.persona)
+            # Generation step (visible in UI)
+            try:
+                async with cl.Step(name="Generate answer", type="run") as gen_step:
+                    gen_step.input = f"persona={context.persona}"
+                    async for token in self.response_generator.generate_response_streaming(
+                        combined_query,
+                        retrieved_chunks or [],
+                        context.persona,
+                        user_evidence=context.file_evidence,
+                    ):
+                        if token:
+                            try:
+                                await msg.stream_token(token)
+                                collected += str(token)
+                            except Exception as e:
+                                logger.warning(f"Failed to stream token: {e}")
+                                collected += str(token)
+                    gen_step.output = f"{len(collected)} characters"
+            except Exception as e:
+                logger.error(f"Streaming generation failed: {e}")
+                # Fallback to basic error response if streaming completely fails
+                if not collected:
+                    collected = self.response_generator._generate_error_response(context.persona)
 
             # Validate final and update if masked
             validation_result = self.security_validator.validate_response(collected)
             final_response = validation_result["validated_response"]
             if final_response != collected:
*** End Patch

*** Begin Patch
*** Update File: main.py
@@
 def initialize_components() -> bool:
     """Initialize all Story 2.1 chatbot components with error handling."""
     global conversation_manager, input_sanitizer, security_validator, file_processor, _init_ok
 
     try:
+        # Prevent double-initialization (import-time + CLI)
+        if _init_ok and conversation_manager is not None:
+            return _init_ok
+
         # Validate config once; if it fails, we will surface a UI error and disable handlers
         try:
             app_config.validate_config()
         except Exception as cfg_err:
             logger.log_exception("Configuration validation failed", cfg_err, extra_context={
*** End Patch

*** Begin Patch
*** Update File: src/query_handler.py
@@
             if section_boost:
                 # Pull boost value from centralized config
                 try:
-                    from .app_config import config
+                    from .app_config_extended import config
                     boost_value = getattr(config, "section_boost_value", 0.15)
                 except Exception:
                     boost_value = 0.15
                 query_params["section_intent_boost"] = section_boost
                 query_params["section_boost_value"] = boost_value
*** End Patch