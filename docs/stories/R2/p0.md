Patch P0 â€” blocking bugs & correctness
*** Begin Patch
*** Update File: src/conversation.py
@@
 class ConversationManager:
     """
     Manages conversation flow and integration with Chainlit.
@@
         return cl.user_session.get("user_context")
 
+    def get_user_context(self, session_id: str) -> UserContext:
+        """
+        Public accessor to retrieve or create the per-user context.
+        (Shim to avoid callers poking cl.user_session directly.)
+        """
+        return self._get_or_create_user_context(session_id)
+
     def record_feedback(self, session_id: str, message_id: str, rating: int) -> bool:
         """
         Record user feedback for a specific message.
 
*** End Patch

*** Begin Patch
*** Update File: main.py
@@
     # Integrate OAuth authentication with user context
     user = cl.user_session.get("user")
     if user and hasattr(user, 'metadata') and user.metadata:
         try:
             # User is authenticated via OAuth - integrate with UserContext
-            user_context = await conversation_manager.get_user_context(session_id)
+            user_context = conversation_manager.get_user_context(session_id)
             if user_context:
                 user_context.set_oauth_data(
                     provider=user.metadata.get("provider"),
                     email=user.metadata.get("email"),
                     name=user.metadata.get("name"),
@@
     # Session validation and activity tracking
     try:
-        user_context = await conversation_manager.get_user_context(cl.context.session.id)
+        user_context = conversation_manager.get_user_context(cl.context.session.id)
         if user_context and user_context.is_authenticated:
             user_context.update_activity()
     except Exception as e:
         logger.log_exception("Failed to update user activity", e)
*** End Patch

*** Begin Patch
*** Update File: src/processing/explanation_builder.py
@@
     def _extract_snippet_candidates(self, query: str, chunks: List[Dict]) -> List[Dict]:
@@
-        for chunk in chunks:
-            content = chunk.get("content", "")
+        for chunk in chunks:
+            # Standardized: primary text is under "document" in your pipeline
+            content = chunk.get("document") or chunk.get("content", "")
             section = chunk.get("metadata", {}).get("section", "Unknown")
             score = chunk.get("score", chunk.get("hybrid_score", 0.0))
 
             if not content:
                 continue
@@
     def _extract_cwe_name(self, chunks: List[Dict]) -> str:
@@
-        for chunk in chunks:
-            cwe_name = chunk.get("metadata", {}).get("cwe_name")
+        for chunk in chunks:
+            cwe_name = (
+                chunk.get("metadata", {}).get("name")
+                or chunk.get("metadata", {}).get("cwe_name")
+            )
             if cwe_name:
                 return cwe_name
*** End Patch

*** Begin Patch
*** Update File: src/processing/confidence_calculator.py
@@
 def create_aggregated_cwe(cwe_id: str,
                          name: str,
                          chunks: List[Dict],
                          exact_match: bool = False) -> AggregatedCWE:
@@
     for chunk in chunks:
         # Extract score (could be in different fields depending on retrieval method)
-        score = chunk.get("score", chunk.get("hybrid_score", 0.0))
+        score = chunk.get("score", chunk.get("hybrid_score"))
+        if score is None:
+            # Your retrieval shape keeps scores nested under "scores"
+            s = (chunk.get("scores") or {})
+            score = s.get("hybrid", s.get("vec", 0.0))
         if isinstance(score, (int, float)):
             top_scores.append(float(score))
 
         # Count section hits
         section = chunk.get("metadata", {}).get("section", "Unknown")
*** End Patch

*** Begin Patch
*** Update File: healthcheck.py
@@
 """
 Secure health check script for CWE ChatBot
 Provides safe health check without command injection risks
 """
 
 import sys
+import os
 import urllib.request
 import urllib.error
 
 def main():
     """Perform health check on the Chainlit application."""
     try:
-        # Use localhost health endpoint with timeout
-        with urllib.request.urlopen('http://localhost:8080/health', timeout=5) as response:
+        # Configurable endpoint; default to Chainlit's 8000
+        url = os.getenv('HEALTHCHECK_URL', 'http://localhost:8000/health')
+        # Use localhost health endpoint with timeout
+        with urllib.request.urlopen(url, timeout=5) as response:
             if response.status == 200:
                 sys.exit(0)  # Healthy
             else:
                 sys.exit(1)  # Unhealthy status code
*** End Patch