# Story S-1.1: Gateway Configuration Guide for X-User-Id Header Injection

## Overview

Per-user rate limiting requires a **trusted gateway** to inject the `X-User-Id` header after authentication. This document explains how to configure various gateway options to enable this functionality.

## Current Deployment Status

✅ **Staging Deployed**: Cloud Armor rule active at priority 900
✅ **Load Balancer Security**: Client X-User-Id headers correctly stripped
✅ **Tests Pass**: Spoofing protection and per-IP fallback verified
⚠️ **Gateway Required**: Need trusted X-User-Id injection to activate per-user limits

## Architecture Overview

```
Client Request                   Gateway/IAP                  Cloud Armor               Backend
    |                                |                            |                        |
    |--[X-User-Id: spoofed]-------->|                            |                        |
    |                                |                            |                        |
    |                                |--[Strip client header]---->|                        |
    |                                |                            |                        |
    |                                |--[Authenticate user]       |                        |
    |                                |                            |                        |
    |                                |--[Add X-User-Id: hash]---->|--[Rate limit check]--->|
    |                                |                            |                        |
    |                                |                            |   429 if over limit    |
    |                                |                            |   200 if under limit   |
```

## Gateway Options

### Option 1: Identity-Aware Proxy (IAP) - Recommended for GCP

**Best for**: GCP-native deployments with Google/GitHub OAuth

#### Step 1: Enable IAP

```bash
# Enable IAP for the backend service
gcloud compute backend-services update cwe-chatbot-backend \
  --global \
  --iap=enabled \
  --oauth2-client-id=YOUR_CLIENT_ID \
  --oauth2-client-secret=YOUR_CLIENT_SECRET
```

#### Step 2: Configure IAP to Add X-User-Id Header

IAP automatically adds the `X-Goog-Authenticated-User-Email` header. We need to transform this to `X-User-Id`:

**Option A: Use Cloud Armor to transform header** (if supported)
```bash
# Cloud Armor header transformation (check if supported)
gcloud compute url-maps update cwe-chatbot-lb \
  --default-route-action='{
    "headerAction": {
      "requestHeadersToAdd": [{
        "headerName": "X-User-Id",
        "headerValue": "{X-Goog-Authenticated-User-Email}",
        "replace": true
      }]
    }
  }'
```

**Option B: Use Cloud Function/Cloud Run middleware**
Deploy a small Cloud Function or middleware in your app that:
1. Reads `X-Goog-Authenticated-User-Email` from IAP
2. Hashes it to create stable user ID
3. Adds `X-User-Id` header for downstream processing

```python
# middleware example
import hashlib
import os

SALT = os.environ.get("USER_ID_SALT", "default-salt-change-me")

def hash_user_email(email: str) -> str:
    """Create stable, opaque user ID from email."""
    data = f"{email}{SALT}".encode()
    return hashlib.sha256(data).hexdigest()[:16]

@app.middleware("http")
async def add_user_id_header(request, call_next):
    # Get IAP header
    iap_email = request.headers.get("X-Goog-Authenticated-User-Email")

    if iap_email:
        # Extract email from IAP format: "accounts.google.com:user@example.com"
        parts = iap_email.split(":", 1)
        email = parts[1] if len(parts) > 1 else parts[0]

        # Create stable user ID
        user_id = hash_user_email(email)

        # Add header for Cloud Armor
        request.state.user_id = user_id
        request.headers["X-User-Id"] = user_id

    response = await call_next(request)
    return response
```

#### Step 3: Verify IAP Configuration

```bash
# Test IAP is working
curl -H "Authorization: Bearer $(gcloud auth print-identity-token)" \
  https://cwe.crashedmind.com

# Check logs for X-Goog-Authenticated-User-Email header
gcloud logging read 'resource.type="http_load_balancer"' \
  --limit=5 \
  --format=json \
  | grep -i "x-goog-authenticated"
```

### Option 2: API Gateway (Apigee/Cloud Endpoints)

**Best for**: API-first architectures with custom JWT validation

#### Step 1: Configure API Gateway

```yaml
# openapi.yaml
swagger: "2.0"
info:
  title: CWE ChatBot API
  version: "1.0.0"
host: cwe.crashedmind.com
x-google-backend:
  address: https://cwe-chatbot-backend.run.app
  jwt_audience: YOUR_JWT_AUDIENCE

securityDefinitions:
  auth0:
    authorizationUrl: ""
    flow: "implicit"
    type: "oauth2"
    x-google-issuer: "https://your-auth-provider.com"
    x-google-jwks_uri: "https://your-auth-provider.com/.well-known/jwks.json"
    x-google-audiences: "YOUR_AUDIENCE"

paths:
  /**:
    get:
      security:
        - auth0: []
      x-google-backend:
        address: https://cwe-chatbot-backend.run.app
        # Add X-User-Id from JWT sub claim
        jwt_header: "X-User-Id"
        jwt_claim: "sub"
```

#### Step 2: Deploy API Gateway

```bash
# Deploy gateway config
gcloud api-gateway api-configs create cwe-chatbot-config \
  --api=cwe-chatbot-api \
  --openapi-spec=openapi.yaml \
  --backend-auth-service-account=cwe-chatbot-backend@cwechatbot.iam.gserviceaccount.com

# Create gateway
gcloud api-gateway gateways create cwe-chatbot-gateway \
  --api=cwe-chatbot-api \
  --api-config=cwe-chatbot-config \
  --location=us-central1
```

### Option 3: Application-Level Middleware

**Best for**: Quick implementation, full control

#### Implementation

Add middleware to your Chainlit application:

```python
# apps/chatbot/src/middleware/user_id_injector.py
"""
User ID injection middleware for rate limiting.
Extracts user identity from OAuth session and adds X-User-Id header.
"""
import hashlib
import os
from starlette.middleware.base import BaseHTTPMiddleware
from starlette.requests import Request

class UserIdInjectorMiddleware(BaseHTTPMiddleware):
    """Inject X-User-Id header from authenticated user session."""

    def __init__(self, app, salt: str = None):
        super().__init__(app)
        self.salt = salt or os.environ.get("USER_ID_SALT", "change-me-in-production")

    async def dispatch(self, request: Request, call_next):
        # Get user from Chainlit OAuth session
        user = request.session.get("user")

        if user:
            # Extract user identifier (email, sub, or username)
            user_identifier = (
                user.get("identifier") or
                user.get("email") or
                user.get("sub") or
                user.get("username")
            )

            if user_identifier:
                # Create stable, opaque user ID
                user_id = self._hash_user_id(user_identifier)

                # Add header for Cloud Armor rate limiting
                # This header will be preserved through Load Balancer
                request.headers.__dict__["_list"].append(
                    (b"x-user-id", user_id.encode())
                )

        response = await call_next(request)
        return response

    def _hash_user_id(self, identifier: str) -> str:
        """Create stable, opaque user ID."""
        data = f"{identifier}{self.salt}".encode()
        return hashlib.sha256(data).hexdigest()[:16]


# In apps/chatbot/main.py - Add middleware
from src.middleware.user_id_injector import UserIdInjectorMiddleware

# After creating app, add middleware
app.add_middleware(UserIdInjectorMiddleware)
```

#### Configuration

```bash
# Set salt via Secret Manager
gcloud secrets create user-id-salt \
  --data-file=<(openssl rand -hex 32)

# Grant Cloud Run access
gcloud secrets add-iam-policy-binding user-id-salt \
  --member="serviceAccount:cwe-chatbot-run-sa@cwechatbot.iam.gserviceaccount.com" \
  --role="roles/secretmanager.secretAccessor"

# Update Cloud Run service
gcloud run services update cwe-chatbot \
  --region=us-central1 \
  --update-secrets=USER_ID_SALT=user-id-salt:latest
```

## Load Balancer Header Configuration

**CRITICAL**: Load Balancer must strip client X-User-Id before gateway adds it.

### Current Configuration (Verify)

```bash
# Check if Load Balancer strips X-User-Id
gcloud compute url-maps describe cwe-chatbot-lb --format=json \
  | grep -i "requestheaderstoremove"

# Should show: "requestHeadersToRemove": ["X-User-Id"]
```

### Apply Header Stripping (if not already done)

```bash
gcloud compute url-maps update cwe-chatbot-lb \
  --default-route-action='{
    "headerAction": {
      "requestHeadersToRemove": ["X-User-Id"]
    }
  }'
```

## Testing Gateway Configuration

### Test 1: Verify Header Injection

```bash
# Make authenticated request
curl -v -H "Authorization: Bearer $(gcloud auth print-identity-token)" \
  https://cwe.crashedmind.com 2>&1 \
  | grep -i "x-user-id"

# Should see X-User-Id in request
```

### Test 2: Verify Rate Limiting Activates

```bash
# Send 15 rapid requests (should hit limit at 11th)
for i in {1..15}; do
  curl -s -o /dev/null -w "%{http_code}\n" \
    -H "Authorization: Bearer $(gcloud auth print-identity-token)" \
    https://cwe.crashedmind.com
  sleep 0.1
done

# Expected: First 10 return 200, then 429s
```

### Test 3: Check Cloud Logging

```bash
# Look for DENY_429 with HTTP_HEADER enforcement
gcloud logging read \
  'resource.type="http_load_balancer" AND jsonPayload.enforcedAction="DENY_429"' \
  --limit=10 \
  --format=json \
  | grep -E "(enforcedOnKey|x-user-id)"

# Should show: "enforcedOnKey": "HTTP_HEADER"
```

## Security Considerations

### User ID Generation

**DO**:
- ✅ Use cryptographic hash (SHA-256)
- ✅ Add salt to prevent rainbow table attacks
- ✅ Use stable identifier (email, sub claim)
- ✅ Keep hash short (16 chars sufficient)

**DON'T**:
- ❌ Use raw email addresses
- ❌ Use sequential IDs
- ❌ Use PII directly
- ❌ Use timestamps

### Salt Management

```bash
# Generate strong salt
openssl rand -hex 32

# Store in Secret Manager (not in code!)
gcloud secrets create user-id-salt \
  --data-file=<(openssl rand -hex 32)

# Rotate periodically (quarterly recommended)
gcloud secrets versions add user-id-salt \
  --data-file=<(openssl rand -hex 32)
```

### Header Security

1. **Client headers MUST be stripped** at Load Balancer
2. **Gateway MUST add header** after authentication
3. **Backend MUST NOT trust** X-User-Id without gateway verification
4. **Logs SHOULD NOT contain** raw email addresses

## Troubleshooting

### Issue: X-User-Id not appearing in logs

**Check**:
```bash
# 1. Verify Load Balancer config
gcloud compute url-maps describe cwe-chatbot-lb --format=json

# 2. Check if gateway is adding header
gcloud logging read 'resource.type="http_load_balancer"' \
  --limit=10 \
  --format=json \
  | jq '.[] | .httpRequest.requestHeaders'

# 3. Verify IAP/gateway is enabled
gcloud compute backend-services describe cwe-chatbot-backend \
  --global \
  --format=json \
  | jq '.iap'
```

### Issue: Rate limiting not triggering

**Check**:
```bash
# 1. Verify Cloud Armor rule is active
gcloud compute security-policies rules describe 900 \
  --security-policy=cwe-chatbot-armor

# 2. Check expression evaluates correctly
# Expression should be: has(request.headers['x-user-id'])

# 3. Verify enforce-on-key settings
# Should be: enforceOnKey=http-header, enforceOnKeyName=x-user-id
```

### Issue: All requests getting 429

**Possible Causes**:
1. User ID not unique (multiple users sharing same ID)
2. Rate limit too low for production traffic
3. Header value incorrect format

**Resolution**:
```bash
# Temporarily increase rate limit
gcloud compute security-policies rules update 900 \
  --security-policy=cwe-chatbot-armor \
  --rate-limit-threshold-count=120

# Check Cloud Logging for user ID distribution
gcloud logging read \
  'resource.type="http_load_balancer" AND jsonPayload.enforcedAction="DENY_429"' \
  --format=json \
  | jq -r '.[] | .jsonPayload.enforcedOnKeyValue' \
  | sort | uniq -c | sort -rn
```

## Implementation Checklist

### Phase 1: Gateway Setup
- [ ] Choose gateway option (IAP/API Gateway/Middleware)
- [ ] Configure authentication (OAuth/JWT)
- [ ] Generate and store USER_ID_SALT in Secret Manager
- [ ] Implement user ID hashing logic
- [ ] Deploy gateway configuration

### Phase 2: Load Balancer Security
- [ ] Verify Load Balancer strips client X-User-Id
- [ ] Test spoofing protection (client headers rejected)
- [ ] Verify gateway adds X-User-Id after auth

### Phase 3: Testing
- [ ] Test authenticated requests include X-User-Id
- [ ] Verify rate limiting triggers at threshold
- [ ] Check Cloud Logging shows HTTP_HEADER enforcement
- [ ] Test multiple users have independent limits
- [ ] Verify spoofing attempts fail

### Phase 4: Production Promotion
- [ ] Run integration tests (all pass)
- [ ] Run E2E tests (no regressions)
- [ ] Monitor for 15+ minutes (no issues)
- [ ] Promote from priority 900 → 1000
- [ ] Monitor production for 30 minutes

## Recommended Implementation: Application Middleware

**For CWE ChatBot specifically**, we recommend **Option 3: Application-Level Middleware** because:

1. ✅ **Already have OAuth**: Chainlit OAuth is working
2. ✅ **Full control**: Can customize user ID generation
3. ✅ **No additional infrastructure**: Uses existing Cloud Run
4. ✅ **Easy testing**: Can test locally before deployment
5. ✅ **Quick implementation**: <100 lines of code

### Next Steps

1. Implement `UserIdInjectorMiddleware` in apps/chatbot/src/middleware/
2. Add middleware to apps/chatbot/main.py
3. Generate and store USER_ID_SALT in Secret Manager
4. Deploy to Cloud Run
5. Run integration tests to verify
6. Promote staging rule (900) to production (1000)

## Timeline Estimate

| Phase | Duration | Description |
|-------|----------|-------------|
| Middleware Implementation | 30 min | Write and test UserIdInjectorMiddleware |
| Secret Setup | 10 min | Generate salt, store in Secret Manager |
| Deployment | 10 min | Deploy to Cloud Run |
| Testing | 20 min | Run integration tests, verify logging |
| Promotion | 10 min | Move from priority 900 → 1000 |
| **Total** | **~80 min** | Complete gateway to production |

## Support

If issues arise:
1. Check Cloud Logging for X-User-Id presence
2. Verify Load Balancer header stripping
3. Test middleware with print statements
4. Rollback: `gcloud compute security-policies rules delete 900 --security-policy=cwe-chatbot-armor`

## References

- [Cloud IAP Documentation](https://cloud.google.com/iap/docs)
- [Cloud Armor Rate Limiting](https://cloud.google.com/armor/docs/rate-limiting-overview)
- [Chainlit OAuth](https://docs.chainlit.io/authentication/oauth)
- Story S-1.1: [S-1.1AddPer-UserEdgeRateLimitsGCPCloudArmor.md](S-1.1AddPer-UserEdgeRateLimitsGCPCloudArmor.md)

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-10 | 1.0 | Initial gateway configuration guide | Claude Code Agent |
