# Story S-1.1: Add Per-User Edge Rate Limits (X-User-Id) — GCP Cloud Armor

- **Priority:** High (after S-1 stable)
- **Epic:** Security & Compliance → Platform Guardrails & Abuse Prevention
- **Depends on:** S-1 (per-IP limits live), S-9 (gateway/identity in place)
- **Related:** S-2 (LLM I/O Guardrails)

## Goal

Add **per-user** rate limiting at the **edge** using Cloud Armor, keyed by a **trusted** identity header `X-User-Id` that is **injected by the gateway/IAP/JWT middleware** and **stripped from public traffic**. Keep the existing **per-IP** rule as a fallback.

## Acceptance Criteria

1. **Per-user limit at edge**: `60 requests / minute / user` (window=60s) with **ban** of `300s`. Rule priority **1000**.
2. **Header integrity**: External `X-User-Id` is **removed at the load balancer**; only the **trusted gateway** adds it *after* authentication.
3. **Per-IP fallback**: Existing S-1 per-IP rule (priority **1100**) remains active.
4. **429 at edge**: Over-limit requests receive **HTTP 429** from Cloud Armor.
5. **Observability**: Log-based metric still counts **DENY_429**. Metric includes **policy name** label.
6. **Tests**: Black-box tests show 200→429 when repeatedly calling with the same user id; spoofed client attempts **don’t** bypass limits (header stripped).
7. **Runbook updated**: Header integrity, tuning, and triage steps documented.

## Non-Goals

* No change to app logic.
* No identity storage or RBAC work (belongs to S-3/S-5).
* No Terraform (will be handled in the infra story).

---

## Tasks

### T1 — Gateway / Identity Plumbing

* Configure your **trusted front-door** (choose one):

  * **IAP / Identity-aware Proxy** → set `X-User-Id` from a verified claim (`sub`, or hashed email).
  * **API Gateway / Apigee** → map JWT claim to `X-User-Id`.
* Ensure a **stable, opaque** user key (e.g., SHA-256(email) with a project-secret salt).

  * Never use raw emails as the key.

### T2 — Strip Client-Supplied `X-User-Id` at the Edge

* In the **External HTTPS Load Balancer**, configure a **request header action** to **remove** `X-User-Id` on ingress, so clients can't spoof it.

**IMPORTANT**: GCP requires `headerAction` as a wrapper for request header modifications.

Example (URL map header action):

```bash
# Example: update URL map to remove client-supplied X-User-Id
# Note: headerAction wrapper is REQUIRED by GCP
gcloud compute url-maps update ${URL_MAP} \
  --default-route-action='{"headerAction":{"requestHeadersToRemove":["X-User-Id"]}}'
```

> If you use path matchers, apply `--route-action` / `--header-action` at the relevant path matcher or host rule. In Console: Load Balancer → Routing rules → Header actions → *Remove* `X-User-Id`.
>
> **Header Case Note**: Cloud Armor evaluates headers in **lowercase** within CEL expressions. Use `x-user-id` in rule expressions and `--enforce-on-key-name`.

### T3 — Cloud Armor Per-User Rule (keep per-IP rule)

Update the existing script to add a **per-user** rule at **priority 1000**:

```bash
# scripts/setup_rate_limits.sh (add-on)
USER_HEADER="${USER_HEADER:-X-User-Id}"
USER_HEADER_LOWER=$(echo "$USER_HEADER" | tr 'A-Z' 'a-z')  # Cloud Armor uses lowercase
RPM_PER_USER="${RPM_PER_USER:-60}"
INTERVAL_SEC="${INTERVAL_SEC:-60}"
BAN_DURATION_SEC="${BAN_DURATION_SEC:-300}"
BAN_COUNT_MULTIPLIER="${BAN_COUNT_MULTIPLIER:-2}"

# Per-user (x-user-id) rule — priority 1000
# IMPORTANT: Cloud Armor evaluates headers in lowercase within CEL
gcloud compute security-policies rules create 1000 \
  --security-policy="${POLICY}" \
  --action=rate-based-ban \
  --expression="request.headers['${USER_HEADER_LOWER}'] != null" \
  --rate-limit-threshold-count="${RPM_PER_USER}" \
  --rate-limit-threshold-interval-sec="${INTERVAL_SEC}" \
  --conform-action=deny-429 \
  --exceed-action=deny-429 \
  --ban-threshold-count="$((RPM_PER_USER * BAN_COUNT_MULTIPLIER))" \
  --ban-threshold-interval-sec="${INTERVAL_SEC}" \
  --ban-duration-sec="${BAN_DURATION_SEC}" \
  --enforce-on-key=HTTP_HEADER \
  --enforce-on-key-name="${USER_HEADER_LOWER}" || true
```

> Keep the S-1 **per-IP** rule at **1100**, and the **final allow** at **2147483647**.

### T4 — Observability (re-use S-1)

* **Metric**: `rate_limit_blocks` (no change), filter `jsonPayload.enforcedAction="DENY_429"`.
* **Label extractor** (already set): `policy_name = EXTRACT(jsonPayload.enforcedSecurityPolicy.name)`.
* **Validation**: During testing, verify `enforcedOnKey` shows:
  - `HTTP_HEADER` for per-user rule (priority 1000)
  - `IP` for per-IP fallback rule (priority 1100)
* Optional: add a *text* field in your alert doc to remind on header integrity checks.

**WebSocket Note**: Rate limiting applies to the HTTP upgrade request. Per-IP fallback is critical to prevent abusive reconnect loops.

### T5 — Tests

**A) Black-box pytest (per-user path)**

```python
# tests/integration/test_rate_limit_user.py
import os, requests

URL = os.environ["STAGING_URL"]            # public endpoint (cheap GET ok)
USER_ID = os.environ.get("TEST_USER_ID","itest-user-1")
LIMIT = int(os.environ.get("TEST_RATE_LIMIT","10"))

def test_per_user_200_then_429():
    headers = {"X-User-Id": USER_ID}
    for i in range(LIMIT):
        r = requests.get(URL, headers=headers, timeout=10)
        assert r.status_code < 500
    r = requests.get(URL, headers=headers, timeout=10)
    assert r.status_code == 429
```

**B) Spoofing check (header stripped)**

```python
def test_client_cannot_spoof_user_id():
    # Try to set header from a public client; should be stripped by LB,
    # so per-IP rule applies (not per-user). Hard to assert from black box,
    # but we verify we *still* hit 429 due to per-IP fallback.
    headers = {"X-User-Id": "attacker-spoof"}
    r = requests.get(URL, headers=headers, timeout=10)
    assert r.status_code in (200, 429)
    # Manually verify in logs that enforcedOnKey shows IP, not HTTP_HEADER
```

**C) Logs Explorer verification**

* Filter: `resource.type="http_load_balancer" AND jsonPayload.enforcedAction="DENY_429"`.
* Confirm entries show the **security policy** and (where visible) **enforcedOnKey** = `HTTP_HEADER` for the per-user rule, or `IP` for fallback.

### T6 — Runbook Updates

Add a **Per-User Limits** section:

* **Header integrity:** Client `X-User-Id` is removed at LB; only gateway adds it post-auth.
* **What to tune:** `RPM_PER_USER`, `BAN_DURATION_SEC`; keep per-IP as safety net.
* **Triage flow:** If an account is throttled:

  1. Confirm header origin (gateway logs).
  2. Decide whether to temporarily raise `RPM_PER_USER` or grant a gateway-level exception.
  3. Monitor `rate_limit_blocks` and app latency.

### T7 — Rollback

* Remove per-user rule:

```bash
gcloud compute security-policies rules delete 1000 --security-policy="${POLICY}"
```

* Keep per-IP rule @ 1100 and final allow; no outage required.

---

## Config (uniform across envs)

* **Per-user**: 60 rpm (60s window), ban 300s.
* **Per-IP**: unchanged (S-1 baseline: 60 rpm / 60s / 300s).
* **Ordering**: 1000 (per-user) → 1100 (per-IP) → 2147483647 (allow).

> Scripts may accept env vars for emergencies, but **baseline values are the same** in dev/stage/prod.

---

## Risks & Mitigations

* **Header spoofing** → Mitigated by **LB header removal** + **trusted gateway insertion**.
* **Key instability** (users changing emails) → Use `sub` or a salted hash of a stable identifier.
* **Visibility** (who tripped the limit) → Use gateway logs for identity; Cloud Armor logs won’t expose PII.

---

## Deliverables

* Updated scripts:

  * `scripts/setup_rate_limits.sh` (adds per-user rule @ 1000)
* New tests:

  * `tests/integration/test_rate_limit_user.py`
* Runbook update:

  * “Per-User Limits” section with header-integrity steps and triage
* Short change note in S-1 doc pointing to S-1.1
