# Story S-1.1: HTTPS Load Balancer + Cloud Armor Per-IP Rate Limiting

- **Priority:** Medium (deferred from S-1)
- **Epic:** Security & Compliance → Platform Guardrails & Abuse Prevention
- **Status:** Backlog (prerequisite: S-1 complete)
- **Related:** S-1 (Cloud Run Rate Limiting), S-2 (LLM I/O Guardrails), S-9 (Cloud Production Security)

> **Why This Story Exists:**
> S-1 uses Cloud Run built-in rate limiting (service-level) because the app is directly exposed via `.run.app` URL.
> This story adds HTTPS Load Balancer + Cloud Armor to enable **per-IP rate limiting** with ban duration.
>
> **When to Implement:**
> - Need per-IP rate limiting (not just service-level)
> - Want DDoS protection via Cloud Armor
> - Planning custom domain (e.g., `chatbot.example.com`)
> - Need WAF capabilities (SQL injection, XSS filters)

## Story

**As a** System Administrator,
**I want** per-IP rate limiting enforced at the **edge** via Cloud Armor,
**so that** individual malicious actors can be blocked while legitimate traffic continues.

## Acceptance Criteria

1. **HTTPS Load Balancer:**
   * Serverless NEG (Network Endpoint Group) pointing to Cloud Run service
   * Global HTTPS Load Balancer with SSL certificate (Google-managed or custom)
   * Health checks configured for Cloud Run backend
   * Backend service created with appropriate settings

2. **Cloud Armor per-IP rate limiting:**
   * Limit: **60 requests/minute per IP**
   * Window: **60s**; **ban duration: 300s**
   * Rule order: per-IP rate-based-ban rule at priority **1100**, explicit final allow at **2147483647**
   * Over-limit requests receive **HTTP 429** at the edge

3. **Observability:**
   * Log-based metric `rate_limit_blocks` counts `DENY_429` decisions
   * Alert policy emails SecOps on any blocks within 5 minutes
   * Cloud Armor logs available in Logs Explorer

4. **Zero-downtime migration:**
   * Load Balancer deployed without disrupting existing `.run.app` traffic
   * DNS cutover planned (if using custom domain)
   * Rollback plan documented

5. **Cost optimization:**
   * Load Balancer costs documented (~$18/month + egress)
   * Budget alerts updated to account for LB costs
   * Cloud Run max-instances kept as secondary protection

6. **Security hardening:**
   * Cloud Run service configured to accept traffic only from Load Balancer (ingress: internal-and-cloud-load-balancing)
   * Direct `.run.app` access blocked to prevent bypass

## Tasks

* **T1: Create Serverless NEG**
  * Create serverless NEG pointing to Cloud Run service in `us-central1`
  * Verify NEG health and backend connectivity

* **T2: Create HTTPS Load Balancer**
  * Create backend service with serverless NEG
  * Configure global HTTPS Load Balancer
  * Set up SSL certificate (Google-managed for `.run.app` or custom for domain)
  * Configure URL maps and routing

* **T3: Attach Cloud Armor policy**
  * Run `scripts/setup_rate_limits.sh` (from archived scripts)
  * Verify per-IP rate limiting (60 rpm, 300s ban)
  * Test with `scripts/hit_until_429.sh`

* **T4: Configure observability**
  * Run `scripts/setup_rate_limit_observability.sh`
  * Create log-based metric for `DENY_429` decisions
  * Set up alert policy for rate limit blocks

* **T5: Restrict Cloud Run ingress**
  * Update Cloud Run service: `--ingress=internal-and-cloud-load-balancing`
  * Verify direct `.run.app` access blocked (should return 403)
  * Test Load Balancer access works

* **T6: Documentation & runbook**
  * Update S-1 runbook with Load Balancer details
  * Document DNS configuration (if custom domain)
  * Create rollback procedures
  * Update cost estimates in budget alerts

## Definition of Done

* HTTPS Load Balancer deployed and routing traffic to Cloud Run service
* Cloud Armor policy attached with per-IP rate limiting (60 rpm, 300s ban)
* Rate limiting verified: `hit_until_429.sh` shows 200s then 429s at request #61
* Observability operational: `rate_limit_blocks` metric and alert policy active
* Cloud Run ingress restricted to Load Balancer only (direct `.run.app` blocked)
* Documentation updated with Load Balancer architecture and costs
* Rollback plan tested and documented

## Implementation Scripts

All scripts created in S-1 are ready to use (currently in `scripts/`):

### 1. Load Balancer Setup (NEW)
```bash
# Create serverless NEG
gcloud compute network-endpoint-groups create cwe-chatbot-neg \
  --region=us-central1 \
  --network-endpoint-type=serverless \
  --cloud-run-service=cwe-chatbot

# Create backend service
gcloud compute backend-services create cwe-chatbot-backend \
  --global \
  --load-balancing-scheme=EXTERNAL_MANAGED \
  --enable-cdn

# Add NEG to backend
gcloud compute backend-services add-backend cwe-chatbot-backend \
  --global \
  --network-endpoint-group=cwe-chatbot-neg \
  --network-endpoint-group-region=us-central1

# Create URL map
gcloud compute url-maps create cwe-chatbot-lb \
  --default-service=cwe-chatbot-backend

# Create target HTTPS proxy (requires SSL cert)
gcloud compute ssl-certificates create cwe-chatbot-cert \
  --domains=cwe-chatbot-258315443546.us-central1.run.app

gcloud compute target-https-proxies create cwe-chatbot-https-proxy \
  --url-map=cwe-chatbot-lb \
  --ssl-certificates=cwe-chatbot-cert

# Create forwarding rule (reserves IP)
gcloud compute forwarding-rules create cwe-chatbot-https \
  --global \
  --target-https-proxy=cwe-chatbot-https-proxy \
  --ports=443

# Get Load Balancer IP
gcloud compute forwarding-rules describe cwe-chatbot-https \
  --global \
  --format="value(IPAddress)"
```

### 2. Cloud Armor Setup (EXISTING)
```bash
# Use S-1 archived scripts
./scripts/setup_rate_limits.sh
```

### 3. Observability Setup (EXISTING)
```bash
# Use S-1 archived scripts
PROJECT_ID=cwechatbot \
ALERT_EMAIL=secops@example.com \
./scripts/setup_rate_limit_observability.sh
```

### 4. Restrict Cloud Run Ingress
```bash
# Block direct .run.app access
gcloud run services update cwe-chatbot \
  --region=us-central1 \
  --ingress=internal-and-cloud-load-balancing

# Verify restriction
curl https://cwe-chatbot-258315443546.us-central1.run.app/
# Expected: 403 Forbidden

# Test Load Balancer access
LB_IP=$(gcloud compute forwarding-rules describe cwe-chatbot-https --global --format="value(IPAddress)")
curl https://${LB_IP}/ -H "Host: cwe-chatbot-258315443546.us-central1.run.app"
# Expected: 200 OK
```

## Testing

* **Load Balancer connectivity:** Verify traffic routes through LB to Cloud Run
* **Cloud Armor rate limiting:** Run `scripts/hit_until_429.sh` against LB IP, verify 429 after 60 requests
* **Per-IP enforcement:** Test from multiple IPs, verify limits enforced per-IP not globally
* **Ingress restriction:** Verify direct `.run.app` access blocked (403)
* **Observability:** Confirm `DENY_429` logs appear, metric increments, alert fires
* **Rollback:** Test removing Cloud Armor policy, Load Balancer (service still works via `.run.app`)

## Cost Analysis

### Additional Monthly Costs (Estimated)

| Component | Cost |
|-----------|------|
| HTTPS Load Balancer | ~$18/month (forwarding rules + capacity) |
| Cloud Armor | Free tier covers most use cases |
| Egress traffic | $0.08-0.23/GB (same as Cloud Run direct egress) |
| SSL certificate | Free (Google-managed) |
| **Total** | ~$18-30/month additional |

**Note:** Egress is billed the same whether through Load Balancer or Cloud Run direct. LB adds ~$18 fixed cost.

### Budget Updates
Update S-1 budgets to account for Load Balancer:
- Daily: $50 → $52
- Monthly: $1000 → $1030

## Migration Strategy

### Phase 1: Deploy Load Balancer (No Traffic Impact)
1. Create Load Balancer infrastructure
2. Attach Cloud Armor policy
3. Test Load Balancer endpoint separately
4. Keep `.run.app` active (no traffic disruption)

### Phase 2: Traffic Cutover (Optional - for Custom Domain)
1. Update DNS to point to Load Balancer IP
2. Monitor traffic shift
3. Verify Cloud Armor rate limiting active

### Phase 3: Restrict Direct Access
1. Update Cloud Run ingress to `internal-and-cloud-load-balancing`
2. Verify direct `.run.app` blocked
3. Confirm all traffic via Load Balancer

### Rollback Plan
If issues detected:
1. Revert Cloud Run ingress: `--ingress=all`
2. Update DNS back to `.run.app` (if changed)
3. Remove Load Balancer (optional - can leave for future use)

## Security Benefits

Adding Load Balancer + Cloud Armor provides:

1. **Per-IP rate limiting:** Block abusive IPs without affecting others
2. **DDoS protection:** Cloud Armor absorbs volumetric attacks at edge
3. **WAF capabilities:** Add SQL injection, XSS filters (future stories)
4. **Bot protection:** Integrate reCAPTCHA Enterprise (future)
5. **Geographic restrictions:** Block/allow specific countries (future)
6. **Defense in depth:** Load Balancer + Cloud Run max-instances dual protection

## Related Documentation

- **S-1 Story:** [S-1.Rate-Limiting-and-Budget-Monitoring.md](S-1.Rate-Limiting-and-Budget-Monitoring.md)
- **Archived Scripts:** `docs/future/s-1.1-load-balancer/` (scripts from S-1)
- **Cloud Armor Docs:** https://cloud.google.com/armor/docs/configure-security-policies
- **Serverless NEG Guide:** https://cloud.google.com/load-balancing/docs/negs/serverless-neg-concepts

## Change Log

| Date       | Version | Description                                                     |
| ---------- | ------- | --------------------------------------------------------------- |
| 2025-10-07 | 1.0     | Initial story - deferred Load Balancer + Cloud Armor from S-1. |
