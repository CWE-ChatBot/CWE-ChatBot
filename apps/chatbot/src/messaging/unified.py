#!/usr/bin/env python3
"""
Unified Message Path - R16 Implementation

A single entry point for all user messages across transports (REST, WebSocket, CLI).
Centralizes: normalization, basic safety, routing to LLM/tools, conversation persistence,
and structured logging.

Key benefits:
- Consistent preprocessing and safety checks across all entry points
- Single point for cross-cutting concerns (logging, safety, analytics)
- Easy to add new transports without duplicating logic
- Unified audit trail with correlation IDs
"""

from __future__ import annotations

from dataclasses import dataclass
from datetime import datetime, timezone
from typing import Any, Dict, Optional

from src.app_config import config as app_config
from src.conversation import ConversationManager
from src.observability import set_correlation_id
from src.security.secure_logging import get_secure_logger

logger = get_secure_logger(__name__)


@dataclass
class MessageIn:
    """
    Transport-agnostic input message representation.

    Attributes:
        user_id: User identifier (from OAuth, API key, or anonymous)
        user_email: User email address (if authenticated)
        session_id: Session identifier for conversation tracking
        persona: User persona for response tailoring (Developer, PSIRT Member, etc.)
        text: User message content (query, command, etc.)
        correlation_id: Request correlation ID for distributed tracing
        transport: Message transport type ("rest" | "ws" | "cli")
        metadata: Optional transport-specific metadata (UI version, source, etc.)
    """

    user_id: str
    user_email: Optional[str]
    session_id: str
    persona: Optional[str]
    text: str
    correlation_id: str
    transport: str  # "rest" | "ws" | "cli" | ...
    metadata: Optional[Dict[str, Any]] = None


@dataclass
class MessageOut:
    """
    Standardized output message representation.

    Attributes:
        text: Response text generated by the system
        session_id: Session identifier (echoed from input)
        persona: User persona (echoed from input)
        tokens_in: Input token count (for cost tracking)
        tokens_out: Output token count (for cost tracking)
        latency_ms: Total processing latency in milliseconds
        correlation_id: Request correlation ID (echoed from input)
        safety_blocked: Whether message was blocked by safety checks
        citations: Optional CWE citations and sources
    """

    text: str
    session_id: str
    persona: Optional[str]
    tokens_in: int
    tokens_out: int
    latency_ms: int
    correlation_id: str
    safety_blocked: bool = False
    citations: Optional[Dict[str, Any]] = None


class UnifiedMessagePath:
    """
    Single entry point for all user messages.

    Centralizes:
    - Input normalization and validation
    - Length guarding and safety checks
    - Routing to ConversationManager
    - Structured logging with correlation IDs
    - Token and latency tracking

    Usage:
        cm = ConversationManager(...)
        unified = UnifiedMessagePath(cm)

        # REST handler
        msg_in = MessageIn(user_id="api", session_id="...", text="query", ...)
        result = await unified.process(msg_in)

        # WebSocket handler
        msg_in = MessageIn(user_id="ws_user", session_id="...", text="query", ...)
        result = await unified.process(msg_in)
    """

    def __init__(self, cm: ConversationManager) -> None:
        """
        Initialize unified message path.

        Args:
            cm: ConversationManager instance for message processing
        """
        self.cm = cm

    async def process(self, msg: MessageIn) -> MessageOut:
        """
        Process a user message through the unified pipeline.

        Steps:
        1. Normalize and validate input (trim whitespace, check length)
        2. Set correlation ID for distributed tracing
        3. Apply safety checks (length limits, basic validation)
        4. Route to ConversationManager for processing
        5. Track latency and token usage
        6. Return standardized MessageOut

        Args:
            msg: Input message from any transport

        Returns:
            MessageOut with response, tokens, latency, and metadata

        Raises:
            Exception: Propagates exceptions from ConversationManager (logged first)
        """
        started = datetime.now(timezone.utc)
        set_correlation_id(msg.correlation_id)

        # 1) Normalize input
        text = (msg.text or "").strip()
        if not text:
            logger.info(
                "Empty message dropped",
                extra={
                    "correlation_id": msg.correlation_id,
                    "session_id": msg.session_id,
                },
            )
            return MessageOut(
                text="",
                session_id=msg.session_id,
                persona=msg.persona,
                tokens_in=0,
                tokens_out=0,
                latency_ms=0,
                correlation_id=msg.correlation_id,
            )

        # 2) Lightweight safety / length guarding (non-blocking)
        max_len = getattr(app_config, "max_user_chars", 8000)
        if len(text) > max_len:
            logger.warning(
                f"Message truncated from {len(text)} to {max_len} chars",
                extra={
                    "correlation_id": msg.correlation_id,
                    "original_length": len(text),
                    "max_length": max_len,
                },
            )
            text = text[:max_len]

        # 3) Structured log (no PII beyond authenticated email)
        logger.info(
            "Unified message received",
            extra={
                "correlation_id": msg.correlation_id,
                "transport": msg.transport,
                "session_id": msg.session_id,
                "persona": msg.persona,
                "user_id": msg.user_id,
                "user_email": msg.user_email or "unknown",
                "message_length": len(text),
            },
        )

        # 4) Route to ConversationManager (single source of truth)
        try:
            resp = await self.cm.process_user_message(
                session_id=msg.session_id,
                message_content=text,
            )
            # Expected response shape from ConversationManager:
            # {
            #   "response": str,           # Response text
            #   "tokens_in": int,          # Input token count (optional)
            #   "tokens_out": int,         # Output token count (optional)
            #   "citations": dict,         # CWE citations (optional)
            #   "retrieved_cwes": list,    # Retrieved CWE IDs (optional)
            #   "chunk_count": int,        # Chunk count (optional)
            #   ...
            # }
        except Exception as e:
            logger.log_exception(
                "ConversationManager error",
                e,
                extra_context={
                    "correlation_id": msg.correlation_id,
                    "session_id": msg.session_id,
                },
            )
            # Fail gracefully - let caller handle exception
            raise

        ended = datetime.now(timezone.utc)
        latency_ms = int((ended - started).total_seconds() * 1000)

        # 5) Build standardized output
        out = MessageOut(
            text=resp.get("response", ""),
            session_id=msg.session_id,
            persona=msg.persona,
            tokens_in=int(resp.get("tokens_in", 0)),
            tokens_out=int(resp.get("tokens_out", 0)),
            latency_ms=latency_ms,
            correlation_id=msg.correlation_id,
            citations=resp.get("citations"),
        )

        # 6) Log completion with metrics
        logger.info(
            "Unified message completed",
            extra={
                "correlation_id": msg.correlation_id,
                "session_id": msg.session_id,
                "latency_ms": latency_ms,
                "tokens_in": out.tokens_in,
                "tokens_out": out.tokens_out,
                "response_length": len(out.text),
            },
        )
        return out
