name: quality

on: [push, pull_request]

# Needed to upload SARIF to the Code scanning / Code quality tab
permissions:
  contents: read
  security-events: write

jobs:
  lint-type-test-cover: # Renamed and consolidated
    runs-on: ubuntu-latest
    strategy:
      matrix:
        python: ['3.12']
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v6
        with:
          python-version: ${{ matrix.python }}

      - name: Install Poetry
        run: curl -sSL https://install.python-poetry.org | python3 -

      - name: Ensure Poetry on PATH
        run: echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Cache Poetry
        uses: actions/cache@v5
        with:
          path: ~/.cache/pypoetry
          key: poetry-${{ hashFiles('**/poetry.lock') }}

      - name: Install deps
        run: poetry install --no-interaction --no-root

      # --- LINTING (Fast checks) ---
      - name: Run Ruff (Lint)
        run: poetry run ruff check .

      - name: Run Ruff (Format Check)
        run: poetry run ruff format --check .

      # --- TYPE CHECKING ---
      - name: Install pyright
        run: python -m pip install --upgrade pip pipx && pipx install pyright

      - name: Run pyright
        run: poetry run pyright

      # --- TESTING ---
      - name: Tests + coverage
        run: poetry run pytest --cov --cov-report=xml

      - name: Coverage gate
        uses: orgoro/coverage@v3
        with:
          coverageFile: ./coverage.xml
          failCiIfError: true
          minCoverage: 85 # Your 85% coverage gate

  pyright:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v6
        with:
          python-version: '3.12'

      - name: Install Poetry
        run: curl -sSL https://install.python-poetry.org | python3 -

      - name: Ensure Poetry on PATH
        run: echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Cache Poetry dependencies
        uses: actions/cache@v5
        with:
          path: ~/.cache/pypoetry
          key: poetry-${{ hashFiles('**/poetry.lock') }}

      - name: Install dependencies
        run: poetry install --no-interaction --no-root

      - name: Install pyright
        run: python -m pip install --upgrade pip pipx && pipx install pyright

      - name: Run pyright
        run: poetry run pyright

  # === Semgrep -> SARIF -> Code scanning ===
  semgrep:
    runs-on: ubuntu-latest
    container:
      image: semgrep/semgrep:latest
    steps:
      - uses: actions/checkout@v4
      - name: Run Semgrep (generate SARIF, keep going)
        id: semgrep
        continue-on-error: true  # ensure upload happens even with findings
        run: |
          semgrep scan --config=p/python --config=p/security-audit \
            --exclude='**/tests/**' \
            --exclude='**/scripts/**' \
            --exclude='**/*_test.py' \
            --exclude='**/test_*.py' \
            --sarif --output=semgrep-results.sarif \
            --verbose

      - name: Upload Semgrep SARIF to Code Scanning
        if: always()  # Upload even if semgrep step fails
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: semgrep-results.sarif
      # Optionally fail the job if Semgrep found results (kept soft by default)
      # - run: exit ${{ steps.semgrep.outputs.exit_code || 0 }}

  # === pip-audit -> SARIF -> Code scanning ===
  pip-audit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v6
        with:
          python-version: '3.12'

      - name: Install Poetry
        run: curl -sSL https://install.python-poetry.org | python3 -

      - name: Ensure Poetry on PATH
        run: echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Install Poetry export plugin
        run: poetry self add poetry-plugin-export

      - name: Export deps from Poetry
        run: poetry export -f requirements.txt --without-hashes -o requirements.txt

      - name: Install pip-audit
        run: python -m pip install --upgrade pip pip-audit

      - name: Run pip-audit (produce SARIF, capture exit code)
        id: pipaudit
        run: |
          set +e
          pip-audit -r requirements.txt --format sarif --output pip-audit.sarif --progress-spinner off
          echo "exit_code=$?" >> $GITHUB_OUTPUT
          # Always succeed so we can upload SARIF
          exit 0

      - name: Upload pip-audit SARIF to Code Scanning
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: pip-audit.sarif

      # Re-fail the job if vulnerabilities were found
      - name: Fail if pip-audit had findings
        if: ${{ steps.pipaudit.outputs.exit_code != '0' }}
        run: |
          echo "pip-audit found vulnerabilities."
          exit 1

  # === Bandit (security lint) ===
  bandit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v6
        with:
          python-version: '3.12'
      - name: Install Bandit
        run: python -m pip install --upgrade pip bandit
      - name: Run Bandit (JSON report)
        id: bandit
        continue-on-error: true
        run: >
          bandit -r ./apps
          -x ./apps/chatbot/tests,./apps/cwe_ingestion/tests,./apps/pdf_worker/tests,./apps/tests,./apps/cwe_ingestion/build/lib/tests,./apps/cwe_ingestion/scripts,./apps/pdf_worker/test_*.py
          -f json -o bandit_report_no_tests.json -ll --skip B608

      - name: Upload Bandit report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: bandit_report_no_tests.json
          path: bandit_report_no_tests.json

      - name: Display Bandit findings and fail if issues found
        if: always()
        run: |
          python - <<'PY'
          import json, sys
          with open("bandit_report_no_tests.json") as f:
              data = json.load(f)
          issues = data.get("results", [])
          if issues:
              print(f"\nðŸ”´ Bandit found {len(issues)} security issue(s):\n")
              for i, issue in enumerate(issues, 1):
                  print(f"{i}. [{issue['test_id']}] {issue['issue_severity']} severity")
                  print(f"   File: {issue['filename']}:{issue['line_number']}")
                  print(f"   Issue: {issue['issue_text']}")
                  print(f"   More info: {issue.get('more_info', 'N/A')}\n")
              print("Fix these security issues before merging.")
              sys.exit(1)
          print("âœ… Bandit found no security issues.")
          PY

  # === Vulture (dead code finder) ===
  vulture:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v6
        with:
          python-version: '3.12'
      - name: Install Vulture
        run: python -m pip install --upgrade pip vulture
      - name: Run Vulture
        run: |
          set +e
          vulture --sort-by-size --min-confidence 70 ./ > vulture.txt
          exit 0
      - name: Upload Vulture output
        uses: actions/upload-artifact@v4
        with:
          name: vulture.txt
          path: vulture.txt
      # Report findings but don't fail the build (informational only)
      - name: Report Vulture findings
        run: |
          if grep -E ":[0-9]+:" -q vulture.txt; then
            echo "::warning::Vulture found potential dead code. Review vulture.txt artifact for cleanup opportunities."
            echo "Dead code findings are informational and don't block the build."
          else
            echo "Vulture found no reportable dead code."
          fi

  # === Checkov (SARIF -> Code Scanning) ===
  checkov:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install Checkov
        run: python -m pip install --upgrade pip checkov

      - name: Run Checkov (SARIF only, skip tests)
        id: checkov
        continue-on-error: true  # ensure upload happens even with findings
        run: |
          checkov -d . \
            --framework dockerfile,github_actions,kubernetes,helm \
            --skip-path ".git,.venv,venv,node_modules,**/tests/**" \
            -o sarif --output-file-path . || true
          # Checkov creates a nested directory, flatten it
          if [ -f results_sarif.sarif ]; then
            mv results_sarif.sarif checkov-results.sarif
          fi

      - name: Upload Checkov SARIF to Code Scanning
        if: always()  # Upload even if checkov step fails
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: checkov-results.sarif

  # === Trivy (scan ALL base images from ALL Dockerfiles) ===
  collect-base-images:
    runs-on: ubuntu-latest
    outputs:
      images_json: ${{ steps.collect.outputs.images_json }}
    steps:
      - uses: actions/checkout@v4

      - name: Find Dockerfiles and collect FROM images
        id: collect
        shell: bash
        run: |
          set -euo pipefail
          # Find common Dockerfile/Containerfile names repo-wide
          mapfile -t FILES < <(find . -type f \( -iname 'Dockerfile' -o -name '*Dockerfile' -o -name 'Containerfile' -o -name '*Containerfile' \))

          # Extract image refs from FROM lines (handles multi-stage).
          # Skip ARG-substituted bases (contain '$').
          IMAGES=()
          for f in "${FILES[@]}"; do
            while IFS= read -r img; do
              [[ -z "$img" ]] && continue
              [[ "$img" == *'$'* ]] && continue
              IMAGES+=("$img")
            done < <(grep -hPo '^[[:space:]]*FROM[[:space:]]+\K(\S+)' "$f" | sed 's/[[:space:]]\+AS[[:space:]].*$//' )
          done

          # De-duplicate and emit JSON array for a matrix
          if ((${#IMAGES[@]}==0)); then
            echo "No base images found in Dockerfiles."
            echo 'images_json=[]' >> "$GITHUB_OUTPUT"
            exit 0
          fi
          mapfile -t UNIQUE < <(printf "%s\n" "${IMAGES[@]}" | sort -u)
          printf 'Found %s unique base image(s):\n' "${#UNIQUE[@]}"
          printf ' - %s\n' "${UNIQUE[@]}"

          # Build JSON array
          jq -n --argjson arr "$(printf '%s\n' "${UNIQUE[@]}" | jq -R . | jq -s .)" '$arr' > images.json
          echo "images_json=$(cat images.json)" >> "$GITHUB_OUTPUT"

  trivy-container:
    needs: collect-base-images
    if: ${{ fromJSON(needs.collect-base-images.outputs.images_json) != null && join(fromJSON(needs.collect-base-images.outputs.images_json)) != '' }}
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        image: ${{ fromJSON(needs.collect-base-images.outputs.images_json) }}
    steps:
      - uses: actions/checkout@v4

      # Trivy action does DB caching and supports SARIF nicely
      - name: Scan ${{ matrix.image }} with Trivy (SARIF)
        id: trivy
        uses: aquasecurity/trivy-action@0.33.1
        with:
          scan-type: image
          image-ref: ${{ matrix.image }}
          format: sarif
          output: trivy.sarif
          vuln-type: os,library
          severity: HIGH,CRITICAL
          ignore-unfixed: true
          exit-code: '1'  # fail this matrix leg on findings
          cache: true

      # Always upload the SARIF, even if Trivy failed the step
      - name: Upload Trivy SARIF (${{ matrix.image }})
        if: always()
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: trivy.sarif
          # Unique category per image to avoid collisions when multiple SARIFs exist
          category: trivy:${{ matrix.image }}

  actionlint:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v4
      - name: Run actionlint
        uses: raven-actions/actionlint@v1
        with:
          fail-on-error: true