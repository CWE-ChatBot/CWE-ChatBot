{
  "agent": {
    "attribution": "# Attribution and Acknowledgments\n\n## Project Information\n- **Project**: GenAI Security Agents - Policy-as-Code Engine\n- **Repository**: genai-sec-agents\n- **License**: [To be determined]\n\n## Rule Card Sources\nRule Cards in this repository are based on:\n- Industry security standards and best practices\n- OWASP guidelines and recommendations  \n- CIS Benchmarks and controls\n- NIST Cybersecurity Framework\n- ASVS (Application Security Verification Standard)\n\n## Third-Party Components\n- **PyYAML**: YAML processing library\n- **jsonschema**: JSON Schema validation\n- **pytest**: Testing framework\n\n## OWASP CheatSheet Series\n- **Source**: https://github.com/OWASP/CheatSheetSeries\n- **License**: CC BY-SA 4.0\n- **Usage**: Semantic search corpus for security guidance\n- **Attribution**: \u00a9 OWASP Foundation, licensed under Creative Commons Attribution-ShareAlike 4.0 International License\n- **Local Path**: `vendor/owasp-cheatsheets/`\n- **Purpose**: Used to create normalized search corpus in `research/search_corpus/owasp/` for local semantic search capabilities\n\n## Contributors\n- Lead AppSec Engineer: [Name]\n- Development Team: [Names]\n\n## Standards References\nThis project implements security controls based on recognized industry standards. All Rule Cards include proper attribution to source standards in the `refs` section.",
    "build_date": "2025-09-04T18:06:35Z",
    "compiler_version": "1.0.0",
    "description": "Multi-domain security agent with access to all Rule Cards for complex cross-domain analysis",
    "domains": [
      "Cross-domain security analysis",
      "Comprehensive security guidance"
    ],
    "name": "comprehensive-security-agent",
    "source_digest": "sha256:1d670f362a6a6b58b8ed484dde6669f82f10a8d3f0d2aedd082f138b0d22322c",
    "version": "4ea80e36-1757009195"
  },
  "rules": [
    {
      "detect": {
        "semgrep": [
          "oob-authentication-protection"
        ]
      },
      "do": [
        "Implement rate limiting for out-of-band code attempts",
        "Protect against timing attacks in code verification",
        "Prevent replay of used authentication codes"
      ],
      "dont": [
        "Allow unlimited code verification attempts",
        "Use predictable timing for code validation",
        "Accept previously used codes"
      ],
      "id": "AUTH-PROTECT-OOB-CODE-AUTH-001",
      "refs": {
        "asvs": [
          "V6.5.1"
        ],
        "cwe": [
          "CWE-307"
        ],
        "owasp": [
          "A07:2021"
        ]
      },
      "requirement": "Code-based out-of-band authentication must be protected against brute force attacks, replay attacks, and timing attacks.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Protect Code-based Out-of-Band Authentication",
      "verify": {
        "tests": [
          "Test rate limiting on code verification attempts",
          "Verify protection against timing attacks"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "password-field-type"
        ]
      },
      "do": [
        "Use type=password for password input fields"
      ],
      "dont": [
        "Use plain text input fields for passwords"
      ],
      "id": "AUTH-CONFIGURE-PASSWORD-INPUT-001",
      "refs": {
        "asvs": [
          "V6.2.6"
        ],
        "cwe": [
          "CWE-312"
        ],
        "owasp": [
          "A2:2021"
        ]
      },
      "requirement": "Password input fields must use type=password to mask the entry. Applications may allow the user to temporarily view the entire masked password, or the last typed character of the password.",
      "scope": "web-application",
      "severity": "low",
      "title": "Password input fields must use type=password",
      "verify": {
        "tests": [
          "Manually verify that password input fields are masked"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-secure-false"
        ]
      },
      "do": [
        "Generate authentication seeds using Cryptographically Secure Pseudorandom Number Generators"
      ],
      "dont": [
        "Use insecure random number generators for authentication seeds"
      ],
      "id": "AUTH-CSP-AUTH-SECRET-002",
      "refs": {
        "asvs": [
          "V6.5.3"
        ],
        "cwe": [
          "CWE-287"
        ],
        "owasp": [
          "A07:2021"
        ]
      },
      "requirement": "Lookup secrets, out-of-band authentication code, and time-based one-time password seeds, are generated using a Cryptographically Secure Pseudorandom Number Generator (CSPRNG) to avoid predictable values.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Use Cryptographically Secure Pseudorandom Number Generators for Authentication Seeds",
      "verify": {
        "tests": [
          "Testing methods to ensure secure generation of authentication seeds"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "identity-proofing-recovery"
        ]
      },
      "do": [
        "Validate identity proofing evidence at same level as initial enrollment",
        "Require identity verification for authentication factor recovery"
      ],
      "dont": [
        "Allow factor recovery without proper identity verification",
        "Use weaker identity proofing than initial enrollment"
      ],
      "id": "AUTH-VALIDATE-IDENTITY-PROOFING-001",
      "refs": {
        "asvs": [
          "V6.1.1"
        ],
        "cwe": [
          "CWE-287"
        ],
        "owasp": [
          "A07:2021"
        ]
      },
      "requirement": "Perform evidence of identity proofing at the same level as during enrollment when recovering lost authentication factors.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Evidence of Identity Proofing for Lost Authentication Factor",
      "verify": {
        "tests": [
          "Verify identity proofing level matches enrollment requirements"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-secure-false"
        ]
      },
      "do": [
        "Generate initial passwords/activation codes securely and randomly",
        "Follow password policy requirements for generation",
        "Verify authentication strength information from the IdP if applicable"
      ],
      "dont": [
        "Do not use predictable or weak initial passwords/activation codes"
      ],
      "id": "AUTH-GEN-008",
      "refs": {
        "asvs": [
          "V6.8.4"
        ],
        "cwe": [
          "CWE-287"
        ],
        "owasp": [
          "A07:2021"
        ]
      },
      "requirement": "System generated initial passwords or activation codes must be securely randomly generated, follow password policy requirements, and verify authentication strength information from the IdP if applicable.",
      "scope": "web-application",
      "severity": "high",
      "title": "Secure Initial Passwords/Activation Codes",
      "verify": {
        "tests": [
          "Test generation and verification of initial passwords/activation codes"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-secure-false"
        ]
      },
      "do": [
        "Offer PSTN-based OTPs only after validating the phone number",
        "Provide information on security risks to users when offering PSTN-based OTPs",
        "Bind out-of-band authentication requests, codes, or tokens to the original authentication request",
        "Protect code-based out-of-band authentication mechanisms against brute force attacks with rate limiting",
        "Use codes with at least 64 bits of entropy for out-of-band authentication"
      ],
      "dont": [
        "Offer phone and SMS as options for Level 3 applications"
      ],
      "id": "AUTHENTICATION-NEW-003",
      "refs": {
        "asvs": [
          "V6.6.1",
          "V6.6.2",
          "V6.6.3"
        ],
        "cwe": [
          "CWE-287"
        ],
        "owasp": [
          "A07:2021"
        ]
      },
      "requirement": "Authentication mechanisms using the Public Switched Telephone Network (PSTN) to deliver One-time Passwords...",
      "scope": "web-application",
      "severity": "medium",
      "title": "Out-of-Band Authentication Mechanisms",
      "verify": {
        "tests": [
          "Verify authentication mechanisms and credential handling"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-secure-false"
        ]
      },
      "do": [
        "Ensure SAML assertions are processed uniquely and not reused"
      ],
      "dont": [
        "Do not reuse SAML assertions within their validity period"
      ],
      "id": "AUTH-PREVENT-SAML-001",
      "refs": {
        "asvs": [
          "V6.8.3"
        ],
        "cwe": [
          "CWE-352"
        ],
        "owasp": [
          "A2:2021"
        ]
      },
      "requirement": "SAML assertions are uniquely processed and used only once within the validity period to prevent replay attacks.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Unique Processing of SAML Assertions",
      "verify": {
        "tests": [
          "Test uniqueness and non-replay of SAML assertions"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-secure-false"
        ]
      },
      "do": [
        "Generate challenge nonces that are at least 64 bits long and unique"
      ],
      "dont": [
        "Do not reuse challenge nonces or use non-unique values"
      ],
      "id": "AUTH-AUTH-LIFETIME-001",
      "refs": {
        "asvs": [
          "V6.7.2"
        ],
        "cwe": [
          "CWE-330"
        ],
        "owasp": [
          "A3:2021"
        ]
      },
      "requirement": "The challenge nonce is at least 64 bits in length, and statistically unique or unique over the lifetime of the cryptographic device.",
      "scope": "web-application",
      "severity": "high",
      "title": "Strong Challenge Nonce for Cryptographic Authentication",
      "verify": {
        "tests": [
          "Test generation and uniqueness of challenge nonces"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "multi-factor-authentication"
        ]
      },
      "do": [
        "Implement multi-factor authentication",
        "Use hardware-based authentication as one factor for L3"
      ],
      "dont": [
        "Rely solely on single-factor authentication"
      ],
      "id": "AUTH-IMPLEMENT-MULTIFACTOR-AUTH-001",
      "refs": {
        "asvs": [
          "V6.3.3"
        ],
        "cwe": [
          "CWE-308"
        ],
        "owasp": [
          "A3:2021"
        ]
      },
      "requirement": "Either a multi-factor authentication mechanism or a combination of single-factor authentication mechanisms must be used to access the application. For L3, one factor must be hardware-based.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Multi-Factor Authentication Usage",
      "verify": {
        "tests": [
          "Test multi-factor authentication implementation"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-secure-false"
        ]
      },
      "do": [
        "Allow passwords with a minimum length of 64 characters",
        "Ensure challenge nonces are at least 64 bits in length and unique"
      ],
      "dont": [
        "Enforce passwords shorter than 64 characters"
      ],
      "id": "AUTH-ALLOW-PASSWORD-004",
      "refs": {
        "asvs": [
          "V6.7.2"
        ],
        "cwe": [
          "CWE-287"
        ],
        "owasp": [
          "A07:2021"
        ]
      },
      "requirement": "Passwords of at least 64 characters are permitted and challenge nonces are at least 64 bits in length.",
      "scope": "web-application",
      "severity": "high",
      "title": "Allow passwords of at least 64 characters",
      "verify": {
        "tests": [
          "Test password length enforcement and nonce generation"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-secure-false"
        ]
      },
      "do": [
        "Use type=password for password input fields",
        "Allow temporary viewing of the entire masked password or the last typed character"
      ],
      "dont": [
        "Use plain text for password input fields"
      ],
      "id": "AUTH-NEW-006",
      "refs": {
        "asvs": [
          "V6.2.6"
        ],
        "cwe": [
          "CWE-287"
        ],
        "owasp": [
          "A07:2021"
        ]
      },
      "requirement": "Password input fields must use type=password to mask the entry and allow temporary viewing of the entire masked password or the last typed character.",
      "scope": "web-application",
      "severity": "low",
      "title": "Password Input Field Masking",
      "verify": {
        "tests": [
          "Verify authentication mechanisms and credential handling"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-secure-false",
          "generic.secrets.security.hardcoded-secret"
        ]
      },
      "do": [
        "Register and identify users using a combination of IdP ID and user's ID in the IdP",
        "Implement checks to prevent identity spoofing across multiple identity providers",
        "Validate that user identities are unique across all supported IdPs"
      ],
      "dont": [
        "Do not rely solely on user identifier without considering IdP ID",
        "Do not allow unauthorized access through identity provider manipulation",
        "Avoid trusting user identity claims without proper IdP validation"
      ],
      "id": "AUTH-SPOOFING-001",
      "refs": {
        "asvs": [
          "V6.8.1"
        ],
        "cwe": [
          "CWE-347",
          "CWE-287"
        ],
        "owasp": [
          "A07:2021"
        ]
      },
      "requirement": "Verify that, if the application supports multiple identity providers (IdPs), the user's identity cannot be spoofed via another supported identity provider. The application should register and identify the user using a combination of the IdP ID and the user's ID in the IdP.",
      "scope": "web-application",
      "severity": "high",
      "title": "Prevent Identity Spoofing with Multiple Identity Providers",
      "verify": {
        "tests": [
          "Test identity verification across multiple identity providers",
          "Verify prevention of identity spoofing scenarios",
          "Test user registration with duplicate identities across IdPs"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-secure-false"
        ]
      },
      "do": [
        "Use biometric authentication in conjunction with something you have or know"
      ],
      "dont": [
        "Rely solely on biometric authentication"
      ],
      "id": "AUTH-AUTH-BIOMETRIC-001",
      "refs": {
        "asvs": [
          "V6.5.7"
        ],
        "cwe": [
          "CWE-308"
        ],
        "owasp": [
          "A3:2021"
        ]
      },
      "requirement": "Biometric authentication mechanisms should only be used as secondary factors.",
      "scope": "web-application",
      "severity": "high",
      "title": "Secure Use of Biometric Authentication",
      "verify": {
        "tests": [
          "Verify biometric authentication is used as a secondary factor"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-secure-false"
        ]
      },
      "do": [
        "Implement mechanisms to revoke authentication factors"
      ],
      "dont": [
        "Allow unrevokeable authentication factors"
      ],
      "id": "AUTH-FACTOR-REVOCATION-001",
      "refs": {
        "asvs": [
          "V6.5.6"
        ],
        "cwe": [
          "CWE-602"
        ],
        "owasp": [
          "A3:2021"
        ]
      },
      "requirement": "Any authentication factor must be revocable in case of theft or loss.",
      "scope": "web-application",
      "severity": "high",
      "title": "Revocation of Authentication Factors",
      "verify": {
        "tests": [
          "Test revocation functionality for authentication factors"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "user-enumeration-protection"
        ]
      },
      "do": [
        "Implement protection against user enumeration"
      ],
      "dont": [
        "Reveal valid users through error messages or response times"
      ],
      "id": "AUTH-GEN-007",
      "refs": {
        "asvs": [
          "V6.3.8"
        ],
        "cwe": [
          "CWE-200"
        ],
        "owasp": [
          "A8:2021"
        ]
      },
      "requirement": "Valid users cannot be deduced from failed authentication challenges, such as by error messages or response times.",
      "scope": "web-application",
      "severity": "high",
      "title": "Protection Against User Enumeration",
      "verify": {
        "tests": [
          "Verify protection against user enumeration"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "admin-initiated-password-reset"
        ]
      },
      "do": [
        "Enable administrative users to initiate password reset process for users",
        "Ensure administrative users cannot change or choose the user's password"
      ],
      "dont": [
        "Allow administrative users to change or choose user passwords"
      ],
      "id": "AUTH-ALLOW-PASSWORD-003",
      "refs": {
        "asvs": [
          "V6.4.6"
        ],
        "cwe": [
          "CWE-640"
        ],
        "owasp": [
          "A11:2021"
        ]
      },
      "requirement": "Allow administrative users to initiate the password reset process for users without changing or choosing the user's password.",
      "scope": "web-application",
      "severity": "high",
      "title": "Admin-initiated Password Reset Process",
      "verify": {
        "tests": [
          "Verify that administrative users can initiate password reset without changing user passwords"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "allow-paste-functionality"
        ]
      },
      "do": [
        "Allow users to paste passwords"
      ],
      "dont": [],
      "id": "AUTH-ALLOW-PASSWORD-005",
      "refs": {
        "asvs": [
          "V6.2.7"
        ],
        "cwe": [
          "CWE-312"
        ],
        "owasp": [
          "A2:2021"
        ]
      },
      "requirement": "'paste' functionality, browser password helpers, and external password managers are permitted.",
      "scope": "web-application",
      "severity": "low",
      "title": "Allow 'paste' functionality and external password managers",
      "verify": {
        "tests": [
          "Verify that 'paste' functionality is enabled"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-secure-false"
        ]
      },
      "do": [
        "Use a trusted time source for checking TOTPs to prevent manipulation.",
        "Implement mechanisms to ensure TOTPs are not based on client-provided time."
      ],
      "dont": [
        "Do not rely on untrusted time sources for validating TOTPs."
      ],
      "id": "AUTH-PASSWORD-001",
      "refs": {
        "asvs": [
          "V6.5.8"
        ],
        "cwe": [
          "CWE-287"
        ],
        "owasp": [
          "A07:2021"
        ]
      },
      "requirement": "Time-based one-time passwords (TOTPs) are checked based on a time source from a trusted service and not from an untrusted or client provided time.",
      "scope": "web-application",
      "severity": "high",
      "title": "Secure Time-based One-time Passwords (TOTPs)",
      "verify": {
        "tests": [
          "Verify that TOTPs are validated using a trusted time source."
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "no-periodic-rotation"
        ]
      },
      "do": [
        "Do not enforce periodic password changes"
      ],
      "dont": [],
      "id": "AUTH-CREDENTIAL-PASSWORD-001",
      "refs": {
        "asvs": [
          "V6.2.10"
        ],
        "cwe": [
          "CWE-521"
        ],
        "owasp": [
          "A2:2021"
        ]
      },
      "requirement": "A user's password stays valid until it is discovered to be compromised or the user rotates it. The application must not require periodic credential rotation.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Do not require periodic credential rotation",
      "verify": {
        "tests": [
          "Verify that periodic password rotation is not enforced"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-secure-false"
        ]
      },
      "do": [
        "Set maximum lifetime of 10 minutes for out-of-band requests and 30 seconds for TOTPs"
      ],
      "dont": [
        "Allow indefinite lifetime for authentication codes"
      ],
      "id": "AUTH-OOB-LIFETIME-DEFINITION-001",
      "refs": {
        "asvs": [
          "V6.5.5"
        ],
        "cwe": [
          "CWE-613"
        ],
        "owasp": [
          "A3:2021"
        ]
      },
      "requirement": "Out-of-band authentication requests, codes, or tokens must have a defined lifetime.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Define Lifetime for Out-of-Band Authentication",
      "verify": {
        "tests": [
          "Verify the defined lifetimes for authentication tokens"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "suspicious-authentication-attempts"
        ]
      },
      "do": [
        "Implement notification for suspicious authentication attempts"
      ],
      "dont": [
        "Ignore suspicious authentication attempts"
      ],
      "id": "AUTH-GEN-004",
      "refs": {
        "asvs": [
          "V6.3.5"
        ],
        "cwe": [
          "CWE-285"
        ],
        "owasp": [
          "A5:2021"
        ]
      },
      "requirement": "Users must be notified of suspicious authentication attempts, successful or unsuccessful.",
      "scope": "web-application",
      "severity": "high",
      "title": "Suspicious Authentication Attempts Notification",
      "verify": {
        "tests": [
          "Test notification for suspicious authentication attempts"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "password-hints-and-secret-questions"
        ]
      },
      "do": [
        "Implement alternative authentication methods that do not rely on password hints or secret questions"
      ],
      "dont": [
        "Use password hints or knowledge-based authentication for user authentication"
      ],
      "id": "AUTH-AUTH-SECRET-PASSWORD-001",
      "refs": {
        "asvs": [
          "V6.4.2"
        ],
        "cwe": [
          "CWE-640"
        ],
        "owasp": [
          "A11:2021"
        ]
      },
      "requirement": "Do not use password hints or knowledge-based authentication (secret questions) for user authentication.",
      "scope": "web-application",
      "severity": "low",
      "title": "Use of Password Hints and Knowledge-based Authentication",
      "verify": {
        "tests": [
          "Verify that password hints or secret questions are not used for user authentication"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "authentication-change-notification"
        ]
      },
      "do": [
        "Send notifications when authentication details change",
        "Include relevant change information in notifications",
        "Provide secure communication channels for notifications"
      ],
      "dont": [
        "Update authentication without user notification",
        "Send notifications with sensitive authentication data"
      ],
      "id": "AUTH-IMPLEMENT-UPDATE-NOTIFICATION-001",
      "refs": {
        "asvs": [
          "V6.4.1"
        ],
        "cwe": [
          "CWE-287"
        ],
        "owasp": [
          "A07:2021"
        ]
      },
      "requirement": "Send notifications to users when authentication details are updated to ensure visibility and prevent unauthorized changes.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Authentication Details Update Notification",
      "verify": {
        "tests": [
          "Verify notifications are sent on authentication updates",
          "Test notification content excludes sensitive data"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-secure-false"
        ]
      },
      "do": [
        "Process SAML assertions uniquely",
        "Ensure one-time use of SAML assertions"
      ],
      "dont": [
        "Do not reuse SAML assertions"
      ],
      "id": "AUTH-PREVENT-SAML-002",
      "refs": {
        "asvs": [
          "V6.8.3"
        ],
        "cwe": [
          "CWE-287"
        ],
        "owasp": [
          "A07:2021"
        ]
      },
      "requirement": "Process SAML assertions uniquely and ensure they are used only once within their validity period to prevent replay attacks.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Prevent Replay Attacks with SAML Assertions",
      "verify": {
        "tests": [
          "Test uniqueness and one-time use of SAML assertions"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "expiring-authentication-renewal-instructions"
        ]
      },
      "do": [
        "Send renewal instructions with enough time before expiration for users to renew their authentication mechanisms",
        "Configure automated reminders if necessary"
      ],
      "dont": [
        "Delay sending renewal instructions until authentication mechanisms have expired"
      ],
      "id": "AUTH-IMPLEMENT-RENEWAL-INSTRUCTIONS-001",
      "refs": {
        "asvs": [
          "V6.4.5"
        ],
        "cwe": [
          "CWE-640"
        ],
        "owasp": [
          "A11:2021"
        ]
      },
      "requirement": "Send renewal instructions for expiring authentication mechanisms with sufficient time before expiration, and configure automated reminders if necessary.",
      "scope": "web-application",
      "severity": "high",
      "title": "Renewal Instructions for Expiring Authentication Mechanisms",
      "verify": {
        "tests": [
          "Verify that renewal instructions are sent with sufficient time before expiration"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "multi-factor-authentication-secrets-reuse"
        ]
      },
      "do": [
        "Implement mechanisms to invalidate and prevent reuse of multi-factor authentication secrets after a single use"
      ],
      "dont": [
        "Allow reuse of multi-factor authentication secrets"
      ],
      "id": "AUTH-AUTH-SECRET-MFA-001",
      "refs": {
        "asvs": [
          "V6.5.1"
        ],
        "cwe": [
          "CWE-640"
        ],
        "owasp": [
          "A11:2021"
        ]
      },
      "requirement": "Ensure that lookup secrets, out-of-band authentication requests or codes, and time-based one-time passwords (TOTPs) are only usable once.",
      "scope": "web-application",
      "severity": "medium",
      "title": "One-time Use of Multi-factor Authentication Secrets",
      "verify": {
        "tests": [
          "Verify that multi-factor authentication secrets are only usable once"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "email-based-authentication"
        ]
      },
      "do": [
        "Use dedicated authentication mechanisms instead of email",
        "Implement proper username/password authentication",
        "Reserve email for communication and recovery only"
      ],
      "dont": [
        "Use email address as primary authentication",
        "Rely on email-based authentication for sensitive operations",
        "Send authentication credentials via email"
      ],
      "id": "AUTH-RESTRICT-EMAIL-AUTH-001",
      "refs": {
        "asvs": [
          "V6.1.1"
        ],
        "cwe": [
          "CWE-287"
        ],
        "owasp": [
          "A07:2021"
        ]
      },
      "requirement": "Email addresses should not be used as the primary authentication mechanism to prevent email-based attacks and improve security.",
      "scope": "web-application",
      "severity": "high",
      "title": "Email Not Used for Authentication",
      "verify": {
        "tests": [
          "Verify email is not used for primary authentication",
          "Test that authentication uses proper mechanisms"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-secure-false"
        ]
      },
      "do": [
        "Validate phone numbers before offering PSTN OTP delivery"
      ],
      "dont": [
        "Allow PSTN OTP delivery for unvalidated phone numbers"
      ],
      "id": "AUTH-VALIDATE-PHONE-NUMBERS-001",
      "refs": {
        "asvs": [
          "V6.6.1"
        ],
        "cwe": [
          "CWE-601"
        ],
        "owasp": [
          "A3:2021"
        ]
      },
      "requirement": "PSTN OTP delivery should only be offered for validated phone numbers.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Validate Phone Numbers for PSTN OTP Delivery",
      "verify": {
        "tests": [
          "Test PSTN OTP delivery for validated phone numbers"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-secure-false"
        ]
      },
      "do": [
        "Validate authentication strength information from the IdP",
        "Use a combination of IdP ID and user's ID for user identification"
      ],
      "dont": [
        "Do not rely solely on local authentication strength checks"
      ],
      "id": "AUTH-AUTH-004",
      "refs": {
        "asvs": [
          "V6.8.1"
        ],
        "cwe": [
          "CWE-287"
        ],
        "owasp": [
          "A07:2021"
        ]
      },
      "requirement": "Verify that, if an application uses a separate Identity Provider (IdP) and expects specific authentication strength, methods, or recentness for specific functions, the application verifies this using the information returned by the IdP. The application should register and identify the user using a combination of the IdP ID and the user's ID in the IdP.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Verify Authentication Strength from Identity Provider",
      "verify": {
        "tests": [
          "Verify authentication strength validation from IdP"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "insecure-random-number-generator"
        ]
      },
      "do": [
        "Use a Cryptographically Secure Pseudorandom Number Generator (CSPRNG) to generate authentication secrets"
      ],
      "dont": [
        "Use insecure or predictable random number generators for generating authentication secrets"
      ],
      "id": "AUTH-CSP-AUTH-SECRET-001",
      "refs": {
        "asvs": [
          "V6.5.3"
        ],
        "cwe": [
          "CWE-640"
        ],
        "owasp": [
          "A11:2021"
        ]
      },
      "requirement": "Generate lookup secrets, out-of-band authentication codes, and time-based one-time password seeds using a Cryptographically Secure Pseudorandom Number Generator (CSPRNG).",
      "scope": "web-application",
      "severity": "medium",
      "title": "Use of Cryptographically Secure Pseudorandom Number Generators",
      "verify": {
        "tests": [
          "Verify that a CSPRNG is used to generate authentication secrets"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "verify-password-exactly"
        ]
      },
      "do": [
        "Verify user's password exactly as entered"
      ],
      "dont": [],
      "id": "AUTH-PASSWORD-004",
      "refs": {
        "asvs": [
          "V6.2.8"
        ],
        "cwe": [
          "CWE-312"
        ],
        "owasp": [
          "A2:2021"
        ]
      },
      "requirement": "Verifies the user's password exactly as received from the user, without any modifications such as truncation or case transformation.",
      "scope": "web-application",
      "severity": "low",
      "title": "Verify user's password exactly as received",
      "verify": {
        "tests": [
          "Test password verification without modifications"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-secure-false"
        ]
      },
      "do": [
        "Verify the user's password exactly as received",
        "Do not modify the password such as truncation or case transformation"
      ],
      "dont": [
        "Modify the user's password before verification"
      ],
      "id": "AUTH-NEW-007",
      "refs": {
        "asvs": [
          "V6.2.8"
        ],
        "cwe": [
          "CWE-287"
        ],
        "owasp": [
          "A07:2021"
        ]
      },
      "requirement": "Verify the user's password exactly as received without any modifications such as truncation or case transformation.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Password Verification Integrity",
      "verify": {
        "tests": [
          "Verify authentication mechanisms and credential handling"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "default-user-accounts"
        ]
      },
      "do": [
        "Ensure default user accounts are either not present or disabled"
      ],
      "dont": [
        "Keep default user accounts active"
      ],
      "id": "AUTH-GEN-001",
      "refs": {
        "asvs": [
          "V6.3.2"
        ],
        "cwe": [
          "CWE-16"
        ],
        "owasp": [
          "A2:2021"
        ]
      },
      "requirement": "Default user accounts (e.g., 'root', 'admin', or 'sa') are not present in the application or are disabled.",
      "scope": "web-application",
      "severity": "low",
      "title": "Default User Accounts Absence",
      "verify": {
        "tests": [
          "Manually verify default user accounts are not present or disabled"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "insecure-password-reset-process"
        ]
      },
      "do": [
        "Require users to verify their identity through multi-factor authentication during the password reset process"
      ],
      "dont": [
        "Bypass multi-factor authentication during the password reset process"
      ],
      "id": "AUTH-AUTH-MFA-PASSWORD-001",
      "refs": {
        "asvs": [
          "V6.4.3"
        ],
        "cwe": [
          "CWE-640"
        ],
        "owasp": [
          "A11:2021"
        ]
      },
      "requirement": "Implement a secure process for resetting forgotten passwords that does not bypass multi-factor authentication mechanisms.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Secure Password Reset Process",
      "verify": {
        "tests": [
          "Verify that the password reset process requires multi-factor authentication"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-secure-false",
          "generic.secrets.security.hardcoded-secret"
        ]
      },
      "do": [
        "Implement rate limiting for push notifications in multi-factor authentication",
        "Consider implementing number matching as an additional mitigation strategy",
        "Monitor and log excessive push notification attempts"
      ],
      "dont": [
        "Do not allow unlimited push notifications without rate limiting",
        "Do not rely solely on push notifications without additional controls",
        "Avoid implementing push notifications without abuse prevention mechanisms"
      ],
      "id": "AUTH-MFA-001",
      "refs": {
        "asvs": [
          "V6.6.4"
        ],
        "cwe": [
          "CWE-799",
          "CWE-287"
        ],
        "owasp": [
          "A07:2021"
        ]
      },
      "requirement": "Verify that rate limiting is applied to push notifications used for multi-factor authentication to prevent push bombing attacks. Number matching may also mitigate this risk by requiring user interaction.",
      "scope": "web-application",
      "severity": "high",
      "title": "Rate Limit Push Notifications for Multi-Factor Authentication",
      "verify": {
        "tests": [
          "Test rate limiting functionality for push notifications",
          "Verify number matching implementation if used",
          "Test push bombing attack scenarios"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-secure-false"
        ]
      },
      "do": [
        "Store cryptographic authentication certificates securely to prevent tampering"
      ],
      "dont": [
        "Do not store certificates in plaintext or insecure locations"
      ],
      "id": "AUTH-AUTH-CERT-001",
      "refs": {
        "asvs": [
          "V6.7.1"
        ],
        "cwe": [
          "CWE-311"
        ],
        "owasp": [
          "A3:2021"
        ]
      },
      "requirement": "The certificates used to verify cryptographic authentication assertions are stored in a way that protects them from modification.",
      "scope": "web-application",
      "severity": "high",
      "title": "Secure Storage of Cryptographic Authentication Certificates",
      "verify": {
        "tests": [
          "Verify secure storage mechanisms for cryptographic certificates"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-secure-false"
        ]
      },
      "do": [
        "Store certificates in a secure location with restricted access",
        "Regularly monitor and audit access to certificates"
      ],
      "dont": [
        "Store certificates in plaintext or insecure locations"
      ],
      "id": "AUTH-AUTH-CERT-002",
      "refs": {
        "asvs": [
          "V6.7.1"
        ],
        "cwe": [
          "CWE-287"
        ],
        "owasp": [
          "A07:2021"
        ]
      },
      "requirement": "Verify that certificates used to verify cryptographic authentication assertions are stored securely to protect them from modification.",
      "scope": "web-application",
      "severity": "high",
      "title": "Store Certificates Securely for Cryptographic Authentication",
      "verify": {
        "tests": [
          "Verify access controls and monitoring for certificate storage"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "biometric-authentication-security"
        ]
      },
      "do": [
        "Implement secure biometric template storage",
        "Provide fallback authentication methods",
        "Protect biometric data with encryption",
        "Use secure biometric comparison algorithms"
      ],
      "dont": [
        "Store raw biometric data without protection",
        "Rely solely on biometric authentication",
        "Transmit biometric templates in plaintext"
      ],
      "id": "AUTH-IMPLEMENT-BIOMETRIC-AUTH-001",
      "refs": {
        "asvs": [
          "V6.3.1"
        ],
        "cwe": [
          "CWE-287"
        ],
        "owasp": [
          "A07:2021"
        ]
      },
      "requirement": "Implement biometric authentication with proper security controls including template protection and fallback mechanisms.",
      "scope": "web-application",
      "severity": "high",
      "title": "Biometric Authentication Usage",
      "verify": {
        "tests": [
          "Verify biometric template encryption",
          "Test fallback authentication mechanisms",
          "Validate secure biometric comparison"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "insecure-lookup-secrets-storage"
        ]
      },
      "do": [
        "Hash lookup secrets with less than 112 bits of entropy using an approved hashing algorithm with a random salt"
      ],
      "dont": [
        "Store lookup secrets with less than 112 bits of entropy in plain or reversible format"
      ],
      "id": "AUTH-HASH-SECRET-SALT-001",
      "refs": {
        "asvs": [
          "V6.5.2"
        ],
        "cwe": [
          "CWE-640"
        ],
        "owasp": [
          "A11:2021"
        ]
      },
      "requirement": "Hash lookup secrets with less than 112 bits of entropy using an approved password storage hashing algorithm with a random salt.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Secure Storage of Lookup Secrets",
      "verify": {
        "tests": [
          "Verify that lookup secrets are hashed with a random salt and approved algorithm"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-secure-false"
        ]
      },
      "do": [
        "Use passwords with a minimum of 20 bits of entropy (e.g., 4 random alphanumeric characters or 6 random digits)",
        "Ensure out-of-band authentication requests have a maximum lifetime of 10 minutes",
        "Ensure time-based one-time passwords (TOTPs) have a maximum lifetime of 30 seconds",
        "Revoke any authentication factor in case of theft or loss"
      ],
      "dont": [
        "Use biometric authentication mechanisms as primary factors",
        "Check TOTPs based on untrusted or client provided time"
      ],
      "id": "AUTH-PREVENT-PASSWORD-001",
      "refs": {
        "asvs": [
          "V6.5.4",
          "V6.5.5",
          "V6.5.6",
          "V6.5.7",
          "V6.5.8"
        ],
        "cwe": [
          "CWE-287"
        ],
        "owasp": [
          "A07:2021"
        ]
      },
      "requirement": "Prevent easy to guess passwords by using a documented list of context specific words....",
      "scope": "web-application",
      "severity": "high",
      "title": "Prevent Easy to Guess Passwords",
      "verify": {
        "tests": [
          "Verify authentication mechanisms and credential handling"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-secure-false"
        ]
      },
      "do": [
        "Verify that the password reset process does not bypass multi-factor authentication mechanisms",
        "Implement evidence of identity proofing at the same level as during enrollment if a multi-factor authentication factor is lost",
        "Send renewal instructions for authentication mechanisms with enough time before expiration, configuring automated reminders if necessary"
      ],
      "dont": [
        "Allow password reset processes to bypass multi-factor authentication mechanisms"
      ],
      "id": "AUTHENTICATION-NEW-001",
      "refs": {
        "asvs": [
          "V6.4.3",
          "V6.4.4",
          "V6.4.5",
          "V6.4.6"
        ],
        "cwe": [
          "CWE-287"
        ],
        "owasp": [
          "A07:2021"
        ]
      },
      "requirement": "Implement a secure process for resetting forgotten passwords that does not bypass any enabled multi-factor authentication mechanisms.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Secure Process for Resetting Forgotten Passwords",
      "verify": {
        "tests": [
          "Verify authentication mechanisms and credential handling"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-secure-false"
        ]
      },
      "do": [
        "Ensure out-of-band codes are only valid for the original request"
      ],
      "dont": [
        "Allow reuse of out-of-band codes for different requests"
      ],
      "id": "AUTH-AUTH-CODE-002",
      "refs": {
        "asvs": [
          "V6.6.2"
        ],
        "cwe": [
          "CWE-384"
        ],
        "owasp": [
          "A3:2021"
        ]
      },
      "requirement": "Out-of-band authentication codes must be bound to the original request.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Bind Out-of-Band Authentication to Request",
      "verify": {
        "tests": [
          "Verify out-of-band code binding to requests"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-secure-false"
        ]
      },
      "do": [
        "Generate secrets with at least 20 bits of entropy"
      ],
      "dont": [
        "Use weak secrets with insufficient entropy"
      ],
      "id": "AUTH-MFA-STRONG-SECRETS-001",
      "refs": {
        "asvs": [
          "V6.5.4"
        ],
        "cwe": [
          "CWE-326"
        ],
        "owasp": [
          "A3:2021"
        ]
      },
      "requirement": "Lookup secrets and out-of-band authentication codes must have a minimum of 20 bits of entropy.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Use Strong Secrets for Multi-factor Authentication",
      "verify": {
        "tests": [
          "Test the entropy of generated secrets"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-secure-false",
          "generic.secrets.security.hardcoded-secret"
        ]
      },
      "do": [
        "Always validate digital signatures on authentication assertions for presence and integrity",
        "Reject any assertions that are unsigned or have invalid signatures",
        "Implement proper cryptographic verification of signature algorithms"
      ],
      "dont": [
        "Do not accept authentication assertions without validating digital signatures",
        "Do not rely on client-side signature validation alone",
        "Avoid accepting assertions with weak or deprecated signature algorithms"
      ],
      "id": "AUTH-SIGNATURE-001",
      "refs": {
        "asvs": [
          "V6.8.2"
        ],
        "cwe": [
          "CWE-345",
          "CWE-287"
        ],
        "owasp": [
          "A07:2021"
        ]
      },
      "requirement": "Verify that the presence and integrity of digital signatures on authentication assertions are always validated, rejecting any assertions that are unsigned or have invalid signatures.",
      "scope": "web-application",
      "severity": "high",
      "title": "Validate Digital Signatures on Authentication Assertions",
      "verify": {
        "tests": [
          "Test validation of digital signatures on authentication assertions",
          "Verify rejection of unsigned assertions",
          "Test handling of invalid signature scenarios"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-secure-false"
        ]
      },
      "do": [
        "Implement notification system for suspicious authentication attempts",
        "Include details of the suspicious activity in the notification",
        "Provide guidance on actions to take in response to suspicious attempts"
      ],
      "dont": [
        "Ignore or fail to notify users of suspicious authentication attempts"
      ],
      "id": "AUTH-GEN-003",
      "refs": {
        "asvs": [
          "V6.3.5:2021"
        ],
        "cwe": [
          "CWE-287"
        ],
        "owasp": [
          "A07:2021"
        ]
      },
      "requirement": "Users must be notified of suspicious authentication attempts, including unusual locations, partial successful attempts, long periods of inactivity, or multiple unsuccessful attempts.",
      "scope": "web-application",
      "severity": "high",
      "title": "Notification of Suspicious Authentication Attempts",
      "verify": {
        "tests": [
          "Test notification functionality for suspicious authentication attempts"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-httponly-false"
        ]
      },
      "do": [
        "Use self-contained or reference tokens for session management",
        "Ensure reference tokens are unique and generated using CSPRNG with 128 bits of entropy"
      ],
      "dont": [
        "Use static API secrets and keys for session tokens"
      ],
      "id": "SESSION-SECURE-TOKEN-GENERATION-001",
      "refs": {
        "asvs": [
          "V7.2.2",
          "V7.2.3"
        ],
        "cwe": [
          "CWE-330"
        ],
        "owasp": [
          "A2:2021"
        ]
      },
      "requirement": "Use either self-contained or reference tokens that are dynamically generated for session management. If reference tokens are used, ensure they are unique, generated using a CSPRNG with at least 128 bits of entropy.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Ensure unique and cryptographically secure session tokens",
      "verify": {
        "tests": [
          "Verify usage of unique and cryptographically secure session tokens"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-httponly-false"
        ]
      },
      "do": [
        "Invalidate session data at the application backend on termination"
      ],
      "dont": [
        "Allow terminated sessions to be reused"
      ],
      "id": "SESSION-TERMINATION-INVALIDATION-001",
      "refs": {
        "asvs": [
          "V7.4.1"
        ],
        "cwe": [
          "CWE-384"
        ],
        "owasp": [
          "A2:2021"
        ]
      },
      "requirement": "When session termination is triggered (such as logout or expiration), the application disallows any further use of the session.",
      "scope": "web-application",
      "severity": "low",
      "title": "Disallow Further Use of Session on Termination",
      "verify": {
        "tests": [
          "Verify that terminated sessions cannot be used"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-httponly-false"
        ]
      },
      "do": [
        "Implement multi-factor authentication for highly sensitive transactions"
      ],
      "dont": [
        "Allow highly sensitive transactions without additional authentication"
      ],
      "id": "SESSION-AUTH-VERIFY-001",
      "refs": {
        "asvs": [
          "V7.5.3"
        ],
        "cwe": [
          "CWE-XX"
        ],
        "owasp": [
          "A07:2021"
        ]
      },
      "requirement": "Before performing highly sensitive transactions or operations, further authentication with at least one factor or secondary verification is required.",
      "scope": "web-application",
      "severity": "high",
      "title": "Implement further authentication for highly sensitive transactions",
      "verify": {
        "tests": [
          "Test the implementation of further authentication for highly sensitive transactions"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-httponly-false"
        ]
      },
      "do": [
        "Document systems in federated identity management ecosystem",
        "Define controls for session lifetimes, termination, and re-authentication"
      ],
      "dont": [
        "Neglect documenting federated identity management controls"
      ],
      "id": "SESSION-MANAGEMENT-005",
      "refs": {
        "asvs": [
          "V7.1.3"
        ],
        "cwe": [
          "CWE-200"
        ],
        "owasp": [
          "A2:2021"
        ]
      },
      "requirement": "Document all systems that create and manage user sessions as part of a federated identity management ecosystem (e.g., SSO systems) along with controls for coordinating session lifetimes, termination, and re-authentication conditions.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Document federated identity management ecosystem controls",
      "verify": {
        "tests": [
          "Review documentation for federated identity management controls"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-httponly-false"
        ]
      },
      "do": [
        "Set and enforce an absolute maximum session lifetime",
        "Implement re-authentication mechanisms as necessary"
      ],
      "dont": [
        "Allow sessions to exceed the absolute maximum lifetime without re-authentication"
      ],
      "id": "SESSION-MAXIMUM-LIFETIME-ENFORCEMENT-001",
      "refs": {
        "asvs": [
          "V7.6.1:2021"
        ],
        "cwe": [
          "CWE-384"
        ],
        "owasp": [
          "A07:2021"
        ]
      },
      "requirement": "There is an absolute maximum session lifetime such that re-authentication is enforced according to requirements.",
      "scope": "web-application",
      "severity": "high",
      "title": "Enforce Absolute Maximum Session Lifetime",
      "verify": {
        "tests": [
          "Test session lifetime enforcement and re-authentication mechanisms"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-httponly-false"
        ]
      },
      "do": [
        "Configure session lifetime and re-authentication settings between RPs and IdPs"
      ],
      "dont": [
        "Neglect session lifetime and re-authentication requirements"
      ],
      "id": "SESSION-AUTH-LIFETIME-ENFORCE-001",
      "refs": {
        "asvs": [
          "V7.6.1"
        ],
        "cwe": [
          "CWE-XX"
        ],
        "owasp": [
          "A07:2021"
        ]
      },
      "requirement": "Ensure session lifetime and termination between Relying Parties (RPs) and Identity Providers (IdPs) are as documented, requiring re-authentication when necessary.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Enforce session lifetime and re-authentication between RPs and IdPs",
      "verify": {
        "tests": [
          "Verify session lifetime and re-authentication behavior between RPs and IdPs"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "session-token-verification-trusted-backend"
        ]
      },
      "do": [
        "Implement backend service for session token verification"
      ],
      "dont": [
        "Perform session token verification on the client-side"
      ],
      "id": "SESSION-VERIFY-TOKEN-SESSION-001",
      "refs": {
        "asvs": [
          "V7.2.1:2021"
        ],
        "cwe": [
          "CWE-613"
        ],
        "owasp": [
          "A2:2021"
        ]
      },
      "requirement": "All session token verification must be performed using a trusted backend service to ensure security and integrity.",
      "scope": "web-application/api",
      "severity": "medium",
      "title": "Perform session token verification using a trusted backend service",
      "verify": {
        "tests": [
          "Manually verify that session token verification is handled by the backend service"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-httponly-false"
        ]
      },
      "do": [
        "Terminate all active sessions associated with the disabled/deleted account"
      ],
      "dont": [
        "Allow disabled/deleted accounts to have active sessions"
      ],
      "id": "SESSION-ACCOUNT-TERMINATION-001",
      "refs": {
        "asvs": [
          "V7.4.2"
        ],
        "cwe": [
          "CWE-384"
        ],
        "owasp": [
          "A2:2021"
        ]
      },
      "requirement": "Terminates all active sessions when a user account is disabled or deleted.",
      "scope": "web-application",
      "severity": "low",
      "title": "Terminate Sessions on Account Disable/Delete",
      "verify": {
        "tests": [
          "Verify that sessions are terminated when accounts are disabled/deleted"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-httponly-false"
        ]
      },
      "do": [
        "Provide the option to terminate all other active sessions after changing or removing an authentication factor"
      ],
      "dont": [
        "Allow active sessions to persist without re-authentication after authentication factor changes"
      ],
      "id": "SESSION-MANAGEMENT-NEW-002",
      "refs": {
        "asvs": [
          "V7.4.3"
        ],
        "cwe": [
          "CWE-384"
        ]
      },
      "requirement": "Give the option to terminate all other active sessions after a successful change or removal of any authentication factor to enhance security.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Terminate other active sessions after authentication factor change",
      "verify": {
        "tests": [
          "Verify that users can terminate other active sessions after authentication factor changes"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-httponly-false"
        ]
      },
      "do": [
        "Ensure logout functionality is easily accessible on authenticated pages"
      ],
      "dont": [
        "Hide or make logout functionality hard to find"
      ],
      "id": "SESSION-VISIBLE-LOGOUT-FUNCTIONALITY-001",
      "refs": {
        "asvs": [
          "V7.4.4"
        ],
        "cwe": [
          "CWE-384"
        ],
        "owasp": [
          "A2:2021"
        ]
      },
      "requirement": "All pages that require authentication have easy and visible access to logout functionality.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Provide Visible Logout Functionality",
      "verify": {
        "tests": [
          "Verify that logout functionality is visible on authenticated pages"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "http.cookie-session-id-fingerprinting",
          "http.cookie-session-id-disclosure",
          "python.django.security.audit.session-cookie-secure-false",
          "python.django.security.audit.session-cookie-httponly-false",
          "java.spring.security.audit.spring-csrf-disabled"
        ],
        "trufflehog": [
          "Generic API Key"
        ]
      },
      "do": [
        "Update session ID names to generic terms to prevent fingerprinting",
        "Implement a random session ID generator with at least 64 bits of entropy",
        "Ensure session ID names do not reveal sensitive information"
      ],
      "dont": [
        "Use default session ID names like 'PHPSESSID', 'JSESSIONID', 'ASP.NET_SessionId'"
      ],
      "id": "SESSION-MANAGEMENT-001",
      "refs": {
        "cwe": [
          "CWE-200",
          "CWE-384"
        ],
        "owasp": [
          "A3:2021",
          "A6:2021"
        ]
      },
      "requirement": "Change default session ID names to generic names like 'id' to avoid disclosing technologies and programming languages used by the web application.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Use generic session ID names to avoid fingerprinting",
      "verify": {
        "tests": [
          "Verify session ID names are generic and do not disclose sensitive information",
          "Test session ID generation for at least 64 bits of entropy"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-httponly-false"
        ]
      },
      "do": [
        "Provide the option to terminate all other active sessions after authentication factor change"
      ],
      "dont": [
        "Keep all other sessions active after authentication factor change"
      ],
      "id": "SESSION-AUTH-FACTOR-TERMINATION-001",
      "refs": {
        "asvs": [
          "V7.4.3"
        ],
        "cwe": [
          "CWE-384"
        ],
        "owasp": [
          "A2:2021"
        ]
      },
      "requirement": "Gives the option to terminate all other active sessions after a successful change or removal of any authentication factor.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Terminate Other Sessions on Authentication Factor Change",
      "verify": {
        "tests": [
          "Verify that users can terminate other sessions after authentication factor change"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-httponly-false"
        ]
      },
      "do": [
        "Generate a new session token on user authentication",
        "Document session inactivity timeout and absolute maximum session lifetime with justification"
      ],
      "dont": [
        "Reuse session tokens"
      ],
      "id": "SESSION-AUTH-LIFETIME-TIMEOUT-001",
      "refs": {
        "asvs": [
          "V7.1.1",
          "V7.2.4",
          "V7.3.1"
        ],
        "cwe": [
          "CWE-384"
        ],
        "owasp": [
          "A2:2021"
        ]
      },
      "requirement": "Generate a new session token upon user authentication, including re-authentication, and terminate the current session token. Ensure the session inactivity timeout and absolute maximum session lifetime are documented with justification for deviations from NIST SP 800-63B re-authentication requirements.",
      "scope": "web-application",
      "severity": "high",
      "title": "Generate new session token on user authentication",
      "verify": {
        "tests": [
          "Verify new session token generation on user authentication",
          "Review documentation for session inactivity timeout and absolute maximum session lifetime"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-httponly-false"
        ]
      },
      "do": [
        "Implement mechanisms for federated re-authentication between RPs and IdPs"
      ],
      "dont": [
        "Neglect re-authentication requirements between RPs and IdPs"
      ],
      "id": "SESSION-AUTH-LIFETIME-SESSION-001",
      "refs": {
        "asvs": [
          "V7.6.1:2021"
        ],
        "cwe": [
          "CWE-384"
        ],
        "owasp": [
          "A07:2021"
        ]
      },
      "requirement": "Ensure session lifetime and termination between Relying Parties (RPs) and Identity Providers (IdPs) behave as documented, requiring re-authentication as necessary such as when the maximum time between IdP authentication events is reached.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Federated Re-authentication",
      "verify": {
        "tests": [
          "Test session behavior between RPs and IdPs for re-authentication"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "unique-reference-tokens"
        ]
      },
      "do": [
        "Generate unique reference tokens using CSPRNG with at least 128 bits of entropy"
      ],
      "dont": [
        "Reuse reference tokens or generate them without sufficient entropy"
      ],
      "id": "SESSION-TOKEN-SESSION-001",
      "refs": {
        "asvs": [
          "V7.2.3:2021"
        ],
        "cwe": [
          "CWE-330"
        ],
        "owasp": [
          "A2:2021"
        ]
      },
      "requirement": "If reference tokens are used for user sessions, ensure they are unique and possess sufficient entropy for security.",
      "scope": "web-application/api",
      "severity": "medium",
      "title": "Generate unique reference tokens with sufficient entropy",
      "verify": {
        "tests": [
          "Check that reference tokens are unique and have sufficient entropy"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-httponly-false"
        ]
      },
      "do": [
        "Implement mechanisms to require user consent or explicit action for session creation"
      ],
      "dont": [
        "Allow creation of new application sessions without user interaction"
      ],
      "id": "SESSION-PREVENT-SESSION-001",
      "refs": {
        "asvs": [
          "V7.6.2:2021"
        ],
        "cwe": [
          "CWE-384"
        ],
        "owasp": [
          "A07:2021"
        ]
      },
      "requirement": "Ensure that the creation of a session requires either the user's consent or an explicit action to prevent the creation of new application sessions without user interaction.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Require user consent or action for session creation",
      "verify": {
        "tests": [
          "Test session creation process for user consent or explicit action"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-httponly-false"
        ]
      },
      "do": [
        "Allow users to view and terminate active sessions"
      ],
      "dont": [
        "Restrict users from managing their active sessions"
      ],
      "id": "SESSION-ACTIVE-MANAGEMENT-TERMINATION-001",
      "refs": {
        "asvs": [
          "V7.5.2"
        ],
        "cwe": [
          "CWE-384"
        ],
        "owasp": [
          "A2:2021"
        ]
      },
      "requirement": "Users are able to view and terminate any or all currently active sessions.",
      "scope": "web-application",
      "severity": "medium",
      "title": "View and Terminate Active Sessions",
      "verify": {
        "tests": [
          "Verify that users can view and terminate their active sessions"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-httponly-false"
        ]
      },
      "do": [
        "Generate tokens dynamically for each session",
        "Use strong cryptographic algorithms for token generation"
      ],
      "dont": [
        "Reuse tokens across sessions"
      ],
      "id": "SESSION-PREVENT-MGMT-TOKEN-001",
      "refs": {
        "asvs": [
          "V7.3.2"
        ],
        "cwe": [
          "CWE-347"
        ]
      },
      "requirement": "Session management should use dynamically generated tokens to enhance security and prevent unauthorized access.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Use dynamically generated tokens for session management",
      "verify": {
        "tests": [
          "Verify that tokens are dynamically generated and not reused"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "http.session-id-weak-entropy",
          "http.session-id-brute-force",
          "python.django.security.audit.session-cookie-secure-false",
          "python.django.security.audit.session-cookie-httponly-false",
          "java.spring.security.audit.spring-csrf-disabled"
        ]
      },
      "do": [
        "Use a strong CSPRNG to generate session IDs",
        "Ensure session IDs have at least 64 bits of entropy",
        "Consider different encoding methods to achieve required entropy"
      ],
      "dont": [
        "Use predictable or weak session ID generation algorithms"
      ],
      "id": "SESSION-MANAGEMENT-002",
      "refs": {
        "cwe": [
          "CWE-330",
          "CWE-338"
        ],
        "owasp": [
          "A3:2021",
          "A6:2021"
        ]
      },
      "requirement": "Generate session IDs with at least 64 bits of entropy using a cryptographically secure pseudorandom number generator to prevent brute-force guessing attacks.",
      "scope": "web-application",
      "severity": "high",
      "title": "Implement strong session ID entropy to prevent brute-force attacks",
      "verify": {
        "tests": [
          "Test session ID generation algorithm for entropy strength",
          "Verify session IDs have at least 64 bits of entropy"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-httponly-false"
        ]
      },
      "do": [
        "Implement a mechanism to terminate all active sessions upon user account disablement or deletion"
      ],
      "dont": [
        "Allow disabled or deleted user accounts to retain active sessions"
      ],
      "id": "SESSION-MANAGEMENT-NEW-001",
      "refs": {
        "asvs": [
          "V7.4.2"
        ],
        "cwe": [
          "CWE-384"
        ]
      },
      "requirement": "Terminate all active sessions when a user account is disabled or deleted to prevent unauthorized access.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Terminate all active sessions on user account disable or deletion",
      "verify": {
        "tests": [
          "Verify that all active sessions are terminated when a user account is disabled or deleted"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "session-management-security"
        ]
      },
      "do": [
        "Implement secure session token generation",
        "Use cryptographically strong session identifiers",
        "Enforce proper session timeout mechanisms",
        "Implement secure session storage"
      ],
      "dont": [
        "Use predictable session identifiers",
        "Store sessions in insecure locations",
        "Allow indefinite session duration",
        "Reuse session tokens after logout"
      ],
      "id": "SESSION-IMPLEMENT-SECURE-MECHANISMS-001",
      "refs": {
        "asvs": [
          "V3.1.1"
        ],
        "cwe": [
          "CWE-384"
        ],
        "owasp": [
          "A07:2021"
        ]
      },
      "requirement": "Implement secure session management mechanisms including proper session creation, maintenance, and termination to prevent session-based attacks.",
      "scope": "web-application",
      "severity": "critical",
      "title": "Enforce secure session management mechanisms",
      "verify": {
        "tests": [
          "Verify session token randomness and strength",
          "Test session timeout enforcement",
          "Validate secure session storage"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-session-no-secret",
          "python.django.security.audit.session-cookie-httponly-false"
        ]
      },
      "do": [
        "Use trusted backend service for session token verification"
      ],
      "dont": [
        "Rely on untrusted services for session token verification"
      ],
      "id": "SESSION-TRUSTED-BACKEND-VERIFICATION-001",
      "refs": {
        "asvs": [
          "V7.2.1"
        ],
        "cwe": [
          "CWE-346"
        ],
        "owasp": [
          "A2:2021"
        ]
      },
      "requirement": "Perform all session token verification using a trusted backend service to ensure secure session management.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Use trusted backend service for session token verification",
      "verify": {
        "tests": [
          "Verify session token verification using trusted backend service"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "logging.time-synchronization"
        ],
        "trufflehog": [
          "Data Integrity"
        ]
      },
      "do": [
        "Implement time synchronization mechanisms for all servers and devices",
        "Use network time protocols (NTP) to ensure consistent time across the infrastructure",
        "Regularly monitor and adjust time settings to prevent drift"
      ],
      "dont": [
        "Do not overlook time synchronization, leading to inaccurate event timestamps"
      ],
      "id": "LOG-ENVIRONMENT-LOGGING-001",
      "refs": {
        "cwe": [
          "CWE-778",
          "CWE-117"
        ],
        "owasp": [
          "A10:2021",
          "A13:2021"
        ]
      },
      "requirement": "Ensure time synchronization across all servers and devices to maintain accurate timestamps in log entries, facilitating correlation and analysis of events across the application environment.",
      "scope": "web-application",
      "severity": "low",
      "title": "Synchronize time across all servers and devices for accurate logging",
      "verify": {
        "tests": [
          "Verify that time synchronization is in place for all servers and devices",
          "Test the accuracy of event timestamps in log entries"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "logging.application-errors",
          "logging.system-events",
          "logging.high-risk-functionality-usage"
        ],
        "trufflehog": [
          "Sensitive Data Exposure"
        ]
      },
      "do": [
        "Implement logging for application errors and system events",
        "Log the usage of high-risk functionality such as user administration actions and encryption activities",
        "Include detailed information like event timestamp, severity, and description in the logs"
      ],
      "dont": [
        "Do not overlook logging application errors, system events, and critical functionality usage"
      ],
      "id": "LOG-LOG-APPLICATION-ERRORS-001",
      "refs": {
        "cwe": [
          "CWE-209",
          "CWE-778"
        ],
        "owasp": [
          "A06:2021",
          "A10:2021"
        ]
      },
      "requirement": "Log application errors, system events, and usage of high-risk functionality to identify potential security vulnerabilities, performance issues, and unauthorized activities within the application.",
      "scope": "web-application",
      "severity": "high",
      "title": "Log application errors, system events, and high-risk functionality usage",
      "verify": {
        "tests": [
          "Verify that application errors, system events, and high-risk functionality usage are logged",
          "Test the logging of critical events during security testing to ensure completeness"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "logging.sanitization"
        ],
        "trufflehog": [
          "Sensitive Data Exposure"
        ]
      },
      "do": [
        "Implement log sanitization to remove sensitive data before logging",
        "Mask or encrypt sensitive information like passwords and personal data in log entries",
        "Consider pseudonymization techniques for indirect identifiers in log data"
      ],
      "dont": [
        "Do not log sensitive information in clear text without sanitization"
      ],
      "id": "LOG-PREVENT-KEY-SANITIZE-001",
      "refs": {
        "cwe": [
          "CWE-312",
          "CWE-315"
        ],
        "owasp": [
          "A10:2021",
          "A13:2021"
        ]
      },
      "requirement": "Apply log sanitization techniques to remove or mask sensitive data such as passwords, personal information, and encryption keys from log entries to prevent exposure of confidential information.",
      "scope": "web-application",
      "severity": "low",
      "title": "Implement log sanitization to protect sensitive data",
      "verify": {
        "tests": [
          "Verify that log sanitization techniques are applied to sensitive data",
          "Test the effectiveness of data masking in log entries during security assessments"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "logging.alerting-mechanisms"
        ],
        "trufflehog": [
          "Data Leakage"
        ]
      },
      "do": [
        "Configure alerting for critical events such as authentication failures or high-risk activities",
        "Monitor log data continuously for anomalies or suspicious activities",
        "Integrate log alerts with incident response processes for timely action"
      ],
      "dont": [
        "Do not overlook setting up alerts for critical security events in logs"
      ],
      "id": "LOG-MONITORING-ENABLE-001",
      "refs": {
        "cwe": [
          "CWE-778",
          "CWE-117"
        ],
        "owasp": [
          "A10:2021",
          "A13:2021"
        ]
      },
      "requirement": "Set up alerting mechanisms to notify responsible teams about critical events in the logs and ensure continuous monitoring for immediate response to security incidents.",
      "scope": "web-application",
      "severity": "low",
      "title": "Enable alerting and monitoring for critical events",
      "verify": {
        "tests": [
          "Verify that alerting mechanisms are triggered for critical events",
          "Test the monitoring of log data for timely detection of security incidents"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "logging.encryption-transit",
          "logging.encryption-rest"
        ],
        "trufflehog": [
          "Sensitive Data Exposure"
        ]
      },
      "do": [
        "Use secure transmission protocols for sending log data over untrusted networks",
        "Encrypt log data stored at rest using strong encryption algorithms",
        "Consider data masking or encryption for sensitive log entries"
      ],
      "dont": [
        "Do not transmit log data over untrusted networks without encryption"
      ],
      "id": "LOG-ACCESS-001",
      "refs": {
        "cwe": [
          "CWE-311",
          "CWE-312"
        ],
        "owasp": [
          "A10:2021",
          "A13:2021"
        ]
      },
      "requirement": "Encrypt log data both in transit and at rest to protect sensitive information from unauthorized access or interception.",
      "scope": "web-application",
      "severity": "high",
      "title": "Encrypt log data in transit and at rest",
      "verify": {
        "tests": [
          "Verify that log data is encrypted in transit and at rest",
          "Test encryption mechanisms during security testing to ensure effectiveness"
        ]
      }
    },
    {
      "detect": {
        "custom": [
          "Manual code review to ensure error handling is implemented correctly"
        ],
        "semgrep": [
          "java.servlet.error-page",
          "java.servlet.error-handler",
          "python.logging.security.audit.logging-sensitive-data",
          "java.lang.security.audit.system-exit",
          "javascript.express.security.audit.express-expose-sensitive-data"
        ],
        "trufflehog": [
          "Java Error Handling Configuration"
        ]
      },
      "do": [
        "Configure the web.xml file to define error-page for java.lang.Exception",
        "Create an error.jsp file to log the error, set HTTP response header, and return a generic JSON response",
        "Ensure the error.jsp file handles unexpected errors and returns a 500 status code"
      ],
      "dont": [
        "Avoid exposing detailed error messages to users in production environments"
      ],
      "id": "ERROR-HANDLING-001",
      "refs": {
        "asvs": [
          "V6.4.1",
          "V6.4.2"
        ],
        "cwe": [
          "CWE-209",
          "CWE-116"
        ],
        "owasp": [
          "A06:2021",
          "A07:2021"
        ],
        "standards": [
          "RFC 7807"
        ]
      },
      "requirement": "Configure a global error handler in Java web applications to redirect to an error page, trace the error, and return a generic response without revealing implementation details.",
      "scope": "web-application",
      "severity": "high",
      "title": "Implement global error handling for Java web applications",
      "verify": {
        "tests": [
          "Verify that unexpected errors redirect to the error page",
          "Test that error.jsp logs errors and returns a generic response",
          "Confirm that detailed error messages are not exposed to users"
        ]
      }
    },
    {
      "detect": {
        "custom": [
          "Manual code review to validate error handling implementation"
        ],
        "semgrep": [
          "spring.exception-handler",
          "spring.problem-detail",
          "python.logging.security.audit.logging-sensitive-data",
          "java.lang.security.audit.system-exit",
          "javascript.express.security.audit.express-expose-sensitive-data"
        ],
        "trufflehog": [
          "Spring Error Handling Configuration"
        ]
      },
      "do": [
        "Create a RestResponseEntityExceptionHandler class to handle exceptions extending java.lang.Exception",
        "Use ProblemDetail class to create the response object with a generic message",
        "Ensure the response includes an internal server error status code (500)"
      ],
      "dont": [
        "Avoid returning detailed error messages to clients in production environments"
      ],
      "id": "ERROR-HANDLING-002",
      "refs": {
        "asvs": [
          "V6.4.1",
          "V6.4.2"
        ],
        "cwe": [
          "CWE-209",
          "CWE-116"
        ],
        "owasp": [
          "A06:2021",
          "A07:2021"
        ],
        "standards": [
          "RFC 7807"
        ]
      },
      "requirement": "Define a global error handler in SpringMVC or SpringBoot applications to return a generic response for unexpected errors without exposing sensitive information.",
      "scope": "web-application",
      "severity": "high",
      "title": "Implement global error handling for SpringMVC/SpringBoot applications",
      "verify": {
        "tests": [
          "Validate that the global error handler responds with a generic message for all exceptions",
          "Test that the response includes an internal server error status code",
          "Confirm that no sensitive information is exposed in error responses"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "logging.log-rotation",
          "logging.retention-policies"
        ],
        "trufflehog": [
          "Data Retention"
        ]
      },
      "do": [
        "Implement log rotation to manage log file sizes and prevent disk space exhaustion",
        "Define retention periods for log data based on legal, regulatory, and operational needs",
        "Regularly review and adjust log rotation and retention policies as necessary"
      ],
      "dont": [
        "Do not neglect log rotation and retention policies, leading to unmanageable log file sizes"
      ],
      "id": "LOG-PREVENT-001",
      "refs": {
        "cwe": [
          "CWE-778",
          "CWE-117"
        ],
        "owasp": [
          "A10:2021",
          "A13:2021"
        ]
      },
      "requirement": "Establish log rotation and retention policies to manage log file sizes, prevent disk space exhaustion, and comply with legal and regulatory requirements.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Implement log rotation and retention policies",
      "verify": {
        "tests": [
          "Verify that log rotation is functioning as intended",
          "Review log retention policies to ensure compliance with legal and operational requirements"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "logging.input-validation-failure",
          "logging.output-validation-failure"
        ],
        "trufflehog": [
          "Sensitive Data Leakage"
        ]
      },
      "do": [
        "Implement logging mechanisms to capture input validation failures",
        "Implement logging mechanisms to capture output validation failures",
        "Include details such as timestamp, user identity, and description in the log entries"
      ],
      "dont": [
        "Do not ignore input validation failures or output validation failures in logs"
      ],
      "id": "LOG-VALID-001",
      "refs": {
        "cwe": [
          "CWE-117",
          "CWE-778"
        ],
        "owasp": [
          "A10:2021",
          "A06:2021"
        ]
      },
      "requirement": "Ensure that all input validation failures (e.g., protocol violations, invalid parameter values) and output validation failures (e.g., database record set mismatch) are logged to provide visibility into potential security issues.",
      "scope": "web-application",
      "severity": "high",
      "title": "Log all input validation failures and output validation failures",
      "verify": {
        "tests": [
          "Verify that input validation failures and output validation failures are logged",
          "Test the logging mechanism during security testing to ensure proper functionality"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "logging.authentication-success",
          "logging.authentication-failure",
          "logging.authorization-failure"
        ],
        "trufflehog": [
          "Credentials Exposure"
        ]
      },
      "do": [
        "Implement logging for successful authentications",
        "Implement logging for failed authentication attempts",
        "Implement logging for authorization failures",
        "Include user identity, timestamp, and event description in the log entries"
      ],
      "dont": [
        "Do not neglect logging authentication and authorization events"
      ],
      "id": "LOG-AUTH-AUTHZ-ACCESS-001",
      "refs": {
        "cwe": [
          "CWE-285",
          "CWE-306"
        ],
        "owasp": [
          "A03:2021",
          "A07:2021"
        ]
      },
      "requirement": "Ensure that authentication successes, authentication failures, and authorization failures are logged to monitor and track access control activities within the application.",
      "scope": "web-application",
      "severity": "high",
      "title": "Log authentication successes, failures, and authorization failures",
      "verify": {
        "tests": [
          "Verify that authentication successes, failures, and authorization failures are properly logged",
          "Test the logging of authentication and authorization events during security testing"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "logging.testing-verification"
        ],
        "trufflehog": [
          "Sensitive Data Exposure"
        ]
      },
      "do": [
        "Include logging mechanisms in code review and application testing processes",
        "Verify that logs are being generated as expected during security verification",
        "Test the resilience of logging mechanisms against common attacks and failures"
      ],
      "dont": [
        "Do not assume logging mechanisms are functioning correctly without regular testing"
      ],
      "id": "LOG-VERIFY-LOGGING-001",
      "refs": {
        "cwe": [
          "CWE-778",
          "CWE-117"
        ],
        "owasp": [
          "A10:2021",
          "A13:2021"
        ]
      },
      "requirement": "Regularly test and verify the functionality of logging mechanisms to ensure they are operational, accurate, and effective in capturing security-relevant events.",
      "scope": "web-application",
      "severity": "low",
      "title": "Perform regular testing and verification of logging mechanisms",
      "verify": {
        "tests": [
          "Conduct regular testing of logging mechanisms to ensure proper functionality",
          "Verify that logs are accurate and complete during security assessments"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "logging.centralized-collection"
        ],
        "trufflehog": [
          "Data Leakage"
        ]
      },
      "do": [
        "Set up a centralized log collection system for aggregating log data",
        "Utilize SIEM or SEM tools for log analysis and monitoring",
        "Integrate log data from different application components for comprehensive security monitoring"
      ],
      "dont": [
        "Do not rely solely on decentralized or siloed log storage systems"
      ],
      "id": "LOG-MONITORING-MGMT-001",
      "refs": {
        "cwe": [
          "CWE-778",
          "CWE-117"
        ],
        "owasp": [
          "A10:2021",
          "A13:2021"
        ]
      },
      "requirement": "Implement a centralized log collection and management system (e.g., SIEM or SEM) to aggregate, analyze, and monitor log data from various application components for improved security monitoring and incident response.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Implement centralized log collection and management",
      "verify": {
        "tests": [
          "Verify that log data is being centrally collected and managed",
          "Test the integration of log data from various components during security testing"
        ]
      }
    },
    {
      "detect": {
        "custom": [
          "Manual inspection to ensure error handling is correctly implemented"
        ],
        "semgrep": [
          "aspnetcore.error-handler",
          "aspnetcore.json-error-response",
          "python.logging.security.audit.logging-sensitive-data",
          "java.lang.security.audit.system-exit",
          "javascript.express.security.audit.express-expose-sensitive-data"
        ],
        "trufflehog": [
          "ASP.NET Core Error Handling Configuration"
        ]
      },
      "do": [
        "Create an ErrorController API Controller to handle all unexpected exceptions",
        "Build a generic JSON response with a message indicating an error occurred",
        "Set the HTTP status code to 500 for internal server errors"
      ],
      "dont": [
        "Avoid leaking implementation details in error responses"
      ],
      "id": "ERROR-HANDLING-003",
      "refs": {
        "asvs": [
          "V6.4.1",
          "V6.4.2"
        ],
        "cwe": [
          "CWE-209",
          "CWE-116"
        ],
        "owasp": [
          "A06:2021",
          "A07:2021"
        ],
        "standards": [
          "RFC 7807"
        ]
      },
      "requirement": "Define a global error handler in ASP.NET Core applications to return a generic JSON response for unexpected errors and log error details without exposing sensitive information.",
      "scope": "web-application",
      "severity": "high",
      "title": "Implement global error handling for ASP.NET Core web applications",
      "verify": {
        "tests": [
          "Ensure the ErrorController handles all types of exceptions",
          "Verify that the response includes a generic error message",
          "Confirm that the HTTP status code is set to 500 for internal server errors"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "logging.customizable-levels"
        ],
        "trufflehog": [
          "Sensitive Data Exposure"
        ]
      },
      "do": [
        "Allow customization of logging levels to adjust verbosity",
        "Ensure default logging level provides sufficient detail for operational needs",
        "Prevent deactivation of critical event logging or compliance-required logs"
      ],
      "dont": [
        "Do not allow complete deactivation of application logging or critical event logging"
      ],
      "id": "LOG-LOGGING-001",
      "refs": {
        "cwe": [
          "CWE-778",
          "CWE-117"
        ],
        "owasp": [
          "A10:2021",
          "A13:2021"
        ]
      },
      "requirement": "Implement customizable logging levels to adjust the verbosity of logging based on severity, threat level, and operational needs while ensuring critical events are always captured.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Implement customizable logging levels",
      "verify": {
        "tests": [
          "Verify that logging levels can be customized as needed",
          "Test the default logging level to ensure it captures essential events"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "logging.secure-transmission"
        ],
        "trufflehog": [
          "Sensitive Data Exposure"
        ]
      },
      "do": [
        "Utilize secure transmission protocols (e.g., TLS) for transmitting log data over untrusted networks",
        "Encrypt log data before transmission to protect confidentiality and integrity"
      ],
      "dont": [
        "Do not transmit log data over untrusted networks without encryption"
      ],
      "id": "LOG-PREVENT-002",
      "refs": {
        "cwe": [
          "CWE-311",
          "CWE-312"
        ],
        "owasp": [
          "A10:2021",
          "A13:2021"
        ]
      },
      "requirement": "Use secure transmission protocols when sending log data over untrusted networks to prevent interception or tampering of log entries during transit.",
      "scope": "web-application",
      "severity": "low",
      "title": "Implement secure transmission protocols for log data",
      "verify": {
        "tests": [
          "Verify that log data is transmitted using secure protocols",
          "Test the encryption of log data during transmission for effectiveness"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "logging.log-handler"
        ],
        "trufflehog": [
          "Data Leakage"
        ]
      },
      "do": [
        "Create a reusable log handler module for consistent log generation",
        "Define a standard interface for logging across different application components",
        "Ensure the log handler is thoroughly tested and integrated into approved modules"
      ],
      "dont": [
        "Do not rely on ad-hoc logging mechanisms that vary across applications"
      ],
      "id": "LOG-MGMT-001",
      "refs": {
        "cwe": [
          "CWE-778",
          "CWE-117"
        ],
        "owasp": [
          "A10:2021",
          "A13:2021"
        ]
      },
      "requirement": "Develop a standardized log handler module that can be used across multiple applications to ensure consistent log generation, format, and content for easier management and analysis.",
      "scope": "web-application",
      "severity": "low",
      "title": "Implement log handler for consistent log generation",
      "verify": {
        "tests": [
          "Verify that the log handler module is being used for log generation",
          "Test the consistency of log format and content across applications"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "logging.review-policies"
        ],
        "trufflehog": [
          "Data Retention"
        ]
      },
      "do": [
        "Review log rotation and retention policies at regular intervals",
        "Adjust log rotation settings based on changing operational needs",
        "Ensure retention periods align with legal and regulatory obligations"
      ],
      "dont": [
        "Do not neglect reviewing log rotation and retention policies, leading to compliance issues"
      ],
      "id": "LOG-REGULARLY-REVIEW-ADJUST-001",
      "refs": {
        "cwe": [
          "CWE-778",
          "CWE-117"
        ],
        "owasp": [
          "A10:2021",
          "A13:2021"
        ]
      },
      "requirement": "Periodically review log rotation and retention policies to ensure log file sizes are managed effectively, and retention periods comply with legal, regulatory, and operational requirements.",
      "scope": "web-application",
      "severity": "low",
      "title": "Regularly review and adjust log rotation and retention policies",
      "verify": {
        "tests": [
          "Verify that log rotation and retention policies are periodically reviewed",
          "Review and adjust log rotation settings during compliance checks"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "logging.event-attributes"
        ],
        "trufflehog": [
          "Sensitive Data Exposure"
        ]
      },
      "do": [
        "Include timestamp, user identity, event type, and description in each log entry",
        "Consider additional attributes like severity, action, object, and result status for comprehensive event logging"
      ],
      "dont": [
        "Do not omit critical event attributes in log entries, hindering analysis and monitoring"
      ],
      "id": "LOG-MONITORING-SCRIPT-001",
      "refs": {
        "cwe": [
          "CWE-778",
          "CWE-117"
        ],
        "owasp": [
          "A10:2021",
          "A13:2021"
        ]
      },
      "requirement": "Ensure that each log entry includes essential event attributes such as timestamp, user identity, event type, and description for effective monitoring and analysis.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Include sufficient event attributes in log entries",
      "verify": {
        "tests": [
          "Verify that essential event attributes are present in all log entries",
          "Test the completeness of event attributes during security testing"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "yaml.docker-compose.security.writable-filesystem-service",
          "terraform.aws.security.aws-s3-bucket-public-read-prohibited"
        ]
      },
      "do": [
        "Define resource\u2011management strategies for external systems",
        "Include resource\u2011release procedures, timeout settings, and retry logic"
      ],
      "dont": [
        "Neglect defining resource\u2011management strategies"
      ],
      "id": "CONFIG-RESOURCE-MANAGEMENT-DOCUMENTATION-001",
      "refs": {
        "asvs": [
          "V13.1.3"
        ],
        "cwe": [
          "CWE-16"
        ],
        "owasp": [
          "A05:2021"
        ]
      },
      "requirement": "Ensure that documentation defines resource\u2011management strategies for every external system or service the application uses, including databases, file handles, threads, and HTTP connections. This should include resource\u2011release procedures, timeout settings, failure handling, and retry logic specifications.",
      "scope": "web-application",
      "severity": "high",
      "title": "Document resource management strategies for external systems",
      "verify": {
        "tests": [
          "Review documentation for completeness"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "yaml.docker-compose.security.writable-filesystem-service",
          "terraform.aws.security.aws-s3-bucket-public-read-prohibited"
        ]
      },
      "do": [
        "Document all communication needs for the application",
        "Include external services and potential end user-provided locations"
      ],
      "dont": [
        "Neglect documenting communication needs"
      ],
      "id": "CONFIG-COMMUNICATION-DOCUMENTATION-001",
      "refs": {
        "asvs": [
          "V13.1.1"
        ],
        "cwe": [
          "CWE-16"
        ],
        "owasp": [
          "A05:2021"
        ]
      },
      "requirement": "Ensure that all communication needs for the application are documented, including external services which the application relies upon and cases where an end user might be able to provide an external location to which the application will then connect.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Document all communication needs and external services",
      "verify": {
        "tests": [
          "Review documentation for completeness"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "http.response.body: $version"
        ]
      },
      "do": [
        "Configure web server to limit backend component version information"
      ],
      "dont": [
        "Expose detailed version information of backend components"
      ],
      "id": "CONFIG-LIMIT-BACKEND-COMPONENT-001",
      "refs": {
        "asvs": [
          "V13.4.6"
        ],
        "cwe": [
          "CWE-200"
        ],
        "owasp": [
          "A6:2021"
        ]
      },
      "requirement": "Detailed version information of backend components must not be exposed",
      "scope": "web-application",
      "severity": "high",
      "title": "Limit Backend Component Version Information",
      "verify": {
        "tests": [
          "Manually verify that backend component version information is limited"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "yaml.docker-compose.security.writable-filesystem-service",
          "terraform.aws.security.aws-s3-bucket-public-read-prohibited"
        ]
      },
      "do": [
        "Define critical secrets for the application",
        "Establish a schedule for rotating critical secrets"
      ],
      "dont": [
        "Neglect defining critical secrets and rotation schedule"
      ],
      "id": "CONFIG-SECRET-ROTATION-THREAT-MODEL-001",
      "refs": {
        "asvs": [
          "V13.1.4"
        ],
        "cwe": [
          "CWE-16"
        ],
        "owasp": [
          "A05:2021"
        ]
      },
      "requirement": "Ensure that the application's documentation defines the secrets that are critical for the security of the application and a schedule for rotating them, based on the organization's threat model and business requirements.",
      "scope": "web-application",
      "severity": "high",
      "title": "Rotate critical secrets based on threat model",
      "verify": {
        "tests": [
          "Review documentation for completeness"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "http.server.trace.enabled: $true"
        ]
      },
      "do": [
        "Disable HTTP TRACE method in web server configuration"
      ],
      "dont": [
        "Allow HTTP TRACE method"
      ],
      "id": "CONFIG-PREVENT-ENVIRONMENT-DISABLE-002",
      "refs": {
        "asvs": [
          "V13.4.4"
        ],
        "cwe": [
          "CWE-200"
        ],
        "owasp": [
          "A6:2021"
        ]
      },
      "requirement": "The HTTP TRACE method must be disabled in production environments to prevent potential information leakage",
      "scope": "web-application",
      "severity": "medium",
      "title": "Disable HTTP TRACE Method",
      "verify": {
        "tests": [
          "Manually verify that HTTP TRACE method is disabled"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "yaml.docker-compose.security.writable-filesystem-service",
          "terraform.aws.security.aws-s3-bucket-public-read-prohibited"
        ]
      },
      "do": [
        "Use a secrets management solution to securely create, store, control access to, and destroy backend secrets",
        "Follow the principle of least privilege for access to secret assets"
      ],
      "dont": [
        "Store secrets in application source code or build artifacts"
      ],
      "id": "CONFIG-PRIVILEGE-SECRET-MGMT-001",
      "refs": {
        "asvs": [
          "V13.3.1",
          "V13.3.2"
        ],
        "cwe": [
          "CWE-798"
        ],
        "owasp": [
          "A6:2021"
        ]
      },
      "requirement": "Ensure secrets are securely managed using a secrets management solution and adhere to the principle of least privilege.",
      "scope": "web-application/api",
      "severity": "medium",
      "title": "Secret Management Best Practices",
      "verify": {
        "tests": [
          "Verify that secrets are securely managed and access is restricted"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "backend-authentication-missing"
        ]
      },
      "do": [
        "Authenticate all backend communication components",
        "Use mutual TLS or service-to-service authentication",
        "Implement proper certificate management",
        "Monitor backend authentication failures"
      ],
      "dont": [
        "Allow unauthenticated backend communication",
        "Use weak authentication between services",
        "Skip certificate validation in backend calls"
      ],
      "id": "CONFIG-IMPLEMENT-BACKEND-AUTH-001",
      "refs": {
        "asvs": [
          "V9.2.1"
        ],
        "cwe": [
          "CWE-306"
        ],
        "owasp": [
          "A07:2021"
        ]
      },
      "requirement": "Implement authentication mechanisms for all backend communication components to ensure secure inter-service communication.",
      "scope": "web-application",
      "severity": "high",
      "title": "Authenticate backend communication components",
      "verify": {
        "tests": [
          "Verify backend services require authentication",
          "Test certificate validation in backend communication",
          "Validate authentication failure handling"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "yaml.docker-compose.security.writable-filesystem-service",
          "terraform.aws.security.aws-s3-bucket-public-read-prohibited"
        ]
      },
      "do": [
        "Implement an allowlist of trusted resources or systems for backend communication"
      ],
      "dont": [
        "Allow unrestricted outbound requests from the server"
      ],
      "id": "CONFIG-ALLOW-CONFIG-001",
      "refs": {
        "asvs": [
          "V13.2.5"
        ],
        "cwe": [
          "CWE-285"
        ],
        "owasp": [
          "A6:2021"
        ]
      },
      "requirement": "Ensure the web or application server is configured with an allowlist of resources or systems to which the server can send requests or load data or files from.",
      "scope": "web-application/api",
      "severity": "medium",
      "title": "Secure Backend Communication Configuration",
      "verify": {
        "tests": [
          "Verify that only specified resources or systems are allowed for communication"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "yaml.docker-compose.security.writable-filesystem-service",
          "terraform.aws.security.aws-s3-bucket-public-read-prohibited"
        ]
      },
      "do": [
        "Perform all cryptographic operations using an isolated security module"
      ],
      "dont": [
        "Perform cryptographic operations without proper key protection"
      ],
      "id": "CONFIG-KEY-001",
      "refs": {
        "asvs": [
          "V13.3.3"
        ],
        "cwe": [
          "CWE-310"
        ],
        "owasp": [
          "A6:2021"
        ]
      },
      "requirement": "Ensure all cryptographic operations are performed using an isolated security module to protect key material from exposure.",
      "scope": "web-application/api",
      "severity": "high",
      "title": "Secure Cryptographic Operations",
      "verify": {
        "tests": [
          "Verify that cryptographic operations are isolated and key material is protected"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "yaml.docker-compose.security.writable-filesystem-service",
          "terraform.aws.security.aws-s3-bucket-public-read-prohibited"
        ]
      },
      "do": [
        "Disable debug modes for all components in production"
      ],
      "dont": [
        "Allow debug modes to be enabled in production environments"
      ],
      "id": "CONFIG-PREVENT-ENVIRONMENT-DISABLE-001",
      "refs": {
        "asvs": [
          "V13.4.2"
        ],
        "cwe": [
          "CWE-204"
        ],
        "owasp": [
          "A6:2021"
        ]
      },
      "requirement": "Ensure that debug modes are disabled for all components in production environments to prevent exposure of debugging features and information leakage.",
      "scope": "web-application/api",
      "severity": "medium",
      "title": "Disable Debug Modes in Production",
      "verify": {
        "tests": [
          "Verify that debug modes are disabled in production"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "yaml.docker-compose.security.writable-filesystem-service",
          "terraform.aws.security.aws-s3-bucket-public-read-prohibited"
        ]
      },
      "do": [
        "Assign the least necessary privileges to accounts for backend communication"
      ],
      "dont": [
        "Assign excessive privileges to backend communication accounts"
      ],
      "id": "CONFIG-SEC-008",
      "refs": {
        "asvs": [
          "V13.2.2"
        ],
        "cwe": [
          "CWE-16"
        ],
        "owasp": [
          "A05:2021"
        ]
      },
      "requirement": "Ensure that communications between backend application components are performed with accounts assigned the least necessary privileges.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Least privilege for backend communication accounts",
      "verify": {
        "tests": [
          "Review privileges assigned to backend communication accounts"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "yaml.docker-compose.security.writable-filesystem-service",
          "terraform.aws.security.aws-s3-bucket-public-read-prohibited"
        ]
      },
      "do": [
        "Avoid using default credentials for service authentication"
      ],
      "dont": [
        "Use default credentials for service authentication"
      ],
      "id": "CONFIG-SEC-009",
      "refs": {
        "asvs": [
          "V13.2.3"
        ],
        "cwe": [
          "CWE-16"
        ],
        "owasp": [
          "A05:2021"
        ]
      },
      "requirement": "Ensure that if a credential has to be used for service authentication, the credential being used by the consumer is not a default credential (e.g., root/root or admin/admin).",
      "scope": "web-application",
      "severity": "medium",
      "title": "Avoid default credentials for service authentication",
      "verify": {
        "tests": [
          "Review service authentication credentials for default values"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "http.response.body: $file_extension"
        ]
      },
      "do": [
        "Configure web server to serve only specified file extensions"
      ],
      "dont": [
        "Allow serving files with any file extension"
      ],
      "id": "CONFIG-PREVENT-RESTRICT-001",
      "refs": {
        "asvs": [
          "V13.4.7"
        ],
        "cwe": [
          "CWE-200"
        ],
        "owasp": [
          "A6:2021"
        ]
      },
      "requirement": "Web tier should only serve files with specific file extensions to prevent unintentional leakage",
      "scope": "web-application",
      "severity": "high",
      "title": "Restrict File Extensions for Web Tier",
      "verify": {
        "tests": [
          "Manually verify that only specified file extensions are served"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "http.server.directory-listing.enabled: $true"
        ]
      },
      "do": [
        "Disable directory listing functionality in web server configuration"
      ],
      "dont": [
        "Enable directory listing functionality"
      ],
      "id": "CONFIG-RESTRICT-001",
      "refs": {
        "asvs": [
          "V13.4.3"
        ],
        "cwe": [
          "CWE-548"
        ],
        "owasp": [
          "A6:2021"
        ]
      },
      "requirement": "Web servers must not expose directory listings to clients unless explicitly intended",
      "scope": "web-application",
      "severity": "medium",
      "title": "Restrict Directory Listings",
      "verify": {
        "tests": [
          "Manually verify that directory listings are disabled"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "yaml.docker-compose.security.writable-filesystem-service",
          "terraform.aws.security.aws-s3-bucket-public-read-prohibited"
        ]
      },
      "do": [
        "Implement an allowlist for external communications",
        "Define permitted external resources or systems"
      ],
      "dont": [
        "Allow communication with unlisted external resources"
      ],
      "id": "CONFIG-SEC-010",
      "refs": {
        "asvs": [
          "V13.2.4"
        ],
        "cwe": [
          "CWE-16"
        ],
        "owasp": [
          "A05:2021"
        ]
      },
      "requirement": "Ensure that an allowlist is used to define the external resources or systems with which the application is permitted to communicate. This allowlist can be implemented at the application layer, web server, firewall, or a combination of different layers.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Implement allowlist for external communications",
      "verify": {
        "tests": [
          "Review allowlist implementation for external communications"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "http.route.documentation: $true",
          "http.route.monitoring: $true"
        ]
      },
      "do": [
        "Securely restrict access to documentation and monitoring endpoints"
      ],
      "dont": [
        "Expose documentation and monitoring endpoints to unauthorized users"
      ],
      "id": "CONFIG-MONITORING-RESTRICT-001",
      "refs": {
        "asvs": [
          "V13.4.5"
        ],
        "cwe": [
          "CWE-285"
        ],
        "owasp": [
          "A6:2021"
        ]
      },
      "requirement": "Documentation and monitoring endpoints should not be exposed unless explicitly intended",
      "scope": "web-application",
      "severity": "medium",
      "title": "Restrict Documentation and Monitoring Endpoints",
      "verify": {
        "tests": [
          "Manually verify that documentation and monitoring endpoints are restricted"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "python.lang.security.audit.hardcoded-password",
          "javascript.lang.security.audit.hardcoded-secret"
        ]
      },
      "do": [
        "Implement controls to prevent storage of sensitive data in browser storage except for session tokens."
      ],
      "dont": [
        "Allow sensitive data to be stored in browser storage."
      ],
      "id": "DATA-RESTRICT-TOKEN-SESSION-001",
      "refs": {
        "asvs": [
          "V14.3.3"
        ],
        "cwe": [
          "CWE-311"
        ],
        "owasp": [
          "A02:2021"
        ]
      },
      "requirement": "Ensure data stored in browser storage does not contain sensitive data, except for session tokens.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Restricting Sensitive Data in Browser Storage",
      "verify": {
        "tests": [
          "Verify that only session tokens are stored in browser storage."
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "python.lang.security.audit.hardcoded-password",
          "javascript.lang.security.audit.hardcoded-secret"
        ]
      },
      "do": [
        "Include requirements related to general encryption, integrity verification, retention, logging, access controls, database-level encryption, and privacy as per ASVS 14.1.2"
      ],
      "dont": [
        "Omit any sensitive data protection level from having a documented set of protection requirements"
      ],
      "id": "DATA-PROTECT-VERIFY-ENCRYPT-001",
      "refs": {
        "asvs": [
          "V14.1.2"
        ],
        "cwe": [
          "CWE-311"
        ],
        "owasp": [
          "A02:2021"
        ]
      },
      "requirement": "Document protection requirements for all sensitive data protection levels, covering encryption, integrity verification, retention, logging, access controls, database-level encryption, and privacy requirements as per ASVS 14.1.2",
      "scope": "web-application",
      "severity": "medium",
      "title": "Sensitive Data Protection Requirements Documentation",
      "verify": {
        "tests": [
          "Verify that all sensitive data protection levels have documented protection requirements as per ASVS 14.1.2"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "python.lang.security.audit.hardcoded-password",
          "javascript.lang.security.audit.hardcoded-secret"
        ]
      },
      "do": [
        "Prevent sending defined sensitive data to untrusted parties"
      ],
      "dont": [
        "Share sensitive data with untrusted parties"
      ],
      "id": "DATA-PROTECTION-006",
      "refs": {
        "asvs": [
          "V14.2.3"
        ],
        "cwe": [
          "CWE-311"
        ],
        "owasp": [
          "A02:2021"
        ]
      },
      "requirement": "Ensure defined sensitive data is not shared with untrusted parties to prevent unauthorized data collection as per ASVS 14.2.3",
      "scope": "web-application",
      "severity": "medium",
      "title": "Protection Against Untrusted Data Sharing",
      "verify": {
        "tests": [
          "Verify that defined sensitive data is not shared with untrusted parties as per ASVS 14.2.3"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "python.lang.security.audit.hardcoded-password",
          "javascript.lang.security.audit.hardcoded-secret"
        ]
      },
      "do": [
        "Set anti-caching HTTP response header fields like Cache-Control: no-store for sensitive data."
      ],
      "dont": [
        "Allow sensitive data to be cached in browsers."
      ],
      "id": "DATA-PROTECTION-008",
      "refs": {
        "asvs": [
          "V14.3.2"
        ],
        "cwe": [
          "CWE-311"
        ],
        "owasp": [
          "A02:2021"
        ]
      },
      "requirement": "Configure caching mechanisms to only cache appropriate content types and prevent caching of sensitive data.",
      "scope": "web-application",
      "severity": "high",
      "title": "Secure Configuration of Caching Mechanisms",
      "verify": {
        "tests": [
          "Verify that sensitive data is not cached in browser storage."
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "python.lang.security.audit.hardcoded-password",
          "javascript.lang.security.audit.hardcoded-secret"
        ]
      },
      "do": [
        "Implement a process to strip sensitive information from file metadata before storage."
      ],
      "dont": [
        "Store user-submitted files with sensitive metadata intact."
      ],
      "id": "DATA-PROTECTION-002",
      "refs": {
        "asvs": [
          "V14.2.8"
        ],
        "cwe": [
          "CWE-311"
        ],
        "owasp": [
          "A02:2021"
        ]
      },
      "requirement": "Sensitive information must be removed from the metadata of user-submitted files unless storage is explicitly consented to by the user.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Remove sensitive information from user-submitted file metadata",
      "verify": {
        "tests": [
          "Manually verify that sensitive metadata is not present in stored files."
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "python.lang.security.audit.hardcoded-password",
          "javascript.lang.security.audit.hardcoded-secret"
        ]
      },
      "do": [
        "Implement mechanisms to clear authenticated data from client storage upon session termination"
      ],
      "dont": [
        "Leave authenticated data lingering in client storage after session termination"
      ],
      "id": "DATA-PROTECTION-003",
      "refs": {
        "asvs": [
          "V14.3.1"
        ],
        "cwe": [
          "CWE-200"
        ],
        "owasp": [
          "A14:2021"
        ]
      },
      "requirement": "Authenticated data must be cleared from client storage, such as the browser DOM, after the client or session is terminated.",
      "scope": "web-application",
      "severity": "low",
      "title": "Clear authenticated data from client storage",
      "verify": {
        "tests": [
          "Verify authenticated data is cleared from client storage after session termination"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "python.lang.security.audit.hardcoded-password",
          "javascript.lang.security.audit.hardcoded-secret"
        ]
      },
      "do": [
        "Ensure sensitive data is not stored in browser storage"
      ],
      "dont": [
        "Store sensitive data in localStorage, sessionStorage, IndexedDB, or cookies"
      ],
      "id": "DATA-PROTECTION-005",
      "refs": {
        "asvs": [
          "V14.3.3"
        ],
        "cwe": [
          "CWE-200"
        ],
        "owasp": [
          "A14:2021"
        ]
      },
      "requirement": "Data stored in browser storage (e.g., localStorage, sessionStorage, IndexedDB, cookies) must not contain sensitive data, except for session tokens.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Avoid storing sensitive data in browser storage",
      "verify": {
        "tests": [
          "Verify sensitive data is not stored in browser storage, except for session tokens"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "python.lang.security.audit.hardcoded-password",
          "javascript.lang.security.audit.hardcoded-secret"
        ]
      },
      "do": [
        "Implement automated data retention policies for sensitive information"
      ],
      "dont": [
        "Retain outdated or unnecessary sensitive data"
      ],
      "id": "DATA-PROTECTION-001",
      "refs": {
        "asvs": [
          "V14.2.7"
        ],
        "cwe": [
          "CWE-200"
        ],
        "owasp": [
          "A14:2021"
        ]
      },
      "requirement": "Sensitive information must be subject to data retention classification to ensure outdated or unnecessary data is deleted automatically, on a defined schedule, or as the situation requires.",
      "scope": "web-application",
      "severity": "high",
      "title": "Sensitive information data retention",
      "verify": {
        "tests": [
          "Verify data retention policies are in place and functioning correctly"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "sensitive-data-identification"
        ]
      },
      "do": [
        "Implement a process to identify and classify sensitive data",
        "Assign appropriate protection levels based on sensitivity"
      ],
      "dont": [
        "Neglect to classify sensitive data"
      ],
      "id": "DATA-PROTECT-001",
      "refs": {
        "asvs": [
          "V14.1.1"
        ],
        "cwe": [
          "CWE-200"
        ],
        "owasp": [
          "A3:2021"
        ]
      },
      "requirement": "Identify and classify all sensitive data processed by the application into protection levels, considering data protection and privacy regulations.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Sensitive Data Identification and Classification",
      "verify": {
        "tests": [
          "Verify sensitive data classification process"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "minimum-disclosure"
        ]
      },
      "do": [
        "Disclose only necessary sensitive data",
        "Mask complete data unless explicitly needed"
      ],
      "dont": [
        "Expose unnecessary sensitive data"
      ],
      "id": "DATA-PROTECTION-009",
      "refs": {
        "asvs": [
          "V14.2.6"
        ],
        "cwe": [
          "CWE-200"
        ],
        "owasp": [
          "A6:2021"
        ]
      },
      "requirement": "Only disclose the minimum required sensitive data for application functionality, and mask complete data unless explicitly requested.",
      "scope": "web-application",
      "severity": "high",
      "title": "Minimum Disclosure of Sensitive Data",
      "verify": {
        "tests": [
          "Verify minimum disclosure of sensitive data"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "python.lang.security.audit.hardcoded-password",
          "javascript.lang.security.audit.hardcoded-secret"
        ]
      },
      "do": [
        "Implement mechanisms to securely purge cached sensitive data after it is no longer needed."
      ],
      "dont": [
        "Cache sensitive data in server components without proper purging mechanisms."
      ],
      "id": "DATA-SECURE-DATA-CACHING-001",
      "refs": {
        "asvs": [
          "V14.2.7"
        ],
        "cwe": [
          "CWE-311"
        ],
        "owasp": [
          "A02:2021"
        ]
      },
      "requirement": "Ensure sensitive data is not cached in server components, or securely purge cached data after use.",
      "scope": "web-application",
      "severity": "high",
      "title": "Secure Data Caching and Purging",
      "verify": {
        "tests": [
          "Test the purging mechanisms for cached sensitive data."
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "data-protection-controls"
        ]
      },
      "do": [
        "Implement encryption, integrity verification, retention, access controls, and privacy controls for sensitive data"
      ],
      "dont": [
        "Neglect to implement defined data protection controls"
      ],
      "id": "DATA-PROTECTION-007",
      "refs": {
        "asvs": [
          "V14.2.4"
        ],
        "cwe": [
          "CWE-311"
        ],
        "owasp": [
          "A6:2021"
        ]
      },
      "requirement": "Implement defined controls related to encryption, integrity verification, retention, access controls, and privacy for sensitive data.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Implementation of Defined Data Protection Controls",
      "verify": {
        "tests": [
          "Verify implementation of data protection controls"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "python.lang.security.audit.hardcoded-password",
          "javascript.lang.security.audit.hardcoded-secret"
        ]
      },
      "do": [
        "Set anti-caching headers for responses containing sensitive data"
      ],
      "dont": [
        "Allow sensitive data to be cached in browsers"
      ],
      "id": "DATA-PROTECTION-004",
      "refs": {
        "asvs": [
          "V14.3.2"
        ],
        "cwe": [
          "CWE-200"
        ],
        "owasp": [
          "A14:2021"
        ]
      },
      "requirement": "Sufficient anti-caching HTTP response header fields (e.g., Cache-Control: no-store) must be set to prevent sensitive data from being cached in browsers.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Set anti-caching headers for sensitive data",
      "verify": {
        "tests": [
          "Verify anti-caching headers are set for sensitive data responses"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "sensitive-data-http-leakage"
        ]
      },
      "do": [
        "Avoid sending sensitive data in HTTP message body or headers",
        "Do not include sensitive information in URLs or query strings"
      ],
      "dont": [
        "Transmit sensitive data in clear text over HTTP"
      ],
      "id": "DATA-PREVENT-001",
      "refs": {
        "asvs": [
          "V14.2.1"
        ],
        "cwe": [
          "CWE-200"
        ],
        "owasp": [
          "A6:2021"
        ]
      },
      "requirement": "Ensure sensitive data is not sent in HTTP message body or header fields, and avoid including sensitive information in URLs or query strings.",
      "scope": "web-application",
      "severity": "high",
      "title": "Prevention of Sensitive Data Leakage via HTTP",
      "verify": {
        "tests": [
          "Verify sensitive data transmission over HTTP"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "function-level-access"
        ]
      },
      "do": [
        "Implement function-level access restrictions"
      ],
      "dont": [
        "Allow unauthorized access to functions"
      ],
      "id": "AUTHZ-RESTRICT-PERMISSION-AUTHZ-005",
      "refs": {
        "asvs": [
          "V8.2.1"
        ],
        "cwe": [
          "CWE-284"
        ],
        "owasp": [
          "A5:2021"
        ]
      },
      "requirement": "Restrict function-level access to consumers with explicit permissions.",
      "scope": "web-application",
      "severity": "low",
      "title": "Authorization Design - Function-Level Access",
      "verify": {
        "tests": [
          "Verify function-level access restrictions"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-jwt-not-revoked",
          "python.django.security.audit.avoid-csrf-disable"
        ]
      },
      "do": [
        "Implement adaptive security controls for authentication",
        "Consider environmental and contextual attributes"
      ],
      "dont": [
        "Rely solely on static security controls"
      ],
      "id": "AUTHZ-AUTH-ENVIRONMENT-001",
      "refs": {
        "asvs": [
          "V8.4.2"
        ],
        "cwe": [
          "CWE-285"
        ],
        "owasp": [
          "A01:2021"
        ]
      },
      "requirement": "Implement adaptive security controls based on environmental and contextual attributes for authentication.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Adaptive Security Controls",
      "verify": {
        "tests": [
          "Validate access control enforcement and privilege management"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-jwt-not-revoked",
          "python.django.security.audit.avoid-csrf-disable"
        ]
      },
      "do": [
        "Document environmental and contextual attributes used for security decisions",
        "Include attributes like time of day, user location, IP address, and device"
      ],
      "dont": [
        "Do not overlook the impact of environmental factors on security decisions"
      ],
      "id": "AUTH-DESIGN-001",
      "refs": {
        "asvs": [
          "V8.1.3"
        ],
        "cwe": [
          "CWE-285"
        ],
        "owasp": [
          "A01:2021"
        ]
      },
      "requirement": "Define environmental and contextual attributes used in security decisions, including authentication and authorization.",
      "scope": "web-application",
      "severity": "low",
      "title": "Environmental and Contextual Attributes in Authorization",
      "verify": {
        "tests": [
          "Review documentation for completeness of attributes"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-jwt-not-revoked",
          "python.django.security.audit.avoid-csrf-disable"
        ]
      },
      "do": [
        "Apply changes to authorization decisions immediately",
        "Implement controls to alert and revert unauthorized actions"
      ],
      "dont": [
        "Delay applying changes to authorization decisions"
      ],
      "id": "AUTH-OPER-002",
      "refs": {
        "asvs": [
          "V8.3.2"
        ],
        "cwe": [
          "CWE-285"
        ],
        "owasp": [
          "A01:2021"
        ]
      },
      "requirement": "Changes to values on which authorization decisions are made must be applied immediately. Implement mitigating controls to alert when a consumer performs an action when they are no longer authorized to do so and revert the change.",
      "scope": "web-application",
      "severity": "high",
      "title": "Apply immediate changes to authorization decisions",
      "verify": {
        "tests": [
          "Validate access control enforcement and privilege management"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-jwt-not-revoked",
          "python.django.security.audit.avoid-csrf-disable"
        ]
      },
      "do": [
        "Specify clear rules for function-level and data-specific access restrictions",
        "Document how consumer permissions and resource attributes are used in authorization decisions",
        "Include environmental and contextual attributes in the documentation"
      ],
      "dont": [
        "Do not rely solely on user roles for access control"
      ],
      "id": "AUTHZ-RESTRICT-PERMISSION-AUTHZ-004",
      "refs": {
        "asvs": [
          "V8.1.1"
        ],
        "cwe": [
          "CWE-285"
        ],
        "owasp": [
          "A01:2021"
        ]
      },
      "requirement": "Define rules for restricting function-level and data-specific access based on consumer permissions and resource attributes.",
      "scope": "web-application",
      "severity": "high",
      "title": "Authorization Documentation and Rules",
      "verify": {
        "tests": [
          "Review authorization documentation for completeness and accuracy"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-jwt-not-revoked",
          "python.django.security.audit.avoid-csrf-disable"
        ]
      },
      "do": [
        "Implement access control based on originating subject's permissions"
      ],
      "dont": [
        "Base access control on intermediary permissions"
      ],
      "id": "AUTH-OPER-003",
      "refs": {
        "asvs": [
          "V8.3.3"
        ],
        "cwe": [
          "CWE-285"
        ],
        "owasp": [
          "A8:2021"
        ]
      },
      "requirement": "Access to an object should be based on the originating subject's permissions, not on any intermediary or service acting on their behalf.",
      "scope": "web-application/api",
      "severity": "high",
      "title": "Subject-based access control",
      "verify": {
        "tests": [
          "Test access control based on subject's permissions"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-jwt-not-revoked",
          "python.django.security.audit.avoid-csrf-disable"
        ]
      },
      "do": [
        "Specify clear rules for field-level access restrictions",
        "Document how consumer permissions and resource attributes are used for field-level authorization",
        "Consider other attribute values of the data object, such as state or status"
      ],
      "dont": [
        "Do not allow unrestricted access to sensitive fields"
      ],
      "id": "AUTHZ-RESTRICT-PERMISSION-ACCESS-001",
      "refs": {
        "asvs": [
          "V8.1.2"
        ],
        "cwe": [
          "CWE-285"
        ],
        "owasp": [
          "A01:2021"
        ]
      },
      "requirement": "Define rules for field-level access restrictions based on consumer permissions and resource attributes.",
      "scope": "web-application",
      "severity": "high",
      "title": "Field-Level Access Restrictions",
      "verify": {
        "tests": [
          "Review field-level access rules for compliance"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-jwt-not-revoked",
          "python.django.security.audit.avoid-csrf-disable"
        ]
      },
      "do": [
        "Implement multiple layers of security for administrative interfaces"
      ],
      "dont": [
        "Rely solely on network location or trusted endpoints for authorization"
      ],
      "id": "AUTH-OTHER-002",
      "refs": {
        "asvs": [
          "V8.4.2"
        ],
        "cwe": [
          "CWE-285"
        ],
        "owasp": [
          "A8:2021"
        ]
      },
      "requirement": "Access to administrative interfaces should incorporate multiple layers of security, including continuous consumer identity verification, device security posture assessment, and contextual risk analysis.",
      "scope": "web-application/api",
      "severity": "high",
      "title": "Secure access to administrative interfaces",
      "verify": {
        "tests": [
          "Test security layers for administrative interfaces"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-jwt-not-revoked",
          "python.django.security.audit.avoid-csrf-disable"
        ]
      },
      "do": [
        "Implement authorization checks on the server-side"
      ],
      "dont": [
        "Rely solely on client-side authorization logic"
      ],
      "id": "AUTH-OPER-001",
      "refs": {
        "asvs": [
          "V8.3.1"
        ],
        "cwe": [
          "CWE-285"
        ],
        "owasp": [
          "A8:2021"
        ]
      },
      "requirement": "Enforce authorization rules at a trusted service layer and avoid relying on controls that an untrusted consumer could manipulate, such as client-side JavaScript.",
      "scope": "web-application/api",
      "severity": "low",
      "title": "Enforce authorization rules at a trusted service layer",
      "verify": {
        "tests": [
          "Test server-side authorization enforcement"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-jwt-not-revoked",
          "python.django.security.audit.avoid-csrf-disable"
        ]
      },
      "do": [
        "Implement cross-tenant controls"
      ],
      "dont": [
        "Allow consumer operations to affect unauthorized tenants"
      ],
      "id": "AUTH-OTHER-001",
      "refs": {
        "asvs": [
          "V8.4.1"
        ],
        "cwe": [
          "CWE-285"
        ],
        "owasp": [
          "A8:2021"
        ]
      },
      "requirement": "Multi-tenant applications must use cross-tenant controls to prevent consumer operations from affecting tenants with which they do not have permissions to interact.",
      "scope": "web-application/api",
      "severity": "medium",
      "title": "Cross-tenant controls for multi-tenant applications",
      "verify": {
        "tests": [
          "Test cross-tenant controls functionality"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "field-level-access"
        ]
      },
      "do": [
        "Implement field-level access restrictions"
      ],
      "dont": [
        "Allow unauthorized access to specific fields"
      ],
      "id": "AUTHZ-RESTRICT-PERMISSION-AUTHZ-003",
      "refs": {
        "asvs": [
          "V8.2.3"
        ],
        "cwe": [
          "CWE-284"
        ],
        "owasp": [
          "A7:2021"
        ]
      },
      "requirement": "Restrict field-level access to consumers with explicit permissions to mitigate BOPLA.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Authorization Design - Field-Level Access",
      "verify": {
        "tests": [
          "Verify field-level access restrictions"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-jwt-not-revoked",
          "python.django.security.audit.avoid-csrf-disable"
        ]
      },
      "do": [
        "Implement adaptive controls for authentication based on consumer attributes",
        "Consider attributes like time of day, location, IP address, and device"
      ],
      "dont": [
        "Do not rely solely on static authentication mechanisms"
      ],
      "id": "AUTH-DESIGN-002",
      "refs": {
        "asvs": [
          "V8.1.4"
        ],
        "cwe": [
          "CWE-285"
        ],
        "owasp": [
          "A01:2021"
        ]
      },
      "requirement": "Implement adaptive security controls based on environmental and contextual attributes for authentication decisions.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Adaptive Security Controls for Authentication",
      "verify": {
        "tests": [
          "Test adaptive controls for authentication effectiveness"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.express.security.audit.express-jwt-not-revoked",
          "python.django.security.audit.avoid-csrf-disable"
        ]
      },
      "do": [
        "Ensure explicit permissions are required for data-specific access",
        "Mitigate IDOR and BOLA risks by enforcing access controls",
        "Consider contextual attributes in data-specific authorization"
      ],
      "dont": [
        "Do not rely on client-side controls for data-specific access"
      ],
      "id": "AUTHZ-RESTRICT-PERMISSION-AUTHZ-001",
      "refs": {
        "asvs": [
          "V8.2.2"
        ],
        "cwe": [
          "CWE-285"
        ],
        "owasp": [
          "A01:2021"
        ]
      },
      "requirement": "Restrict data-specific access to consumers with explicit permissions to mitigate IDOR and BOLA.",
      "scope": "web-application",
      "severity": "high",
      "title": "Authorization Design - Data-Specific Access",
      "verify": {
        "tests": [
          "Test data-specific access controls for effectiveness"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "trusted-certificate-internal-services"
        ]
      },
      "do": [
        "Use trusted certificates for internal service TLS connections"
      ],
      "dont": [
        "Trust all certificates for internal service communication"
      ],
      "id": "NET-TLS-CERT-001",
      "refs": {
        "asvs": [
          "V12.3.4"
        ],
        "cwe": [
          "CWE-295"
        ],
        "owasp": [
          "A06:2021"
        ]
      },
      "requirement": "TLS connections between internal services must use trusted certificates. Configure consuming services to only trust specific internal CAs and self-signed certificates.",
      "scope": "infrastructure",
      "severity": "high",
      "title": "Ensure trusted certificates for internal service TLS connections",
      "verify": {
        "tests": [
          "Verify that internal service TLS connections use trusted certificates"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "python.requests.security.disabled-cert-validation",
          "javascript.lang.security.audit.tls-min-version",
          "generic.secrets.security.detected-secret"
        ]
      },
      "do": [
        "Enable recommended and strong cipher suites, with the strongest set as preferred.",
        "Ensure all supported cipher suites provide forward secrecy, especially for L3 applications."
      ],
      "dont": [
        "Allow weak or deprecated cipher suites."
      ],
      "id": "NET-TLS-CIPHER-SUITES-001",
      "refs": {
        "asvs": [
          "V12.1.2"
        ],
        "cwe": [
          "CWE-326"
        ],
        "owasp": [
          "A06:2021"
        ]
      },
      "requirement": "Only recommended cipher suites are enabled, with the strongest cipher suites set as preferred. L3 applications must only support cipher suites which provide forward secrecy.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Enable Strong, Recommended Cipher Suites",
      "verify": {
        "tests": [
          "Verify that only recommended and strong cipher suites are enabled.",
          "Verify that cipher suites providing forward secrecy are preferred."
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "tls-client-certificate-validation"
        ]
      },
      "do": [
        "Implement certificate validation in TLS clients"
      ],
      "dont": [
        "Ignore certificate validation errors"
      ],
      "id": "NET-TLS-CERT-002",
      "refs": {
        "asvs": [
          "V12.3.2"
        ],
        "cwe": [
          "CWE-295"
        ],
        "owasp": [
          "A06:2021"
        ]
      },
      "requirement": "TLS clients must validate certificates received before communicating with a TLS server.",
      "scope": "infrastructure",
      "severity": "medium",
      "title": "Ensure TLS clients validate certificates before communicating with a server",
      "verify": {
        "tests": [
          "Manually verify that TLS clients validate certificates"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "python.requests.security.disabled-cert-validation",
          "javascript.lang.security.audit.tls-min-version"
        ]
      },
      "do": [
        "Enable TLS 1.2 and TLS 1.3 as preferred options"
      ],
      "dont": [
        "Allow outdated or insecure TLS versions"
      ],
      "id": "NET-TLS-LATEST-VERSIONS-001",
      "refs": {
        "asvs": [
          "V12.1.1"
        ],
        "cwe": [
          "CWE-326"
        ],
        "owasp": [
          "A06:2021"
        ]
      },
      "requirement": "Only the latest recommended versions of the TLS protocol (e.g., TLS 1.2 and TLS 1.3) are enabled for secure communication.",
      "scope": "web-application",
      "severity": "high",
      "title": "Enable latest TLS versions for secure communication",
      "verify": {
        "tests": [
          "Manually verify that only TLS 1.2 and TLS 1.3 are enabled"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "generic.secrets.security.detected-secret"
        ]
      },
      "do": [
        "Enable OCSP Stapling or equivalent mechanism"
      ],
      "dont": [
        "Neglect certification revocation mechanisms"
      ],
      "id": "NET-CERTIFICATE-REVOCATION-OCSP-001",
      "refs": {
        "asvs": [
          "V12.1.4"
        ],
        "cwe": [
          "CWE-346"
        ],
        "owasp": [
          "A06:2021"
        ]
      },
      "requirement": "Proper certification revocation mechanisms, such as Online Certificate Status Protocol (OCSP) Stapling, are enabled and configured.",
      "scope": "web-application",
      "severity": "high",
      "title": "Enable Certification Revocation",
      "verify": {
        "tests": [
          "Verify that certification revocation mechanisms are enabled"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "strong-authentication-intra-service"
        ]
      },
      "do": [
        "Implement strong authentication for intra-service communications"
      ],
      "dont": [
        "Allow insecure authentication methods for intra-service communication"
      ],
      "id": "NETWORK-SEC-004",
      "refs": {
        "asvs": [
          "V12.3.5"
        ],
        "cwe": [
          "CWE-287"
        ],
        "owasp": [
          "A06:2021"
        ]
      },
      "requirement": "Ensure that services communicating internally within a system use strong authentication to verify each endpoint. Employ strong authentication methods like TLS client authentication using public-key infrastructure.",
      "scope": "infrastructure",
      "severity": "high",
      "title": "Implement strong authentication for intra-service communications",
      "verify": {
        "tests": [
          "Verify strong authentication implementation for intra-service communications"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "python.requests.security.disabled-cert-validation",
          "javascript.lang.security.audit.tls-min-version"
        ]
      },
      "do": [
        "Implement TLS for all internal service communication",
        "Configure consuming services to trust specific internal CAs and self-signed certificates",
        "Employ strong authentication methods for intra-service communications",
        "Consider using a service mesh for microservice architectures to enhance security"
      ],
      "dont": [
        "Allow insecure or unencrypted communication between internal services"
      ],
      "id": "NET-TLS-INTERNAL-SERVICE-ENCRYPTION-001",
      "refs": {
        "asvs": [
          "V12.3.3",
          "V12.3.4",
          "V12.3.5"
        ],
        "cwe": [
          "CWE-295"
        ],
        "owasp": [
          "A06:2021"
        ]
      },
      "requirement": "Use TLS for all connectivity between internal, HTTP-based services within the application to prevent insecure or unencrypted communications.",
      "scope": "web-application",
      "severity": "high",
      "title": "Ensure TLS for internal service communication",
      "verify": {
        "tests": [
          "Verify TLS implementation for internal service communication",
          "Verify trust configuration for internal CAs and self-signed certificates",
          "Verify strong authentication methods for intra-service communications",
          "Consider using a service mesh for microservice architectures"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "generic.secrets.security.detected-secret"
        ]
      },
      "do": [
        "Ensure mTLS client certificates are trusted"
      ],
      "dont": [
        "Accept untrusted mTLS client certificates"
      ],
      "id": "NET-MTLS-CLIENT-CERTIFICATE-VALIDATION-001",
      "refs": {
        "asvs": [
          "V12.1.3"
        ],
        "cwe": [
          "CWE-295"
        ],
        "owasp": [
          "A06:2021"
        ]
      },
      "requirement": "Validate that mTLS client certificates are trusted before using the certificate identity for authentication or authorization.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Validate mTLS Client Certificates",
      "verify": {
        "tests": [
          "Verify that mTLS client certificates are validated"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "generic.secrets.security.detected-secret"
        ]
      },
      "do": [
        "Enable Encrypted Client Hello (ECH)"
      ],
      "dont": [
        "Expose sensitive metadata during TLS handshake"
      ],
      "id": "NET-ENCRYPTED-CLIENT-HELLO-001",
      "refs": {
        "asvs": [
          "V12.1.5"
        ],
        "cwe": [
          "CWE-200"
        ],
        "owasp": [
          "A06:2021"
        ]
      },
      "requirement": "Enable Encrypted Client Hello (ECH) in the application's TLS settings to prevent exposure of sensitive metadata, such as the Server Name Indication (SNI), during TLS handshake processes.",
      "scope": "web-application",
      "severity": "high",
      "title": "Enable Encrypted Client Hello",
      "verify": {
        "tests": [
          "Verify that ECH is enabled"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "tls-internal-service-communication"
        ]
      },
      "do": [
        "Implement TLS for internal service communication"
      ],
      "dont": [
        "Allow insecure or unencrypted communication between internal services"
      ],
      "id": "NET-TLS-ENCRYPT-001",
      "refs": {
        "asvs": [
          "V12.3.3"
        ],
        "cwe": [
          "CWE-319"
        ],
        "owasp": [
          "A06:2021"
        ]
      },
      "requirement": "Use TLS or another appropriate transport encryption mechanism for all connectivity between internal, HTTP-based services within the application, and do not fall back to insecure or unencrypted communications.",
      "scope": "infrastructure",
      "severity": "high",
      "title": "Ensure secure transport encryption for internal service communication",
      "verify": {
        "tests": [
          "Verify that internal service communication is encrypted"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.security.dom-based-xss",
          "python.django.security.audit.xss.direct-use-of-httpresp-write",
          "javascript.browser.security.audit.dom-based-xss",
          "java.spring.security.audit.spring-xss"
        ]
      },
      "do": [
        "Use HTML encoding followed by JavaScript encoding for untrusted data in HTML subcontext",
        "Utilize ESAPI or similar libraries for encoding untrusted data"
      ],
      "dont": [
        "Do not directly insert untrusted data into HTML subcontext without proper encoding"
      ],
      "id": "DOM-XSS-PREVENTION-RULE1",
      "refs": {
        "cwe": [
          "CWE-79"
        ],
        "owasp": [
          "A7:2021",
          "A2:2021"
        ]
      },
      "requirement": "HTML escape and then JavaScript escape all untrusted data before inserting into HTML subcontext within the execution context to prevent DOM based XSS vulnerabilities.",
      "scope": "web-application",
      "severity": "high",
      "title": "HTML and JavaScript Encoding for Untrusted Data in HTML Subcontext",
      "verify": {
        "tests": [
          "Scan codebase to ensure all untrusted data in HTML subcontext is properly encoded"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.security.dom-based-xss",
          "python.django.security.audit.xss.direct-use-of-httpresp-write",
          "javascript.browser.security.audit.dom-based-xss",
          "java.spring.security.audit.spring-xss"
        ]
      },
      "do": [
        "Minimize usage of untrusted data in event handlers and JavaScript code subcontexts",
        "Prefer safe assignment properties like textContent for populating the DOM with untrusted data"
      ],
      "dont": [
        "Do not directly insert untrusted data into event handlers or JavaScript code subcontexts"
      ],
      "id": "DOM-XSS-PREVENTION-RULE3",
      "refs": {
        "cwe": [
          "CWE-79"
        ],
        "owasp": [
          "A7:2021",
          "A2:2021"
        ]
      },
      "requirement": "Avoid including untrusted data in event handler and JavaScript code subcontexts within an execution context to prevent DOM based XSS vulnerabilities.",
      "scope": "web-application",
      "severity": "high",
      "title": "Avoid Untrusted Data in Event Handler and JavaScript Code Subcontexts",
      "verify": {
        "tests": [
          "Review codebase to ensure absence of untrusted data in event handlers and JavaScript code subcontexts"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.react.security.react-dangerously-set-inner-html",
          "javascript.angular.security.angular-bypass-security-trust",
          "javascript.lit.security.lit-unsafe-html"
        ]
      },
      "do": [
        "Follow framework best practices for templating, auto-escaping, and output encoding",
        "Be cautious of using escape hatches that directly manipulate the DOM",
        "Avoid using insecure functions like React's dangerouslySetInnerHTML or Angular's bypassSecurityTrustAs*",
        "Regularly update framework plugins and components to mitigate XSS risks"
      ],
      "dont": [
        "Use escape hatches without understanding their security implications",
        "Rely solely on framework protections without considering additional security measures"
      ],
      "id": "XSS-FRAMEWORK-001",
      "refs": {
        "owasp": [
          "A07:2021",
          "A08:2021",
          "A09:2021",
          "A10:2021"
        ]
      },
      "requirement": "Developers using modern web frameworks like React, Angular, or Lit must understand how these frameworks prevent XSS vulnerabilities and be aware of potential gaps in security mechanisms.",
      "scope": "web-application",
      "severity": "high",
      "title": "Understand XSS prevention mechanisms in modern web frameworks",
      "verify": {
        "tests": [
          "Review framework-specific XSS prevention guidelines and ensure compliance",
          "Perform code reviews to identify insecure usage of escape hatches"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "http.cookie.samesite-strict",
          "http.cookie.samesite-lax",
          "python.django.security.audit.session-cookie-secure-false",
          "python.django.security.audit.session-cookie-httponly-false",
          "java.spring.security.audit.spring-csrf-disabled"
        ],
        "trufflehog": [
          "SameSite Cookie Attribute",
          "Basic Auth"
        ]
      },
      "do": [
        "Set SameSite attribute to 'strict' for session cookies to prevent them from being sent in cross-origin requests",
        "Consider using SameSite attribute 'lax' for session cookies to allow them in top-level navigations and safe HTTP methods"
      ],
      "dont": [
        "Do not solely rely on SameSite attribute for Clickjacking defense, use in conjunction with other mechanisms"
      ],
      "id": "CLICKJACKING-DEFENSE-003",
      "refs": {
        "asvs": [
          "V6.1.1",
          "V6.1.2"
        ],
        "cwe": [
          "CWE-693",
          "CWE-1021"
        ],
        "owasp": [
          "A6:2021"
        ],
        "standards": [
          "RFC 6265bis"
        ]
      },
      "requirement": "Mark session cookies with SameSite attribute as 'strict' or 'lax' to prevent them from being included in requests made to a page within an iframe. This helps defend against Clickjacking attacks by ensuring that authenticated sessions are not vulnerable to being hijacked.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Secure session cookies with SameSite attribute to mitigate Clickjacking",
      "verify": {
        "tests": [
          "Verify session cookies are marked with SameSite attribute as 'strict' or 'lax'",
          "Test that session cookies are not included in requests within iframes"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.security.dom-based-xss",
          "python.django.security.audit.xss.direct-use-of-httpresp-write",
          "javascript.browser.security.audit.dom-based-xss",
          "java.spring.security.audit.spring-xss"
        ]
      },
      "do": [
        "Use JavaScript encoding for untrusted data in HTML attribute subcontext",
        "Avoid unnecessary HTML attribute encoding in execution context"
      ],
      "dont": [
        "Do not double-encode untrusted data in HTML attribute subcontext"
      ],
      "id": "DOM-XSS-PREVENTION-RULE2",
      "refs": {
        "cwe": [
          "CWE-79"
        ],
        "owasp": [
          "A7:2021",
          "A2:2021"
        ]
      },
      "requirement": "JavaScript escape untrusted data before inserting into HTML attribute subcontext within the execution context to prevent DOM based XSS vulnerabilities.",
      "scope": "web-application",
      "severity": "medium",
      "title": "JavaScript Escape for Untrusted Data in HTML Attribute Subcontext",
      "verify": {
        "tests": [
          "Check codebase to confirm proper JavaScript encoding for HTML attribute subcontext"
        ]
      }
    },
    {
      "detect": {
        "custom": [
          "Manual review of HTML sanitization implementation"
        ]
      },
      "do": [
        "Use DOMPurify library for HTML sanitization",
        "Regularly patch and update HTML sanitization libraries",
        "Ensure sanitized content is not modified afterwards to maintain security"
      ],
      "dont": [
        "Rely solely on output encoding for user-generated HTML content",
        "Modify sanitized content after applying HTML sanitization"
      ],
      "id": "XSS-HTML-SANITIZATION-003",
      "refs": {
        "owasp": [
          "A05:2021",
          "A06:2021"
        ]
      },
      "requirement": "When allowing users to author HTML content, utilize HTML sanitization libraries like DOMPurify to strip dangerous HTML and prevent XSS attacks.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Implement HTML sanitization for user-generated content",
      "verify": {
        "tests": [
          "Test user-generated HTML content with known XSS payloads",
          "Verify that DOMPurify or similar library is effectively sanitizing input"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "generic.xss.security.unsafe-output-encoding",
          "javascript.security.unsafe-javascript-context",
          "css.security.unsafe-css-context"
        ]
      },
      "do": [
        "Use HTML entity encoding for HTML contexts",
        "Apply HTML attribute encoding for HTML attribute contexts",
        "Utilize JavaScript encoding for JavaScript contexts",
        "Implement CSS hex encoding for CSS contexts",
        "Use URL encoding for URL contexts"
      ],
      "dont": [
        "Display user input without proper encoding in any context"
      ],
      "id": "XSS-OUTPUT-ENCODING-002",
      "refs": {
        "owasp": [
          "A01:2021",
          "A02:2021",
          "A03:2021",
          "A04:2021"
        ]
      },
      "requirement": "Ensure all user input displayed in HTML, HTML attribute, JavaScript, CSS, and URL contexts is properly encoded to prevent XSS vulnerabilities.",
      "scope": "web-application",
      "severity": "high",
      "title": "Implement proper output encoding for different contexts",
      "verify": {
        "tests": [
          "Automated scanning to detect missing or improper output encoding",
          "Manual code review to verify correct encoding implementation"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "http.response-header.x-frame-options-deny",
          "http.response-header.x-frame-options-sameorigin",
          "http.response-header.x-frame-options-allow-from",
          "python.django.security.audit.xss-filter-disabled",
          "python.flask.security.audit.flask-cors-origin-wildcard",
          "java.spring.security.audit.spring-security-headers"
        ],
        "trufflehog": [
          "X-Frame-Options"
        ]
      },
      "do": [
        "Set X-Frame-Options header to DENY to prevent any domain from framing the content",
        "Set X-Frame-Options header to SAMEORIGIN to only allow the current site to frame the content",
        "Use ALLOW-FROM uri to permit specific URIs to frame the page (deprecated, check browser support)"
      ],
      "dont": [
        "Do not rely solely on meta-tags for X-Frame-Options, apply the header in HTTP responses"
      ],
      "id": "CLICKJACKING-DEFENSE-001",
      "refs": {
        "asvs": [
          "V6.1.1",
          "V6.1.2"
        ],
        "cwe": [
          "CWE-693",
          "CWE-1021"
        ],
        "owasp": [
          "A6:2021"
        ],
        "standards": [
          "RFC 7034"
        ]
      },
      "requirement": "Set the X-Frame-Options HTTP response header to DENY, SAMEORIGIN, or ALLOW-FROM uri to prevent the browser from loading the page in a frame. This helps defend against Clickjacking attacks by ensuring content is not embedded into other sites.",
      "scope": "web-application",
      "severity": "high",
      "title": "Implement X-Frame-Options header to prevent Clickjacking",
      "verify": {
        "tests": [
          "Verify X-Frame-Options header is correctly set in HTTP responses",
          "Test that the page cannot be framed in different domains"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "http.response-header.content-security-policy-frame-ancestors-none",
          "http.response-header.content-security-policy-frame-ancestors-self",
          "http.response-header.content-security-policy-frame-ancestors-specific",
          "python.django.security.audit.session-cookie-secure-false",
          "python.django.security.audit.session-cookie-httponly-false",
          "java.spring.security.audit.spring-csrf-disabled"
        ],
        "trufflehog": [
          "Content-Security-Policy",
          "Basic Auth"
        ]
      },
      "do": [
        "Use frame-ancestors 'none' to prevent any domain from framing the content",
        "Specify frame-ancestors 'self' to only allow the current site to frame the content",
        "Authorize specific domains using frame-ancestors directive"
      ],
      "dont": [
        "Do not forget to include the frame-ancestors directive in the Content-Security-Policy header"
      ],
      "id": "CLICKJACKING-DEFENSE-002",
      "refs": {
        "asvs": [
          "V6.1.1",
          "V6.1.2"
        ],
        "cwe": [
          "CWE-693",
          "CWE-1021"
        ],
        "owasp": [
          "A6:2021"
        ],
        "standards": [
          "W3C CSP Level 2"
        ]
      },
      "requirement": "Implement the frame-ancestors directive in Content-Security-Policy HTTP response header to control which domains are allowed to render a page in a frame or iframe. This helps defend against Clickjacking attacks by preventing content from being embedded into unauthorized sites.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Utilize Content Security Policy (CSP) frame-ancestors to prevent Clickjacking",
      "verify": {
        "tests": [
          "Verify Content-Security-Policy header includes frame-ancestors directive",
          "Test that unauthorized domains cannot frame the page"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "crypto.key-hardcoded",
          "generic.secrets.security.detected-hardcoded-key",
          "crypto.weak-crypto"
        ]
      },
      "do": [
        "Implement approved cryptographic algorithms for key exchange (e.g., Diffie-Hellman) with secure parameters"
      ],
      "dont": [
        "Use insecure key exchange algorithms"
      ],
      "id": "CRYPTO-PREVENT-KEY-001",
      "refs": {
        "asvs": [
          "V11.6.2"
        ],
        "cwe": [
          "CWE-327",
          "CWE-328",
          "CWE-329"
        ],
        "owasp": [
          "A10:2021"
        ]
      },
      "requirement": "Use approved cryptographic algorithms for key exchange with secure parameters to prevent cryptographic breaks",
      "scope": "web-application",
      "severity": "high",
      "title": "Approved Key Exchange Algorithms",
      "verify": {
        "tests": [
          "Verify implementation meets security requirements"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "crypto.key-hardcoded",
          "generic.secrets.security.detected-hardcoded-key",
          "crypto.weak-crypto"
        ]
      },
      "do": [
        "Ensure hash functions used have output length of at least 256 bits for collision resistance or 128 bits for resistance to second pre-image attacks"
      ],
      "dont": [
        "Use hash functions with inadequate bit-lengths for required collision resistance"
      ],
      "id": "CRYPTO-HASH-AUTH-001",
      "refs": {
        "asvs": [
          "V11.4.3"
        ],
        "cwe": [
          "CWE-327",
          "CWE-328",
          "CWE-329"
        ],
        "owasp": [
          "A10:2021"
        ]
      },
      "requirement": "Hash functions used in digital signatures, data authentication, or data integrity must be collision resistant with appropriate bit-lengths",
      "scope": "web-application",
      "severity": "medium",
      "title": "Hash Function Collision Resistance",
      "verify": {
        "tests": [
          "Verify implementation meets security requirements"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "crypto.key-hardcoded",
          "generic.secrets.security.detected-hardcoded-key",
          "crypto.weak-crypto"
        ]
      },
      "do": [
        "Implement crypto agility to allow for seamless upgrades and replacements of cryptographic components"
      ],
      "dont": [
        "Rely on static cryptographic configurations that cannot be easily changed"
      ],
      "id": "CRYPTO-ALLOW-KEY-CIPHER-001",
      "refs": {
        "asvs": [
          "V11.2.2"
        ],
        "cwe": [
          "CWE-327",
          "CWE-328",
          "CWE-329"
        ],
        "owasp": [
          "A10:2021"
        ]
      },
      "requirement": "Design with crypto agility to allow reconfiguration, upgrading, or swapping of cryptographic algorithms, key lengths, ciphers, and modes",
      "scope": "web-application/api/mobile/infrastructure",
      "severity": "medium",
      "title": "Crypto Agility Design",
      "verify": {
        "tests": [
          "Verify implementation meets security requirements"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "crypto.key-hardcoded",
          "generic.secrets.security.detected-hardcoded-key",
          "crypto.weak-crypto"
        ]
      },
      "do": [
        "Implement approved key derivation functions with key stretching parameters when deriving secret keys from passwords",
        "Use cryptographically secure pseudo-random number generators (CSPRNG) with at least 128 bits of entropy for generating non-guessable random numbers and strings",
        "Use approved cryptographic algorithms and modes of operation for key generation, seeding, digital signature generation, and verification",
        "Implement full memory encryption to protect sensitive data while in use",
        "Minimize data exposure during processing and encrypt data immediately after use or as soon as feasible"
      ],
      "dont": [
        "Expose application encryption keys in client-side code or public repositories"
      ],
      "id": "CRYPTO-PROTECT-KEY-MGMT-001",
      "refs": {
        "asvs": [
          "V11.4.4",
          "V11.5.1",
          "V11.6.1",
          "V11.7.1",
          "V11.7.2"
        ],
        "cwe": [
          "CWE-327",
          "CWE-328",
          "CWE-329"
        ],
        "owasp": [
          "A10:2021"
        ]
      },
      "requirement": "Application encryption keys should be properly protected, not exposed in client-side code or public ...",
      "scope": "web-application",
      "severity": "high",
      "title": "Application Key Protection and Management",
      "verify": {
        "tests": [
          "Verify implementation meets security requirements"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "crypto.key-hardcoded",
          "generic.secrets.security.detected-hardcoded-key",
          "crypto.weak-crypto"
        ]
      },
      "do": [
        "Ensure that cryptographic operations use industry-validated implementations"
      ],
      "dont": [
        "Use unvalidated or custom cryptographic implementations"
      ],
      "id": "CRYPTO-IMPL-001",
      "refs": {
        "asvs": [
          "V11.2.1"
        ],
        "cwe": [
          "CWE-327",
          "CWE-328",
          "CWE-329"
        ],
        "owasp": [
          "A10:2021"
        ]
      },
      "requirement": "Use industry-validated implementations for cryptographic operations",
      "scope": "web-application/api/mobile/infrastructure",
      "severity": "medium",
      "title": "Industry-Validated Cryptographic Implementations",
      "verify": {
        "tests": [
          "Verify implementation meets security requirements"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "crypto.key-hardcoded",
          "generic.secrets.security.detected-hardcoded-key",
          "crypto.weak-crypto"
        ]
      },
      "do": [
        "Use CSPRNG for generating non-guessable random values",
        "Ensure random number generation mechanism works securely under heavy demand"
      ],
      "dont": [
        "Use insecure random number generation methods"
      ],
      "id": "CRYPTO-CSP-001",
      "refs": {
        "asvs": [
          "V11.5.1",
          "V11.5.2"
        ],
        "cwe": [
          "CWE-327",
          "CWE-328",
          "CWE-329"
        ],
        "owasp": [
          "A10:2021"
        ]
      },
      "requirement": "Generate random numbers and strings using a cryptographically secure pseudo-random number generator (CSPRNG) with at least 128 bits of entropy",
      "scope": "web-application",
      "severity": "high",
      "title": "Secure Random Number Generation",
      "verify": {
        "tests": [
          "Verify implementation meets security requirements"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "crypto.key-hardcoded",
          "generic.secrets.security.detected-hardcoded-key",
          "crypto.weak-crypto"
        ]
      },
      "do": [
        "Implement cryptographic operations that are constant-time with no 'short-circuit' operations"
      ],
      "dont": [
        "Allow timing side-channel attacks by not implementing constant-time operations"
      ],
      "id": "CRYPTO-CONSTANT-TIME-CRYPTOGRAPHIC-001",
      "refs": {
        "asvs": [
          "V11.2.4"
        ],
        "cwe": [
          "CWE-327",
          "CWE-328",
          "CWE-329"
        ],
        "owasp": [
          "A10:2021"
        ]
      },
      "requirement": "Ensure all cryptographic operations are constant-time to avoid information leakage",
      "scope": "web-application/api/mobile/infrastructure",
      "severity": "high",
      "title": "Constant-Time Cryptographic Operations",
      "verify": {
        "tests": [
          "Verify implementation meets security requirements"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "crypto.key-hardcoded",
          "generic.secrets.security.detected-hardcoded-key",
          "crypto.weak-crypto"
        ]
      },
      "do": [
        "Verify that cryptographic primitives provide a minimum of 128-bits of security"
      ],
      "dont": [
        "Use cryptographic primitives with insufficient security strength"
      ],
      "id": "CRYPTO-KEY-CONFIG-001",
      "refs": {
        "asvs": [
          "V11.2.3"
        ],
        "cwe": [
          "CWE-327",
          "CWE-328",
          "CWE-329"
        ],
        "owasp": [
          "A10:2021"
        ]
      },
      "requirement": "Ensure that all cryptographic primitives utilize a minimum of 128-bits of security based on the algorithm, key size, and configuration",
      "scope": "web-application/api/mobile/infrastructure",
      "severity": "medium",
      "title": "Minimum Security Strength for Cryptographic Primitives",
      "verify": {
        "tests": [
          "Verify implementation meets security requirements"
        ]
      }
    },
    {
      "detect": {
        "codeql": [
          "sql-injection"
        ],
        "semgrep": [
          "java.sql.preparedstatement",
          "csharp.sql.preparedstatement",
          "hibernate.querylanguage.preparedstatement",
          "python.django.security.injection.sql.django-sql-injection",
          "python.sqlalchemy.security.audit.sqlalchemy-execute-raw-query",
          "java.spring.security.audit.spring-sqli"
        ],
        "trufflehog": [
          "SQL Injection"
        ]
      },
      "do": [
        "Use prepared statements with variable binding in database queries",
        "Define all SQL code first and pass in each parameter to the query later",
        "Ensure the database always distinguishes between code and data"
      ],
      "dont": [
        "Avoid writing dynamic queries with string concatenation",
        "Do not allow user-supplied input to be directly appended to queries"
      ],
      "id": "SQL-INJECTION-PREVENTION-001",
      "refs": {
        "asvs": [
          "V6.1.1",
          "V6.1.2"
        ],
        "cwe": [
          "CWE-89",
          "CWE-564"
        ],
        "owasp": [
          "A1:2021",
          "A4:2021"
        ],
        "standards": [
          "ISO/IEC 27001"
        ]
      },
      "requirement": "Developers must use prepared statements with parameterized queries to prevent SQL injection vulnerabilities. Prepared statements ensure that the database distinguishes between code and data, making it impossible for attackers to change the query's intent.",
      "scope": "web-application",
      "severity": "high",
      "title": "Prevent SQL Injection with Prepared Statements",
      "verify": {
        "tests": [
          "Verify that all database queries use prepared statements with parameterized queries",
          "Test that user-supplied input is never directly appended to SQL queries",
          "Confirm that the database distinguishes between code and data in all queries"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "generic.validation.email-syntactic-check",
          "java.spring.security.spring-email-validation",
          "python.django.security.audit.avoid-unsafe-deserialization",
          "python.flask.security.audit.direct-use-of-jinja2",
          "java.spring.security.audit.spring-unvalidated-redirect"
        ],
        "trufflehog": [
          "Email address validation issues"
        ]
      },
      "do": [
        "Check for two parts separated by '@' symbol in email addresses",
        "Ensure email addresses do not contain dangerous characters",
        "Validate domain part with letters, numbers, hyphens, and periods only",
        "Perform semantic validation by sending confirmation emails for ownership verification"
      ],
      "dont": [
        "Accept email addresses without basic syntactic validation",
        "Rely solely on regular expressions for email address validation"
      ],
      "id": "INPUT-VALIDATION-003",
      "refs": {
        "asvs": [
          "V6.1.1",
          "V6.1.2"
        ],
        "cwe": [
          "CWE-20",
          "CWE-116"
        ],
        "owasp": [
          "A03:2021",
          "C3:2024"
        ]
      },
      "requirement": "Validate email addresses with both syntactic and semantic checks to ensure correct format and legitimacy.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Implement email address validation with syntactic and semantic checks",
      "verify": {
        "tests": [
          "Verify that email addresses undergo both syntactic and semantic validation",
          "Test email confirmation process for ownership verification"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "python.django.security.django-input-validation",
          "java.spring.security.spring-input-validation",
          "python.django.security.audit.avoid-unsafe-deserialization",
          "python.flask.security.audit.direct-use-of-jinja2",
          "java.spring.security.audit.spring-unvalidated-redirect"
        ],
        "trufflehog": [
          "Structured data validation issues"
        ]
      },
      "do": [
        "Enforce correct syntax for structured fields (e.g., SSN, date, currency symbol)",
        "Ensure correctness of values in the specific business context (e.g., start date before end date)",
        "Use data type validators provided by web application frameworks or custom validators",
        "Validate input against JSON Schema or XML Schema for structured data"
      ],
      "dont": [
        "Rely solely on client-side validation for input validation",
        "Accept inputs without proper syntactic and semantic validation"
      ],
      "id": "INPUT-VALIDATION-001",
      "refs": {
        "asvs": [
          "V6.1.1",
          "V6.1.2"
        ],
        "cwe": [
          "CWE-20",
          "CWE-116"
        ],
        "owasp": [
          "A03:2021",
          "C3:2024"
        ]
      },
      "requirement": "All user inputs, including data from untrusted sources, must undergo both syntactic and semantic validation to ensure correct syntax and values in the specific business context.",
      "scope": "web-application",
      "severity": "high",
      "title": "Implement syntactic and semantic input validation for all user inputs",
      "verify": {
        "tests": [
          "Verify that all user inputs are validated both syntactically and semantically",
          "Test for bypassing validation by providing malformed data"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "generic.validation.allowlist",
          "javascript.security.allowlist-validation",
          "python.django.security.audit.avoid-unsafe-deserialization",
          "python.flask.security.audit.direct-use-of-jinja2",
          "java.spring.security.audit.spring-unvalidated-redirect"
        ],
        "trufflehog": [
          "Allowlist validation issues"
        ]
      },
      "do": [
        "Define strong validation patterns based on regular expressions for structured data",
        "Match input against a fixed set of options for dropdown lists or radio buttons",
        "Use allowlist validation for all user-provided input fields"
      ],
      "dont": [
        "Rely solely on denylist validation for input validation",
        "Accept inputs without matching them against an allowlist"
      ],
      "id": "INPUT-VALIDATION-002",
      "refs": {
        "asvs": [
          "V6.1.1",
          "V6.1.2"
        ],
        "cwe": [
          "CWE-20",
          "CWE-116"
        ],
        "owasp": [
          "A03:2021",
          "C3:2024"
        ]
      },
      "requirement": "Implement allowlist validation for all user inputs to define exactly what is authorized, ensuring that only authorized inputs are accepted.",
      "scope": "web-application",
      "severity": "high",
      "title": "Implement allowlist validation for all user inputs",
      "verify": {
        "tests": [
          "Verify that all user inputs are validated against allowlists",
          "Test for bypassing validation by providing unauthorized inputs"
        ]
      }
    },
    {
      "detect": {
        "codeql": [
          "sql-injection"
        ],
        "semgrep": [
          "java.sql.callablestatement",
          "dotnet.sql.command",
          "python.django.security.injection.sql.django-sql-injection",
          "python.sqlalchemy.security.audit.sqlalchemy-execute-raw-query",
          "java.spring.security.audit.spring-sqli"
        ],
        "trufflehog": [
          "SQL Injection"
        ]
      },
      "do": [
        "Build SQL statements with parameters in stored procedures",
        "Ensure stored procedures are implemented safely to prevent SQL injection",
        "Define and store SQL code in the database itself, then call from the application"
      ],
      "dont": [
        "Avoid using unsafe dynamic SQL generation within stored procedures",
        "Do not grant excessive execute rights to application accounts for stored procedures"
      ],
      "id": "SQL-INJECTION-PREVENTION-002",
      "refs": {
        "asvs": [
          "V6.1.1",
          "V6.1.2"
        ],
        "cwe": [
          "CWE-89",
          "CWE-564"
        ],
        "owasp": [
          "A1:2021",
          "A4:2021"
        ],
        "standards": [
          "ISO/IEC 27001"
        ]
      },
      "requirement": "Developers must use properly constructed stored procedures to prevent SQL injection vulnerabilities. Stored procedures should be implemented safely with predefined SQL statements and parameters to ensure the database distinguishes between code and data.",
      "scope": "web-application",
      "severity": "high",
      "title": "Implement Secure Stored Procedures",
      "verify": {
        "tests": [
          "Verify that stored procedures use predefined SQL statements with parameters",
          "Test that stored procedures are implemented safely to prevent SQL injection",
          "Confirm that stored procedures distinguish between code and data in queries"
        ]
      }
    },
    {
      "detect": {
        "codeql": [
          "sql-injection"
        ],
        "semgrep": [
          "input-validation.table-name",
          "input-validation.column-name",
          "python.django.security.audit.avoid-unsafe-deserialization",
          "python.flask.security.audit.direct-use-of-jinja2",
          "java.spring.security.audit.spring-unvalidated-redirect"
        ],
        "trufflehog": [
          "SQL Injection"
        ]
      },
      "do": [
        "Validate input for table names, column names, or sort order indicators",
        "Map parameter values to legal and expected table or column names",
        "Use input validation to prevent unauthorized input in SQL queries"
      ],
      "dont": [
        "Avoid using user parameter values directly for table or column names",
        "Do not allow unvalidated user input to be included in queries"
      ],
      "id": "SQL-INJECTION-PREVENTION-003",
      "refs": {
        "asvs": [
          "V6.1.1",
          "V6.1.2"
        ],
        "cwe": [
          "CWE-89",
          "CWE-564"
        ],
        "owasp": [
          "A1:2021",
          "A4:2021"
        ],
        "standards": [
          "ISO/IEC 27001"
        ]
      },
      "requirement": "Developers must implement allow-list input validation for parts of SQL queries that can't use bind variables, such as table names or column names. Input validation should ensure that only legal and expected values are used in queries.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Implement Allow-list Input Validation",
      "verify": {
        "tests": [
          "Verify that input validation is implemented for table names, column names, and sort order indicators",
          "Test that only legal and expected values are used in SQL queries",
          "Confirm that unauthorized input is prevented from being included in queries"
        ]
      }
    },
    {
      "detect": {
        "codeql": [
          "jwt-signature-not-verified",
          "jwt-none-algorithm-accepted"
        ],
        "semgrep": [
          "javascript.jsonwebtoken.security.jwt-verify-none",
          "python.jwt.security.jwt-none-alg",
          "java.jwt.security.jwt-signature-bypass",
          "generic.jwt.security.disabled-signature-verification"
        ]
      },
      "do": [
        "Verify JWT signature before accessing token claims or making authorization decisions",
        "Use strong cryptographic algorithms (RS256, ES256) for JWT signing",
        "Implement proper key management for JWT verification keys",
        "Validate the JWT header algorithm matches expected signing algorithm",
        "Use well-established JWT libraries with security updates",
        "Log signature verification failures for security monitoring"
      ],
      "dont": [
        "Do not process JWT claims without verifying the signature first",
        "Do not accept JWT tokens with 'none' algorithm in production",
        "Do not ignore JWT signature verification failures",
        "Do not use weak or deprecated signing algorithms (HS256 with weak keys)",
        "Do not implement custom JWT signature verification without security review",
        "Do not trust JWT claims from unverified tokens"
      ],
      "id": "JWT-SIG-001",
      "refs": {
        "asvs": [
          "V3.1.1",
          "V6.2.1",
          "V6.2.2"
        ],
        "cwe": [
          "CWE-347",
          "CWE-295",
          "CWE-287"
        ],
        "owasp": [
          "A02:2021",
          "A07:2021"
        ],
        "standards": [
          "RFC 7515",
          "RFC 7519",
          "OWASP JWT Security Cheat Sheet"
        ]
      },
      "requirement": "All JWT tokens must undergo complete signature verification using the correct algorithm and key before any claims are processed or authorization decisions are made.",
      "scope": "jwt-implementations",
      "severity": "critical",
      "title": "JWT signatures must be properly verified before processing claims",
      "verify": {
        "tests": [
          "Verify JWT tokens with invalid signatures are rejected",
          "Test that tokens with 'none' algorithm are refused in production",
          "Confirm signature verification occurs before claim processing",
          "Validate proper error handling for signature verification failures",
          "Test JWT verification with wrong signing keys fails appropriately"
        ]
      }
    },
    {
      "detect": {
        "codeql": [
          "hardcoded-jwt-key",
          "weak-jwt-key-generation"
        ],
        "semgrep": [
          "javascript.jsonwebtoken.security.jwt-hardcode-key",
          "python.jwt.security.jwt-hardcode-key",
          "java.jwt.security.jwt-hardcoded-key",
          "generic.jwt.security.weak-key-generation"
        ],
        "trufflehog": [
          "JWT Signing Key",
          "Private Key"
        ]
      },
      "do": [
        "Generate JWT signing keys using cryptographically secure random number generators",
        "Store JWT signing keys in dedicated key management systems or secure storage",
        "Implement key rotation procedures with overlap periods for verification",
        "Use key identifiers (kid) to support multiple active keys during rotation",
        "Validate verification keys against trusted key sources (JWKS endpoints with HTTPS)",
        "Implement key revocation mechanisms for compromised keys"
      ],
      "dont": [
        "Do not use predictable or weak keys for JWT signing",
        "Do not store JWT signing keys in application configuration or source code",
        "Do not reuse JWT keys across different environments or applications",
        "Do not fetch verification keys from untrusted or unencrypted sources",
        "Do not skip key validation when retrieving keys from external sources",
        "Do not use the same key indefinitely without rotation"
      ],
      "id": "JWT-KEY-001",
      "refs": {
        "asvs": [
          "V6.1.1",
          "V6.4.1",
          "V6.4.2",
          "V3.1.1"
        ],
        "cwe": [
          "CWE-321",
          "CWE-798",
          "CWE-330",
          "CWE-295"
        ],
        "owasp": [
          "A02:2021"
        ],
        "standards": [
          "RFC 7517",
          "RFC 7519",
          "NIST SP 800-57"
        ]
      },
      "requirement": "JWT signing keys must be generated with sufficient entropy, stored securely, rotated regularly, and verification keys must be obtained through secure channels with proper validation.",
      "scope": "jwt-implementations",
      "severity": "critical",
      "title": "JWT signing and verification keys must be securely managed",
      "verify": {
        "tests": [
          "Verify JWT signing keys are not present in source code or configuration",
          "Test key rotation procedures maintain token validation capability",
          "Confirm verification keys are retrieved securely with proper validation",
          "Validate key identifier (kid) handling supports multiple active keys",
          "Test key revocation procedures properly invalidate compromised keys"
        ]
      }
    },
    {
      "detect": {
        "codeql": [
          "jwt-without-expiration",
          "jwt-expiration-not-validated"
        ],
        "semgrep": [
          "javascript.jsonwebtoken.security.jwt-missing-expiration",
          "python.jwt.security.jwt-missing-exp",
          "java.jwt.security.jwt-no-expiration",
          "generic.jwt.security.missing-expiration-claim"
        ]
      },
      "do": [
        "Include 'exp' claim in all JWT tokens with reasonable expiration times",
        "Validate JWT expiration before processing token claims",
        "Set appropriate expiration based on token purpose (short for access, longer for refresh)",
        "Implement token refresh mechanisms before expiration",
        "Log and monitor expired token usage attempts",
        "Use synchronized time sources for expiration validation"
      ],
      "dont": [
        "Do not create JWT tokens without expiration claims",
        "Do not accept expired JWT tokens in authorization decisions",
        "Do not set excessively long expiration times (>24 hours for access tokens)",
        "Do not skip expiration validation during token verification",
        "Do not rely on client-side expiration checking alone"
      ],
      "id": "JWT-EXP-001",
      "refs": {
        "asvs": [
          "V3.1.3",
          "V3.3.1",
          "V3.3.3"
        ],
        "cwe": [
          "CWE-613",
          "CWE-287"
        ],
        "owasp": [
          "A07:2021"
        ],
        "standards": [
          "RFC 7519",
          "OWASP JWT Security Cheat Sheet"
        ]
      },
      "requirement": "All JWT tokens must include expiration (exp) claims with appropriate time limits, and applications must validate expiration before accepting tokens to prevent indefinite token usage.",
      "scope": "jwt-implementations",
      "severity": "high",
      "title": "JWT tokens must include expiration claims and be validated",
      "verify": {
        "tests": [
          "Verify all generated JWT tokens contain 'exp' claim",
          "Test that expired JWT tokens are rejected during validation",
          "Confirm appropriate expiration times based on token type and use case",
          "Validate token refresh mechanisms work before expiration",
          "Test system behavior with tokens having past expiration dates"
        ]
      }
    },
    {
      "detect": {
        "codeql": [
          "jwt-algorithm-confusion",
          "jwt-none-algorithm",
          "weak-jwt-algorithm"
        ],
        "semgrep": [
          "javascript.jsonwebtoken.security.jwt-algorithm-none",
          "python.jwt.security.jwt-none-algorithm",
          "java.jwt.security.jwt-weak-algorithm",
          "generic.jwt.security.algorithm-confusion"
        ]
      },
      "do": [
        "Maintain an explicit allowlist of permitted JWT algorithms",
        "Validate JWT algorithm header against the allowed algorithms list",
        "Use asymmetric algorithms (RS256, ES256) for distributed systems",
        "Reject tokens with algorithm mismatches or unexpected algorithms",
        "Implement algorithm-specific key validation and verification",
        "Document approved algorithms and their use cases for development teams"
      ],
      "dont": [
        "Do not accept JWT tokens with 'none' algorithm",
        "Do not allow algorithm switching without explicit validation",
        "Do not use weak or deprecated algorithms (HS256 with shared secrets in distributed systems)",
        "Do not trust algorithm claims without verification against allowed list",
        "Do not implement algorithm detection based solely on token header"
      ],
      "id": "JWT-ALG-001",
      "refs": {
        "asvs": [
          "V6.2.1",
          "V6.2.2",
          "V3.1.1"
        ],
        "cwe": [
          "CWE-347",
          "CWE-327",
          "CWE-345"
        ],
        "owasp": [
          "A02:2021"
        ],
        "standards": [
          "RFC 7515",
          "RFC 7518",
          "OWASP JWT Security Cheat Sheet"
        ]
      },
      "requirement": "JWT verification must validate that the algorithm specified in the token header matches an explicitly allowed list of secure algorithms, preventing algorithm confusion attacks.",
      "scope": "jwt-implementations",
      "severity": "high",
      "title": "JWT algorithm claims must be validated against allowed algorithms",
      "verify": {
        "tests": [
          "Verify tokens with 'none' algorithm are rejected",
          "Test that only explicitly allowed algorithms are accepted",
          "Confirm algorithm confusion attacks are prevented",
          "Validate proper error handling for unsupported algorithms",
          "Test algorithm validation occurs before signature verification"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "python.lang.security.audit.dangerous-system-call",
          "javascript.lang.security.audit.path-traversal"
        ]
      },
      "do": [
        "Implement antivirus scanning for files from untrusted sources"
      ],
      "dont": [
        "Serve files from untrusted sources without scanning"
      ],
      "id": "FILE-HANDLING-001",
      "refs": {
        "asvs": [
          "V5.4.3"
        ],
        "cwe": [
          "CWE-434"
        ],
        "owasp": [
          "A01:2021"
        ]
      },
      "requirement": "Files obtained from untrusted sources are scanned by antivirus scanners to prevent serving of known malicious content.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Scan files from untrusted sources with antivirus",
      "verify": {
        "tests": [
          "Test file upload validation and processing security"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "python.lang.security.audit.dangerous-system-call",
          "javascript.lang.security.audit.path-traversal"
        ]
      },
      "do": [
        "Implement file size limits and validate file signatures",
        "Use internally generated or trusted data for file paths",
        "Apply strict validation and sanitization for user-submitted filenames"
      ],
      "dont": [
        "Accept user-submitted filenames without validation and sanitization"
      ],
      "id": "FILE-UPLOAD-003",
      "refs": {
        "asvs": [
          "V5.3.2"
        ],
        "cwe": [
          "CWE-434"
        ],
        "owasp": [
          "A01:2021"
        ]
      },
      "requirement": "Enforce file size limits and validate file signatures to prevent DoS attacks and malicious uploads. When the application creates file paths for file operations, instead of user-submitted filenames, it uses internally generated or trusted data, or if user-submitted filenames or file metadata must be used, strict validation and sanitization must be applied.",
      "scope": "web-application",
      "severity": "high",
      "title": "Implement file size and type validation",
      "verify": {
        "tests": [
          "Test file upload validation and processing security"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "python.lang.security.audit.dangerous-system-call",
          "javascript.lang.security.audit.path-traversal"
        ]
      },
      "do": [
        "Generate random filenames for uploaded files",
        "Store files in a secure location outside the webroot",
        "Ignore user-provided path information during file processing"
      ],
      "dont": [
        "Use predictable filenames for uploaded files",
        "Store files in insecure locations within the webroot"
      ],
      "id": "FILE-UPLOAD-002",
      "refs": {
        "asvs": [
          "V5.3.3"
        ],
        "cwe": [
          "CWE-434"
        ],
        "owasp": [
          "A01:2021"
        ]
      },
      "requirement": "Generate random filenames for uploaded files and store them in a secure location outside the webroot. Server-side file processing, such as file decompression, ignores user-provided path information to prevent vulnerabilities such as zip slip.",
      "scope": "web-application",
      "severity": "high",
      "title": "Secure file naming and storage location",
      "verify": {
        "tests": [
          "Test file upload validation and processing security"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "python.lang.security.audit.dangerous-system-call",
          "javascript.lang.security.audit.path-traversal"
        ]
      },
      "do": [
        "Check file extensions against a whitelist of allowed extensions",
        "Validate or ignore user-submitted filenames in various contexts",
        "Specify a filename in the Content-Disposition header field"
      ],
      "dont": [
        "Accept file extensions without validation",
        "Allow user-submitted filenames without proper handling"
      ],
      "id": "FILE-UPLOAD-001",
      "refs": {
        "asvs": [
          "V5.4.1"
        ],
        "cwe": [
          "CWE-434"
        ],
        "owasp": [
          "A01:2021"
        ]
      },
      "requirement": "Implement input validation to check file extensions against a whitelist of allowed extensions. Additionally, validate or ignore user-submitted filenames, including in a JSON, JSONP, or URL parameter, and specify a filename in the Content-Disposition header field in the response.",
      "scope": "web-application",
      "severity": "high",
      "title": "Validate file extensions and content types",
      "verify": {
        "tests": [
          "Test file upload validation and processing security"
        ]
      }
    },
    {
      "detect": {
        "codeql": [
          "hardcoded-jwt-secret",
          "weak-jwt-signature"
        ],
        "semgrep": [
          "javascript.jsonwebtoken.security.jwt-hardcode-secret",
          "python.jwt.security.jwt-hardcode-secret",
          "java.jwt.security.jwt-hardcode-secret",
          "generic.secrets.security.jwt-secret"
        ],
        "trufflehog": [
          "JWT Secret",
          "Private Key"
        ]
      },
      "do": [
        "Generate JWT signing keys using cryptographically secure random number generators",
        "Store JWT signing secrets in dedicated key management systems",
        "Use environment variables or secure configuration for JWT secrets in runtime",
        "Implement key rotation procedures for JWT signing keys",
        "Use asymmetric cryptography (RS256, ES256) where possible instead of shared secrets",
        "Ensure JWT signing keys have sufficient entropy (minimum 256 bits for HS256)"
      ],
      "dont": [
        "Do not use predictable or weak JWT signing secrets (e.g., 'secret', 'key', 'password')",
        "Do not hardcode JWT secrets in configuration files or source code",
        "Do not reuse JWT signing keys across different environments or applications",
        "Do not use the 'none' algorithm for JWT signatures in production",
        "Do not commit JWT signing keys to version control systems"
      ],
      "id": "SECRETS-JWT-001",
      "refs": {
        "asvs": [
          "V3.1.1",
          "V6.2.1",
          "V6.4.2"
        ],
        "cwe": [
          "CWE-798",
          "CWE-321",
          "CWE-347"
        ],
        "owasp": [
          "A02:2021",
          "A07:2021"
        ],
        "standards": [
          "RFC 7519",
          "RFC 7515"
        ]
      },
      "requirement": "JWT signing keys and secrets must be cryptographically secure, randomly generated, stored in secure key management systems, and never embedded in source code.",
      "scope": "jwt-implementations",
      "severity": "critical",
      "title": "JWT signing secrets must not be hardcoded or use weak values",
      "verify": {
        "tests": [
          "Verify JWT signing secrets are not present in source code",
          "Test that JWT verification fails with incorrect or missing secrets",
          "Confirm JWT tokens cannot be generated without proper secret access",
          "Validate JWT secret rotation procedures maintain token validation capability",
          "Test rejection of JWT tokens signed with weak or default secrets"
        ]
      }
    },
    {
      "detect": {
        "codeql": [
          "hardcoded-database-password",
          "database-query-built-from-user-controlled-sources"
        ],
        "semgrep": [
          "generic.secrets.security.detected-password",
          "python.django.security.django-hardcoded-db-password",
          "java.spring.security.hardcoded-database-password",
          "javascript.sequelize.security.hardcoded-secret"
        ],
        "trufflehog": [
          "Database Connection String",
          "MySQL Password",
          "PostgreSQL Password"
        ]
      },
      "do": [
        "Use environment variables for database credentials",
        "Implement connection string builders that load credentials at runtime",
        "Use database authentication tokens with automatic renewal",
        "Store database passwords in enterprise secret management systems",
        "Implement least-privilege database access with role-based authentication",
        "Use encrypted connection strings where supported"
      ],
      "dont": [
        "Do not embed database passwords in connection strings within code",
        "Do not hardcode database usernames and passwords in configuration files",
        "Do not commit .env files containing database credentials to version control",
        "Do not use default or placeholder database credentials in any environment",
        "Do not expose database connection details in application logs or error messages"
      ],
      "id": "SECRETS-DB-001",
      "refs": {
        "asvs": [
          "V2.1.12",
          "V6.4.1",
          "V9.2.3"
        ],
        "cwe": [
          "CWE-798",
          "CWE-259",
          "CWE-256"
        ],
        "owasp": [
          "A02:2021",
          "A07:2021"
        ],
        "standards": [
          "PCI DSS 8.2.1"
        ]
      },
      "requirement": "Database connection strings, usernames, passwords, and connection parameters must be externalized from source code and retrieved from secure configuration systems.",
      "scope": "all-languages",
      "severity": "critical",
      "title": "Database credentials must not be hardcoded in applications",
      "verify": {
        "tests": [
          "Verify no database credentials appear in source code",
          "Test application startup fails when database credentials are missing",
          "Confirm database connections use externally provided credentials",
          "Validate database connection encryption is enforced",
          "Test credential rotation scenarios without service interruption"
        ]
      }
    },
    {
      "detect": {
        "codeql": [
          "hardcoded-cloud-credentials",
          "cloud-service-credential-exposure"
        ],
        "semgrep": [
          "generic.secrets.security.detected-aws-access-key",
          "generic.secrets.security.detected-azure-key",
          "generic.secrets.security.detected-gcp-key",
          "cloud.aws.security.hardcoded-aws-credentials"
        ],
        "trufflehog": [
          "AWS Access Key",
          "AWS Secret Key",
          "Azure Storage Account Key",
          "Google Cloud Service Account"
        ]
      },
      "do": [
        "Use cloud-native IAM roles and service accounts for application authentication",
        "Implement workload identity federation where supported",
        "Store cloud credentials in dedicated secret management services (AWS Secrets Manager, Azure Key Vault, GCP Secret Manager)",
        "Use temporary security credentials with automatic rotation",
        "Apply principle of least privilege to cloud service permissions",
        "Implement credential scanning in CI/CD pipelines"
      ],
      "dont": [
        "Do not hardcode AWS access keys, secret keys, or session tokens in code",
        "Do not embed Azure service principal credentials or connection strings",
        "Do not commit Google Cloud service account keys to version control",
        "Do not use long-lived credentials when shorter-lived alternatives exist",
        "Do not grant overly broad permissions to cloud service accounts",
        "Do not expose cloud credentials in environment variables visible to unauthorized processes"
      ],
      "id": "SECRETS-CLOUD-001",
      "refs": {
        "asvs": [
          "V6.4.1",
          "V6.4.2",
          "V14.1.3"
        ],
        "cwe": [
          "CWE-798",
          "CWE-540",
          "CWE-522"
        ],
        "owasp": [
          "A02:2021",
          "A05:2021"
        ],
        "standards": [
          "AWS IAM Best Practices",
          "Azure Security Best Practices",
          "GCP IAM Best Practices"
        ]
      },
      "requirement": "Cloud service access keys, tokens, and credentials must be managed through secure identity and access management systems, never hardcoded in applications or configuration files.",
      "scope": "cloud-applications",
      "severity": "critical",
      "title": "Cloud service credentials and access keys must be secured",
      "verify": {
        "tests": [
          "Verify no cloud service credentials appear in source code or configuration",
          "Test application authentication using IAM roles instead of hardcoded keys",
          "Confirm credential rotation procedures work without service disruption",
          "Validate that cloud permissions follow least-privilege principles",
          "Test CI/CD pipeline credential scanning catches hardcoded keys"
        ]
      }
    },
    {
      "detect": {
        "codeql": [
          "hardcoded-credentials"
        ],
        "semgrep": [
          "generic.secrets.security.detected-aws-access-key",
          "generic.secrets.security.detected-generic-secret",
          "javascript.express.security.express-hardcoded-secret",
          "python.django.security.django-hardcoded-secret"
        ],
        "trufflehog": [
          "AWS Access Key",
          "Generic API Key",
          "GitHub Token"
        ]
      },
      "do": [
        "Use environment variables for API keys",
        "Store credentials in secure key management systems (AWS Secrets Manager, HashiCorp Vault)",
        "Implement proper secret rotation procedures",
        "Use service account authentication where available",
        "Validate that secrets are loaded from secure sources at application startup"
      ],
      "dont": [
        "Do not hardcode API keys in configuration files committed to version control",
        "Do not embed tokens directly in source code",
        "Do not use placeholder or default API keys in production code",
        "Do not store credentials in environment files (.env) committed to repositories",
        "Do not log or expose API keys in error messages or debug output"
      ],
      "id": "SECRETS-API-001",
      "refs": {
        "asvs": [
          "V6.4.1",
          "V6.4.2"
        ],
        "cwe": [
          "CWE-798",
          "CWE-540"
        ],
        "owasp": [
          "A02:2021"
        ],
        "standards": [
          "NIST SP 800-57"
        ]
      },
      "requirement": "API keys, tokens, and service credentials must be stored in secure configuration management systems and injected at runtime, never embedded directly in source code.",
      "scope": "all-languages",
      "severity": "critical",
      "title": "API keys must not be hardcoded in source code",
      "verify": {
        "tests": [
          "Verify no API keys appear in source code or configuration files",
          "Test that application fails gracefully when API keys are missing from environment",
          "Confirm API keys are loaded from secure configuration at runtime",
          "Validate secret rotation procedures work without application downtime"
        ]
      }
    },
    {
      "detect": {
        "codeql": [
          "command-injection"
        ],
        "semgrep": [
          "java.command-injection",
          "java.os-command-injection"
        ],
        "trufflehog": [
          "Command Injection"
        ]
      },
      "do": [
        "Use Java API features for system interactions instead of constructing commands",
        "Sanitize and validate user input before using it in system commands",
        "Implement input validation using allowlist approach to restrict user input"
      ],
      "dont": [
        "Do not build system commands by concatenating user input directly",
        "Avoid executing system commands without proper validation"
      ],
      "id": "JAVA-PREVENT-INJECTION-COMMAND-001",
      "refs": {
        "cwe": [
          "CWE-78",
          "CWE-88"
        ],
        "owasp": [
          "A01:2021",
          "A06:2021"
        ]
      },
      "requirement": "Avoid building Operating System commands using untrusted user input directly in Strings. Utilize technology stack APIs to prevent command injection vulnerabilities.",
      "scope": "web-application",
      "severity": "high",
      "title": "Prevent Command Injection in Java applications",
      "verify": {
        "tests": [
          "Review code to ensure system commands are constructed safely",
          "Perform security testing to validate command injection protections"
        ]
      }
    },
    {
      "detect": {
        "codeql": [
          "xpath-injection"
        ],
        "semgrep": [
          "java.xpath-injection",
          "java.xpath-variable-injection"
        ],
        "trufflehog": [
          "XPath Injection"
        ]
      },
      "do": [
        "Implement XPath Variable Resolver to define parameters for XPath expressions",
        "Sanitize and validate user input before using it in XPath queries",
        "Apply input validation using allowlist approach to restrict user input"
      ],
      "dont": [
        "Do not concatenate user input directly into XPath queries",
        "Avoid using String manipulation to build XPath queries"
      ],
      "id": "JAVA-PREVENT-INJECTION-XPATH-001",
      "refs": {
        "cwe": [
          "CWE-91",
          "CWE-918"
        ],
        "owasp": [
          "A01:2021",
          "A06:2021"
        ]
      },
      "requirement": "Use XPath Variable Resolver to prevent XPath injection in Java applications. Avoid building XPath queries using untrusted user input directly in Strings.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Prevent XPath Injection in Java applications",
      "verify": {
        "tests": [
          "Verify XPath queries are constructed safely without user input manipulation",
          "Conduct security testing to confirm XPath injection vulnerabilities are mitigated"
        ]
      }
    },
    {
      "detect": {
        "codeql": [
          "sql-injection"
        ],
        "semgrep": [
          "java.sql.SQLInjection",
          "java.jdbc.SQLInjection"
        ],
        "trufflehog": [
          "SQL Injection"
        ]
      },
      "do": [
        "Use Prepared Statements with parameterized queries for SQL operations",
        "Sanitize and validate user input before using it in SQL queries",
        "Implement input validation using allowlist approach to restrict user input"
      ],
      "dont": [
        "Do not concatenate user input directly into SQL queries",
        "Avoid using String manipulation to build SQL queries"
      ],
      "id": "JAVA-PREVENT-INJECTION-SQL-001",
      "refs": {
        "cwe": [
          "CWE-89",
          "CWE-564"
        ],
        "owasp": [
          "A01:2021",
          "A02:2021",
          "A06:2021"
        ]
      },
      "requirement": "Use Query Parameterization to prevent SQL injection in Java applications. Avoid building SQL queries using untrusted user input directly in Strings.",
      "scope": "web-application",
      "severity": "high",
      "title": "Prevent SQL Injection in Java applications",
      "verify": {
        "tests": [
          "Perform code reviews to ensure SQL queries are parameterized",
          "Conduct security testing to verify SQL injection vulnerabilities are mitigated"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "php.security.ini.app-debug",
          "python.logging.security.audit.logging-sensitive-data",
          "java.lang.security.audit.system-exit",
          "javascript.express.security.audit.express-expose-sensitive-data"
        ]
      },
      "do": [
        "Set 'APP_DEBUG=false' in the production environment configuration"
      ],
      "dont": [
        "Do not expose debug information to end-users in production"
      ],
      "id": "PHP-PREVENT-ENVIRONMENT-DISABLE-001",
      "refs": {
        "owasp": [
          "A03:2021",
          "A06:2021",
          "A09:2021"
        ]
      },
      "requirement": "Ensure that the 'APP_DEBUG' environment variable is set to 'false' in production to prevent sensitive information disclosure and potential security vulnerabilities.",
      "scope": "web-application",
      "severity": "high",
      "title": "Disable debug mode in production environment",
      "verify": {
        "tests": [
          "Verify 'APP_DEBUG' is set to 'false' in production environment"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "php.laravel.security.cookie-settings",
          "python.django.security.audit.xss.direct-use-of-httpresp-write",
          "javascript.browser.security.audit.dom-based-xss",
          "java.spring.security.audit.spring-xss"
        ]
      },
      "do": [
        "Enable cookie encryption middleware for sensitive data",
        "Set 'http_only' attribute to 'true' to prevent client-side script access",
        "Configure 'same_site' attribute to 'lax' or 'strict' for better cookie security"
      ],
      "dont": [
        "Avoid disabling cookie encryption middleware without a specific use case"
      ],
      "id": "PHP-LARAVEL-SECURE-COOKIES-001",
      "refs": {
        "owasp": [
          "A03:2021",
          "A07:2021",
          "A10:2021"
        ]
      },
      "requirement": "Configure secure cookie attributes to enhance the security of session management and prevent common attacks like session hijacking and XSS.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Secure Cookie Configuration for Laravel Applications",
      "verify": {
        "tests": [
          "Verify cookie encryption middleware is enabled",
          "Check 'http_only' and 'same_site' attributes are properly configured"
        ]
      }
    },
    {
      "detect": {
        "custom": [
          "custom-laravel-app-key-001"
        ],
        "semgrep": [
          "php.laravel.security.key-generation"
        ]
      },
      "do": [
        "Run 'php artisan key:generate' to generate a new application key",
        "Store the application key securely and avoid exposing it in version control"
      ],
      "dont": [
        "Do not hardcode or expose the application key in source code"
      ],
      "id": "PHP-KEY-ENCRYPT-001",
      "refs": {
        "owasp": [
          "A03:2021",
          "A06:2021",
          "A09:2021"
        ]
      },
      "requirement": "Ensure that the application key is generated and securely stored to protect sensitive data encrypted using Laravel's encryption mechanisms.",
      "scope": "web-application",
      "severity": "high",
      "title": "Generate and secure application key",
      "verify": {
        "tests": [
          "Verify the application key is generated and securely stored",
          "Ensure the application key is not exposed in source code or configuration files"
        ]
      }
    },
    {
      "detect": {
        "codeql": [
          "cookie-without-httponly",
          "insecure-cookie-configuration"
        ],
        "semgrep": [
          "javascript.express.security.express-cookie-settings.express-cookie-no-httponly",
          "python.flask.security.insecure-cookies.flask-cookie-no-httponly",
          "java.servlet.security.httponly-cookie",
          "php.security.cookie-not-httponly"
        ]
      },
      "do": [
        "Set HttpOnly attribute on all session cookies",
        "Apply HttpOnly to authentication and authorization cookies",
        "Use HttpOnly for cookies containing sensitive user data or preferences",
        "Configure web framework cookie settings to default HttpOnly to true",
        "Validate HttpOnly attribute is present in cookie security tests",
        "Document cookie security requirements for development teams"
      ],
      "dont": [
        "Do not omit HttpOnly attribute from session management cookies",
        "Do not create security-sensitive cookies accessible to JavaScript",
        "Do not rely solely on CSRF tokens without HttpOnly session cookies",
        "Do not use HttpOnly for functional cookies that legitimately need client-side access",
        "Do not assume HttpOnly prevents all cookie-based attacks"
      ],
      "id": "COOKIES-HTTPONLY-001",
      "refs": {
        "asvs": [
          "V3.4.1",
          "V3.4.2"
        ],
        "cwe": [
          "CWE-1004",
          "CWE-79",
          "CWE-200"
        ],
        "owasp": [
          "A03:2021",
          "A05:2021"
        ],
        "standards": [
          "RFC 6265",
          "OWASP Session Management Cheat Sheet"
        ]
      },
      "requirement": "All cookies containing session identifiers, authentication tokens, or other security-sensitive data must include the HttpOnly attribute to prevent client-side script access and mitigate XSS-based cookie theft.",
      "scope": "web-applications",
      "severity": "high",
      "title": "Session and security-sensitive cookies must use HttpOnly attribute",
      "verify": {
        "tests": [
          "Verify all session cookies include HttpOnly attribute in Set-Cookie headers",
          "Test that HttpOnly cookies are not accessible via document.cookie in browser",
          "Confirm authentication cookies cannot be read by malicious JavaScript",
          "Validate cookie security configuration in framework settings",
          "Test XSS attack scenarios cannot access HttpOnly session cookies"
        ]
      }
    },
    {
      "detect": {
        "codeql": [
          "cookie-without-samesite",
          "insecure-samesite-configuration"
        ],
        "semgrep": [
          "javascript.express.security.express-cookie-settings.express-cookie-no-samesite",
          "python.flask.security.insecure-cookies.flask-cookie-no-samesite",
          "java.servlet.security.samesite-cookie",
          "php.security.cookie-no-samesite"
        ]
      },
      "do": [
        "Set SameSite=Strict for highly sensitive cookies that don't need cross-site access",
        "Use SameSite=Lax for session cookies that need some cross-site functionality",
        "Apply SameSite=None with Secure for cookies requiring cross-site access",
        "Configure SameSite policy based on application's cross-origin requirements",
        "Implement SameSite as part of comprehensive CSRF defense strategy",
        "Test SameSite behavior with application's legitimate cross-origin workflows"
      ],
      "dont": [
        "Do not omit SameSite attribute from authentication or session cookies",
        "Do not use SameSite=None without the Secure attribute",
        "Do not rely solely on SameSite for CSRF protection",
        "Do not use SameSite=Strict for cookies needed in legitimate cross-site scenarios",
        "Do not assume older browsers support SameSite attribute"
      ],
      "id": "COOKIES-SAMESITE-001",
      "refs": {
        "asvs": [
          "V3.4.1",
          "V4.2.2"
        ],
        "cwe": [
          "CWE-352",
          "CWE-346"
        ],
        "owasp": [
          "A01:2021"
        ],
        "standards": [
          "RFC 6265bis",
          "OWASP Cross-Site Request Forgery Prevention Cheat Sheet"
        ]
      },
      "requirement": "Session management and authentication cookies must include the SameSite attribute with appropriate values (Strict, Lax, or None with Secure) to prevent cross-site request forgery attacks.",
      "scope": "web-applications",
      "severity": "medium",
      "title": "Authentication and session cookies must use appropriate SameSite attribute",
      "verify": {
        "tests": [
          "Verify SameSite attribute is present on session and authentication cookies",
          "Test cross-site request scenarios respect SameSite policy",
          "Confirm SameSite=None cookies also include Secure attribute",
          "Validate cookie behavior in cross-origin iframe and AJAX scenarios",
          "Test CSRF attack mitigation with SameSite cookie configuration"
        ]
      }
    },
    {
      "detect": {
        "codeql": [
          "cookie-without-secure-flag",
          "sensitive-cookie-not-secure"
        ],
        "semgrep": [
          "javascript.express.security.express-cookie-settings.express-cookie-no-secure",
          "python.flask.security.insecure-cookies.flask-cookie-no-secure",
          "java.servlet.security.secure-cookie",
          "php.security.cookie-not-secure"
        ]
      },
      "do": [
        "Set Secure attribute on all session and authentication cookies",
        "Apply Secure flag to cookies containing sensitive user data",
        "Configure application frameworks to automatically set Secure for sensitive cookies",
        "Implement HTTPS-only cookie policies in production environments",
        "Use conditional Secure setting based on HTTPS availability in development",
        "Validate Secure attribute presence in automated security tests"
      ],
      "dont": [
        "Do not send sensitive cookies over unencrypted HTTP connections",
        "Do not omit Secure attribute from authentication or session cookies",
        "Do not rely on application-level encryption as substitute for HTTPS",
        "Do not use Secure flag for functional cookies that need HTTP access during development",
        "Do not assume Secure attribute alone provides complete cookie protection"
      ],
      "id": "COOKIES-SECURE-001",
      "refs": {
        "asvs": [
          "V3.4.1",
          "V9.1.3"
        ],
        "cwe": [
          "CWE-614",
          "CWE-319",
          "CWE-523"
        ],
        "owasp": [
          "A02:2021",
          "A05:2021"
        ],
        "standards": [
          "RFC 6265",
          "OWASP Session Management Cheat Sheet"
        ]
      },
      "requirement": "All cookies containing sensitive data, session identifiers, or authentication information must include the Secure attribute to ensure transmission only over encrypted HTTPS connections.",
      "scope": "web-applications",
      "severity": "high",
      "title": "Security-sensitive cookies must use Secure attribute for HTTPS transmission",
      "verify": {
        "tests": [
          "Verify Secure attribute is present on sensitive cookies in HTTPS responses",
          "Test that secure cookies are not transmitted over HTTP connections",
          "Confirm session cookies include Secure flag in production configuration",
          "Validate cookie security settings in web server and application configuration",
          "Test cookie behavior in mixed HTTP/HTTPS environments"
        ]
      }
    },
    {
      "detect": {
        "custom": [
          "Detect string concatenation patterns in prompt construction",
          "Identify missing input validation in prompt processing functions",
          "Flag direct user input insertion into system prompts"
        ],
        "semgrep": [
          "generic.genai.security.prompt-injection",
          "python.genai.security.unsafe-prompt-concatenation",
          "javascript.genai.security.prompt-template-injection",
          "generic.genai.security.system-prompt-exposure"
        ]
      },
      "do": [
        "Implement input validation and sanitization for all user prompts",
        "Use prompt templates with parameterized inputs rather than string concatenation",
        "Apply content filtering to detect and block prompt injection patterns",
        "Implement rate limiting and throttling for prompt processing",
        "Use separate contexts for system instructions and user inputs",
        "Log and monitor suspicious prompt patterns for security analysis"
      ],
      "dont": [
        "Do not directly concatenate user input into system prompts",
        "Do not trust user input without validation and sanitization",
        "Do not expose internal system prompts or instructions to users",
        "Do not allow unlimited or uncontrolled prompt processing",
        "Do not ignore or bypass prompt injection detection mechanisms",
        "Do not store sensitive information in prompt templates accessible to users"
      ],
      "id": "GENAI-PROMPT-001",
      "refs": {
        "asvs": [
          "V5.1.1",
          "V5.1.3",
          "V5.3.1",
          "V12.1.1"
        ],
        "cwe": [
          "CWE-77",
          "CWE-78",
          "CWE-94",
          "CWE-20"
        ],
        "owasp": [
          "LLM01:2023",
          "A03:2021"
        ],
        "standards": [
          "OWASP Top 10 for Large Language Model Applications",
          "NIST AI RMF 1.0",
          "ISO/IEC 27001:2022"
        ]
      },
      "requirement": "Generative AI applications must validate, sanitize, and control user inputs to prevent prompt injection attacks that could compromise system behavior, data access, or generate harmful content.",
      "scope": "genai-applications",
      "severity": "high",
      "title": "GenAI applications must implement prompt injection prevention controls",
      "verify": {
        "tests": [
          "Verify prompt injection attempts are detected and blocked",
          "Test that system instructions remain isolated from user inputs",
          "Confirm input validation prevents malicious prompt patterns",
          "Validate rate limiting prevents prompt abuse",
          "Test content filtering blocks harmful or manipulative inputs"
        ]
      }
    },
    {
      "detect": {
        "codeql": [
          "sensitive-data-exposure",
          "uncontrolled-data-used-in-path-expression"
        ],
        "semgrep": [
          "generic.genai.security.sensitive-data-exposure",
          "python.genai.security.pii-in-prompts",
          "javascript.genai.security.data-leakage",
          "generic.secrets.hardcoded-sensitive-data"
        ],
        "trufflehog": [
          "Personally Identifiable Information",
          "Financial Data",
          "Health Records"
        ]
      },
      "do": [
        "Implement data classification and labeling for sensitive information",
        "Use data sanitization and redaction before processing with GenAI models",
        "Apply output filtering to detect and block sensitive data in responses",
        "Implement access controls and data governance for GenAI training data",
        "Use differential privacy techniques where appropriate for model training",
        "Monitor and audit GenAI outputs for data leakage incidents"
      ],
      "dont": [
        "Do not include sensitive data in GenAI training datasets without protection",
        "Do not process personal information without proper consent and controls",
        "Do not ignore data classification when designing GenAI workflows",
        "Do not allow unrestricted access to GenAI models with sensitive training data",
        "Do not skip output validation that could expose confidential information",
        "Do not store or log sensitive data processed by GenAI systems"
      ],
      "id": "GENAI-DATA-001",
      "refs": {
        "asvs": [
          "V1.7.1",
          "V1.7.2",
          "V8.3.1",
          "V8.3.4"
        ],
        "cwe": [
          "CWE-200",
          "CWE-209",
          "CWE-532",
          "CWE-359"
        ],
        "owasp": [
          "LLM02:2023",
          "A01:2021",
          "A09:2021"
        ],
        "standards": [
          "GDPR Article 25",
          "CCPA Section 1798.100",
          "NIST Privacy Framework",
          "ISO/IEC 27701:2019"
        ]
      },
      "requirement": "Generative AI applications must implement data loss prevention controls to prevent sensitive information, personal data, or confidential business information from being exposed through model responses or training data.",
      "scope": "genai-applications",
      "severity": "critical",
      "title": "GenAI applications must protect sensitive data from exposure through model outputs",
      "verify": {
        "tests": [
          "Verify sensitive data is detected and redacted before GenAI processing",
          "Test that PII and confidential data do not appear in model outputs",
          "Confirm data access controls prevent unauthorized GenAI model usage",
          "Validate output filtering blocks sensitive information leakage",
          "Test data governance policies are enforced in GenAI workflows"
        ]
      }
    },
    {
      "detect": {
        "codeql": [
          "missing-authentication-for-critical-function",
          "weak-authentication-protocol",
          "hardcoded-credentials"
        ],
        "semgrep": [
          "generic.genai.security.weak-model-authentication",
          "python.genai.security.missing-api-auth",
          "javascript.genai.security.hardcoded-api-keys",
          "generic.genai.security.unauthorized-model-access"
        ]
      },
      "do": [
        "Implement strong authentication for GenAI model API access",
        "Apply role-based access control (RBAC) for different model capabilities",
        "Use API keys, tokens, or certificates for model authentication",
        "Implement usage quotas and rate limiting per user or application",
        "Log and monitor all GenAI model access and usage patterns",
        "Apply principle of least privilege for model access permissions"
      ],
      "dont": [
        "Do not allow anonymous or unauthenticated access to GenAI models",
        "Do not use shared credentials for GenAI model access across users",
        "Do not implement weak or easily guessable API keys",
        "Do not skip authorization checks for sensitive model operations",
        "Do not allow unlimited model usage without proper controls",
        "Do not expose internal model endpoints without security controls"
      ],
      "id": "GENAI-MODEL-001",
      "refs": {
        "asvs": [
          "V2.1.1",
          "V4.1.1",
          "V4.2.1",
          "V11.1.1"
        ],
        "cwe": [
          "CWE-287",
          "CWE-306",
          "CWE-284",
          "CWE-798"
        ],
        "owasp": [
          "LLM04:2023",
          "A07:2021",
          "A01:2021"
        ],
        "standards": [
          "NIST Cybersecurity Framework",
          "ISO/IEC 27001:2022",
          "OpenAI Usage Policies",
          "OWASP API Security Top 10"
        ]
      },
      "requirement": "Generative AI model access must implement robust authentication, authorization, and usage controls to prevent unauthorized access, model abuse, and ensure compliance with usage policies.",
      "scope": "genai-applications",
      "severity": "high",
      "title": "GenAI model access and inference must be secured with appropriate authentication and authorization",
      "verify": {
        "tests": [
          "Verify GenAI model access requires valid authentication",
          "Test that unauthorized users cannot access restricted models",
          "Confirm rate limiting and quotas are enforced per user/application",
          "Validate proper authorization for different model capabilities",
          "Test that API keys and tokens are properly validated and rotated"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.nodejs.security.blocking-event-loop",
          "javascript.nodejs.security.sync-file-operations",
          "javascript.express.security.audit.express-cors-origin-wildcard",
          "javascript.lang.security.audit.crypto-js-hardcoded-secret",
          "javascript.express.security.audit.express-helmet-disabled"
        ]
      },
      "do": [
        "Use asynchronous operations for CPU-intensive tasks",
        "Avoid synchronous file operations that can block the event loop",
        "Utilize callbacks or Promises for non-blocking execution"
      ],
      "dont": [
        "Do not perform synchronous operations in event loop",
        "Avoid synchronous file system operations"
      ],
      "id": "NODE-PREVENT-001",
      "refs": {
        "cwe": [
          "CWE-400",
          "CWE-399"
        ],
        "owasp": [
          "A7:2021",
          "A1:2021"
        ]
      },
      "requirement": "Avoid blocking the Node.js event loop with synchronous operations to maintain application responsiveness. Ensure all blocking operations are performed asynchronously to prevent delays in event processing and potential DoS vulnerabilities.",
      "scope": "web-application",
      "severity": "high",
      "title": "Prevent blocking the event loop with asynchronous operations",
      "verify": {
        "tests": [
          "Profile application performance to identify blocking operations",
          "Review codebase for synchronous calls within event loop"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.nodejs.security.request-size-limits",
          "javascript.nodejs.security.raw-body-usage",
          "javascript.express.security.audit.express-cors-origin-wildcard",
          "javascript.lang.security.audit.crypto-js-hardcoded-secret",
          "javascript.express.security.audit.express-helmet-disabled"
        ]
      },
      "do": [
        "Limit request body size for POST, PUT, and DELETE requests",
        "Validate request content type before processing",
        "Use 'raw-body' or similar libraries to set request size limits"
      ],
      "dont": [
        "Do not allow unlimited request body sizes",
        "Avoid processing requests without size validation"
      ],
      "id": "NODE-PREVENT-RESTRICT-001",
      "refs": {
        "cwe": [
          "CWE-770",
          "CWE-400"
        ],
        "owasp": [
          "A6:2021",
          "A1:2021"
        ]
      },
      "requirement": "Implement request size limits to prevent attackers from sending large request bodies that can exhaust server resources or fill up disk space. Utilize libraries like 'raw-body' to restrict the size of incoming requests based on content type.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Set request size limits to prevent DoS attacks",
      "verify": {
        "tests": [
          "Test sending requests with large payloads to verify size limits",
          "Review configuration to ensure request size limits are enforced"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "javascript.nodejs.security.callback-hell",
          "javascript.nodejs.security.promise-then-catch",
          "javascript.nodejs.security.async-await",
          "python.logging.security.audit.logging-sensitive-data",
          "java.lang.security.audit.system-exit",
          "javascript.express.security.audit.express-expose-sensitive-data"
        ]
      },
      "do": [
        "Refactor asynchronous code to use flat Promise chains",
        "Utilize .then() and .catch() functions for error handling",
        "Consider using async/await for cleaner asynchronous code"
      ],
      "dont": [
        "Do not create deeply nested callback functions",
        "Avoid relying solely on callbacks for error handling"
      ],
      "id": "NODE-PREVENT-CODE-HANDLING-001",
      "refs": {
        "cwe": [
          "CWE-829",
          "CWE-691"
        ],
        "owasp": [
          "A10:2021",
          "A8:2021"
        ]
      },
      "requirement": "Avoid nested callback functions in Node.js applications to prevent the 'Pyramid of Doom' or 'Callback Hell' issue. Utilize Promises for top-down execution and error handling to improve code readability and maintainability.",
      "scope": "web-application",
      "severity": "high",
      "title": "Use flat Promise chains to avoid Callback Hell",
      "verify": {
        "tests": [
          "Review codebase for nested callback functions",
          "Ensure Promises are used consistently for asynchronous operations",
          "Validate error handling mechanisms in asynchronous code"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "http.response.header.x-xss-protection"
        ]
      },
      "do": [
        "Set X-XSS-Protection header with '1; mode=block' to enable XSS protection in supported browsers"
      ],
      "dont": [
        "Disable X-XSS-Protection header or set it to '0'"
      ],
      "id": "HTTP-HEADERS-XSS-PROTECTION-002",
      "refs": {
        "asvs": [
          "V12.3.2",
          "V12.3.5"
        ],
        "cwe": [
          "CWE-79"
        ],
        "owasp": [
          "A03:2021"
        ]
      },
      "requirement": "Implement X-XSS-Protection header to prevent reflected cross-site scripting (XSS) attacks by stopping malicious scripts from executing.",
      "scope": "web-application",
      "severity": "high",
      "title": "Mitigate XSS attacks with X-XSS-Protection header",
      "verify": {
        "tests": [
          "Manually verify X-XSS-Protection header is set correctly"
        ]
      }
    },
    {
      "detect": {
        "semgrep": [
          "http.response.header.x-content-type-options"
        ]
      },
      "do": [
        "Set X-Content-Type-Options header with 'nosniff' to prevent MIME type sniffing"
      ],
      "dont": [
        "Disable X-Content-Type-Options header"
      ],
      "id": "HTTP-HEADERS-CONTENT-TYPE-003",
      "refs": {
        "asvs": [
          "V12.3.3",
          "V12.3.4"
        ],
        "cwe": [
          "CWE-434"
        ],
        "owasp": [
          "A06:2021"
        ]
      },
      "requirement": "Implement X-Content-Type-Options header to prevent MIME type sniffing by instructing browsers to follow the declared content type.",
      "scope": "web-application",
      "severity": "medium",
      "title": "Prevent MIME type confusion with X-Content-Type-Options header",
      "verify": {
        "tests": [
          "Manually verify X-Content-Type-Options header is set to 'nosniff'"
        ]
      }
    },
    {
      "detect": {
        "hadolint": [
          "DL3002"
        ],
        "semgrep": [
          "dockerfile.security.missing-user",
          "dockerfile.security.user-root"
        ]
      },
      "do": [
        "Use USER directive to specify non-root user",
        "Create dedicated application user in Dockerfile",
        "Set appropriate file permissions for non-root user"
      ],
      "dont": [
        "Do not run processes as root (UID 0)",
        "Do not rely on runtime user switching",
        "Do not use privileged containers unnecessarily"
      ],
      "id": "DOCKER-USER-001",
      "refs": {
        "cis": [
          "4.1"
        ],
        "nist": [
          "CM-2"
        ],
        "owasp": [
          "A06:2021"
        ]
      },
      "requirement": "Container processes must run under a non-root user account to limit privilege escalation risks.",
      "scope": "dockerfile",
      "severity": "high",
      "title": "Docker containers must not run as root user",
      "verify": {
        "tests": [
          "Verify USER directive is present and not root",
          "Test container runs with non-root UID",
          "Validate file permissions work for specified user"
        ]
      }
    }
  ],
  "schema_version": "1.0",
  "validation_hooks": {
    "codeql": [
      "cloud-service-credential-exposure",
      "command-injection",
      "cookie-without-httponly",
      "cookie-without-samesite",
      "cookie-without-secure-flag",
      "database-query-built-from-user-controlled-sources",
      "hardcoded-cloud-credentials",
      "hardcoded-credentials",
      "hardcoded-database-password",
      "hardcoded-jwt-key",
      "hardcoded-jwt-secret",
      "insecure-cookie-configuration",
      "insecure-samesite-configuration",
      "jwt-algorithm-confusion",
      "jwt-expiration-not-validated",
      "jwt-none-algorithm",
      "jwt-none-algorithm-accepted",
      "jwt-signature-not-verified",
      "jwt-without-expiration",
      "missing-authentication-for-critical-function",
      "sensitive-cookie-not-secure",
      "sensitive-data-exposure",
      "sql-injection",
      "uncontrolled-data-used-in-path-expression",
      "weak-authentication-protocol",
      "weak-jwt-algorithm",
      "weak-jwt-key-generation",
      "weak-jwt-signature",
      "xpath-injection"
    ],
    "custom": [
      "Detect string concatenation patterns in prompt construction",
      "Flag direct user input insertion into system prompts",
      "Identify missing input validation in prompt processing functions",
      "Manual code review to ensure error handling is implemented correctly",
      "Manual code review to validate error handling implementation",
      "Manual inspection to ensure error handling is correctly implemented",
      "Manual review of HTML sanitization implementation",
      "custom-laravel-app-key-001"
    ],
    "hadolint": [
      "DL3002"
    ],
    "semgrep": [
      "admin-initiated-password-reset",
      "allow-paste-functionality",
      "aspnetcore.error-handler",
      "aspnetcore.json-error-response",
      "authentication-change-notification",
      "backend-authentication-missing",
      "biometric-authentication-security",
      "cloud.aws.security.hardcoded-aws-credentials",
      "crypto.key-hardcoded",
      "crypto.weak-crypto",
      "csharp.sql.preparedstatement",
      "css.security.unsafe-css-context",
      "data-protection-controls",
      "default-user-accounts",
      "dockerfile.security.missing-user",
      "dockerfile.security.user-root",
      "dotnet.sql.command",
      "email-based-authentication",
      "expiring-authentication-renewal-instructions",
      "field-level-access",
      "function-level-access",
      "generic.genai.security.prompt-injection",
      "generic.genai.security.sensitive-data-exposure",
      "generic.genai.security.system-prompt-exposure",
      "generic.genai.security.unauthorized-model-access",
      "generic.genai.security.weak-model-authentication",
      "generic.jwt.security.algorithm-confusion",
      "generic.jwt.security.disabled-signature-verification",
      "generic.jwt.security.missing-expiration-claim",
      "generic.jwt.security.weak-key-generation",
      "generic.secrets.hardcoded-sensitive-data",
      "generic.secrets.security.detected-aws-access-key",
      "generic.secrets.security.detected-azure-key",
      "generic.secrets.security.detected-gcp-key",
      "generic.secrets.security.detected-generic-secret",
      "generic.secrets.security.detected-hardcoded-key",
      "generic.secrets.security.detected-password",
      "generic.secrets.security.detected-secret",
      "generic.secrets.security.hardcoded-secret",
      "generic.secrets.security.jwt-secret",
      "generic.validation.allowlist",
      "generic.validation.email-syntactic-check",
      "generic.xss.security.unsafe-output-encoding",
      "hibernate.querylanguage.preparedstatement",
      "http.cookie-session-id-disclosure",
      "http.cookie-session-id-fingerprinting",
      "http.cookie.samesite-lax",
      "http.cookie.samesite-strict",
      "http.response-header.content-security-policy-frame-ancestors-none",
      "http.response-header.content-security-policy-frame-ancestors-self",
      "http.response-header.content-security-policy-frame-ancestors-specific",
      "http.response-header.x-frame-options-allow-from",
      "http.response-header.x-frame-options-deny",
      "http.response-header.x-frame-options-sameorigin",
      "http.response.body: $file_extension",
      "http.response.body: $version",
      "http.response.header.x-content-type-options",
      "http.response.header.x-xss-protection",
      "http.route.documentation: $true",
      "http.route.monitoring: $true",
      "http.server.directory-listing.enabled: $true",
      "http.server.trace.enabled: $true",
      "http.session-id-brute-force",
      "http.session-id-weak-entropy",
      "identity-proofing-recovery",
      "input-validation.column-name",
      "input-validation.table-name",
      "insecure-lookup-secrets-storage",
      "insecure-password-reset-process",
      "insecure-random-number-generator",
      "java.command-injection",
      "java.jdbc.SQLInjection",
      "java.jwt.security.jwt-hardcode-secret",
      "java.jwt.security.jwt-hardcoded-key",
      "java.jwt.security.jwt-no-expiration",
      "java.jwt.security.jwt-signature-bypass",
      "java.jwt.security.jwt-weak-algorithm",
      "java.lang.security.audit.system-exit",
      "java.os-command-injection",
      "java.servlet.error-handler",
      "java.servlet.error-page",
      "java.servlet.security.httponly-cookie",
      "java.servlet.security.samesite-cookie",
      "java.servlet.security.secure-cookie",
      "java.spring.security.audit.spring-csrf-disabled",
      "java.spring.security.audit.spring-security-headers",
      "java.spring.security.audit.spring-sqli",
      "java.spring.security.audit.spring-unvalidated-redirect",
      "java.spring.security.audit.spring-xss",
      "java.spring.security.hardcoded-database-password",
      "java.spring.security.spring-email-validation",
      "java.spring.security.spring-input-validation",
      "java.sql.SQLInjection",
      "java.sql.callablestatement",
      "java.sql.preparedstatement",
      "java.xpath-injection",
      "java.xpath-variable-injection",
      "javascript.angular.security.angular-bypass-security-trust",
      "javascript.browser.security.audit.dom-based-xss",
      "javascript.express.security.audit.express-cors-origin-wildcard",
      "javascript.express.security.audit.express-expose-sensitive-data",
      "javascript.express.security.audit.express-helmet-disabled",
      "javascript.express.security.audit.express-jwt-not-revoked",
      "javascript.express.security.audit.express-session-no-secret",
      "javascript.express.security.express-cookie-settings.express-cookie-no-httponly",
      "javascript.express.security.express-cookie-settings.express-cookie-no-samesite",
      "javascript.express.security.express-cookie-settings.express-cookie-no-secure",
      "javascript.express.security.express-hardcoded-secret",
      "javascript.genai.security.data-leakage",
      "javascript.genai.security.hardcoded-api-keys",
      "javascript.genai.security.prompt-template-injection",
      "javascript.jsonwebtoken.security.jwt-algorithm-none",
      "javascript.jsonwebtoken.security.jwt-hardcode-key",
      "javascript.jsonwebtoken.security.jwt-hardcode-secret",
      "javascript.jsonwebtoken.security.jwt-missing-expiration",
      "javascript.jsonwebtoken.security.jwt-verify-none",
      "javascript.lang.security.audit.crypto-js-hardcoded-secret",
      "javascript.lang.security.audit.hardcoded-secret",
      "javascript.lang.security.audit.path-traversal",
      "javascript.lang.security.audit.tls-min-version",
      "javascript.lit.security.lit-unsafe-html",
      "javascript.nodejs.security.async-await",
      "javascript.nodejs.security.blocking-event-loop",
      "javascript.nodejs.security.callback-hell",
      "javascript.nodejs.security.promise-then-catch",
      "javascript.nodejs.security.raw-body-usage",
      "javascript.nodejs.security.request-size-limits",
      "javascript.nodejs.security.sync-file-operations",
      "javascript.react.security.react-dangerously-set-inner-html",
      "javascript.security.allowlist-validation",
      "javascript.security.dom-based-xss",
      "javascript.security.unsafe-javascript-context",
      "javascript.sequelize.security.hardcoded-secret",
      "logging.alerting-mechanisms",
      "logging.application-errors",
      "logging.authentication-failure",
      "logging.authentication-success",
      "logging.authorization-failure",
      "logging.centralized-collection",
      "logging.customizable-levels",
      "logging.encryption-rest",
      "logging.encryption-transit",
      "logging.event-attributes",
      "logging.high-risk-functionality-usage",
      "logging.input-validation-failure",
      "logging.log-handler",
      "logging.log-rotation",
      "logging.output-validation-failure",
      "logging.retention-policies",
      "logging.review-policies",
      "logging.sanitization",
      "logging.secure-transmission",
      "logging.system-events",
      "logging.testing-verification",
      "logging.time-synchronization",
      "minimum-disclosure",
      "multi-factor-authentication",
      "multi-factor-authentication-secrets-reuse",
      "no-periodic-rotation",
      "oob-authentication-protection",
      "password-field-type",
      "password-hints-and-secret-questions",
      "php.laravel.security.cookie-settings",
      "php.laravel.security.key-generation",
      "php.security.cookie-no-samesite",
      "php.security.cookie-not-httponly",
      "php.security.cookie-not-secure",
      "php.security.ini.app-debug",
      "python.django.security.audit.avoid-csrf-disable",
      "python.django.security.audit.avoid-unsafe-deserialization",
      "python.django.security.audit.session-cookie-httponly-false",
      "python.django.security.audit.session-cookie-secure-false",
      "python.django.security.audit.xss-filter-disabled",
      "python.django.security.audit.xss.direct-use-of-httpresp-write",
      "python.django.security.django-hardcoded-db-password",
      "python.django.security.django-hardcoded-secret",
      "python.django.security.django-input-validation",
      "python.django.security.injection.sql.django-sql-injection",
      "python.flask.security.audit.direct-use-of-jinja2",
      "python.flask.security.audit.flask-cors-origin-wildcard",
      "python.flask.security.insecure-cookies.flask-cookie-no-httponly",
      "python.flask.security.insecure-cookies.flask-cookie-no-samesite",
      "python.flask.security.insecure-cookies.flask-cookie-no-secure",
      "python.genai.security.missing-api-auth",
      "python.genai.security.pii-in-prompts",
      "python.genai.security.unsafe-prompt-concatenation",
      "python.jwt.security.jwt-hardcode-key",
      "python.jwt.security.jwt-hardcode-secret",
      "python.jwt.security.jwt-missing-exp",
      "python.jwt.security.jwt-none-alg",
      "python.jwt.security.jwt-none-algorithm",
      "python.lang.security.audit.dangerous-system-call",
      "python.lang.security.audit.hardcoded-password",
      "python.logging.security.audit.logging-sensitive-data",
      "python.requests.security.disabled-cert-validation",
      "python.sqlalchemy.security.audit.sqlalchemy-execute-raw-query",
      "sensitive-data-http-leakage",
      "sensitive-data-identification",
      "session-management-security",
      "session-token-verification-trusted-backend",
      "spring.exception-handler",
      "spring.problem-detail",
      "strong-authentication-intra-service",
      "suspicious-authentication-attempts",
      "terraform.aws.security.aws-s3-bucket-public-read-prohibited",
      "tls-client-certificate-validation",
      "tls-internal-service-communication",
      "trusted-certificate-internal-services",
      "unique-reference-tokens",
      "user-enumeration-protection",
      "verify-password-exactly",
      "yaml.docker-compose.security.writable-filesystem-service"
    ],
    "trufflehog": [
      "ASP.NET Core Error Handling Configuration",
      "AWS Access Key",
      "AWS Secret Key",
      "Allowlist validation issues",
      "Azure Storage Account Key",
      "Basic Auth",
      "Command Injection",
      "Content-Security-Policy",
      "Credentials Exposure",
      "Data Integrity",
      "Data Leakage",
      "Data Retention",
      "Database Connection String",
      "Email address validation issues",
      "Financial Data",
      "Generic API Key",
      "GitHub Token",
      "Google Cloud Service Account",
      "Health Records",
      "JWT Secret",
      "JWT Signing Key",
      "Java Error Handling Configuration",
      "MySQL Password",
      "Personally Identifiable Information",
      "PostgreSQL Password",
      "Private Key",
      "SQL Injection",
      "SameSite Cookie Attribute",
      "Sensitive Data Exposure",
      "Sensitive Data Leakage",
      "Spring Error Handling Configuration",
      "Structured data validation issues",
      "X-Frame-Options",
      "XPath Injection"
    ]
  }
}